<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="packages.xsl"?>
<skript lang = "german">
  <kurztitel>Java</kurztitel>
  <pakete javacompilefirst = "name/panitz/adt/*.java name/panitz/crempel/util/*.java"/>
  <titelseite>
    <titel>Eine Java Einführung in die Programmierung</titel>
    <untertitel>(Entwurf)</untertitel>
    <semester>WS 05/06</semester>
    <autor>Sven Eric Panitz</autor>
    <institution>FH Wiesbaden</institution>
    <disclaimer>Die vorliegende Fassung des Skriptes hat mitlerweile schon eine
kleine Geschichte hinter sich: es startete als Skript für die
Programmiervorlesungen an 
der TFH-Berlin im Studiengang Medieninformatik im WS02/03
als dreiteilige Vorlesung. 
Im SS05 sind diese drei Teile zu einem Skript zusammengeführt worden, 
das speziell für die Vorlesung
Java des 3. Semester im Studiengang allgemeine Informatik an der FH
Wiesbaden ausgerichtet war. 
Dabei wurde versucht auf die Vorkenntnisse der Studenten aus den
Vorlesungen C und C++ aufzubauen.<p/>

Mit diesem Semester habe ich mich entschieden, das  Skript wieder als
allgemeine Einführung in die Programmierung mit Java zu gestalten und somit
ein monolythisches Skript, das für sich stehen kann, zu erhalten. 
So ergibt sich, daß viele Kapitel Wiederholungen von Stoff aus den
C-Vorlesungen und auch der Vorlesung Informatik 1 sind. In der Vorlesung
werden diese Kapitel allerdings des Umfangs wegen nicht behandelt werden.<p/>

Trotz der nun schon etwas längeren Historie des Skripts, ist es naturgemäß 
 in Aufbau und Qualität nicht mit einem Buch
vergleichbar. Flüchtigkeits- und Tippfehler werden sich im Eifer
des Gefechtes nicht vermeiden lassen und wahrscheinlich in nicht
geringem Maße auftreten. Ich bin natürlich stets dankbar, wenn
ich auf solche aufmerksam gemacht werde und diese korrigieren
kann.<p/>

Der Quelltext dieses Skripts ist eine XML-Datei, die durch eine XQuery 
in eine <LaTeX/>-Datei transformiert und für die schließlich eine
pdf-Datei und eine postscript-Datei
erzeugt wird. 
Beispielprogramme werden direkt aus dem Skriptquelltext extrahiert und sind
auf der Webseite herunterzuladen.<p/></disclaimer>
  </titelseite>
  <toc/>
  <kapitel titel = "Einführung">
    <section titel = "Ziel der Vorlesung">
Diese Vorlesung setzt sich zum Ziel, die Grundlagen der Programmierung zu 
vermitteln. Hierzu gehören insbesondere gängige Algorithmen und 
Programmiermuster sowie die gebräuchlichsten Datentypen. Die verwendete
Programmiersprache ist aus pragmatischen Gründen <em>Java</em>. Die
Vorlesung will aber kein reiner Javakurs sein, sondern ermöglichen, die
gelernten Konzepte schnell auch in anderen Programmiersprachen umzusetzen.
Programmierung wird nicht allein als die eigentliche Codierung des 
Programms verstanden, sondern Tätigkeiten wie Spezifikation, Modellierung,
Testen etc.<white/>werden als Teildisziplinen der Programmierung verstanden.<p/>
Desweiteren soll die Vorlesung mit der allgemeinen Terminologie der Informatik
vertraut machen.</section>
    <section titel = "Programmieren">
      <subsection titel = "Disziplinen der Programmierung">
Mit dem Begriff Programmierung wird zunächst 
die eigentliche Codierung eines Programms assoziiert. 
Eine genauerer Blick offenbart jedoch, daß dieses nur ein kleiner 
Teil von vielen recht unterschiedlichen Schritten ist, die zur
Erstellung von Software notwendig sind:<itemize>
          <item><b>Spezifikation:</b> Bevor eine Programmieraufgabe
bewerkstelligt werden kann, muß  das zu lösende
Problem spezifiziert werden. Dieses kann informell durch eine
natürlichsprachliche Beschreibung bis hin zu mathematisch
beschriebenen Funktionen geschehen. Gegen die Spezifikation 
wird programmiert. Sie beschreibt das gewünschte Verhalten
des zu erstellenden Programms. </item>
          <item><b>Modellieren:</b> Bevor es an die eigentliche Codierung
geht, wird in der Regel die Struktur des Programms modelliert.
Auch dieses kann in unterschiedlichen Detaillierungsgraden geschehen.
Manchmal reichen Karteikarten als hilfreiches Mittel aus,
andernfalls empfiehlt sich eine umfangreiche Modellierung 
mit Hilfe rechnergestützter Werkzeuge. Für die objektorientierte
Programmierung hat sich  UML als eine geeignete Modellierungssprache
durchgesetzt. In ihr lassen sich Klassendiagramme, Klassenhierarchien
und Abhängigkeiten graphisch darstellen. Mit bestimmten Werkzeugen
wie <em>Together</em> oder <em>Rational Rose</em> läßt sich direkt 
für eine UML-Modellierung Programmtext generieren.</item>
          <item><b>Codieren:</b> Die eigentliche Codierung ist in der
Regel der einzige Schritt, der direkt Code in der gewünschten
Programmiersprache von Hand erzeugt. Alle anderen Schritte 
der Programmierung
sind mehr oder weniger unabhängig von der zugrundeliegenden
Programmiersprache.<p/>
Für die Codierung empfiehlt es sich, Konventionen zu verabreden, wie 
der Code geschrieben wird, was für Bezeichner benutzt werden, in
welcher Weise der Programmtext eingerückt wird. Entwicklungsabteilungen
haben zumeist schriftlich verbindlich festgeschriebene Richtlinien
für den Programmierstil. Dieses erleichtert, den Code der Kollegen im
Projekt schnell zu verstehen.</item>
          <item><b>Testen:</b> Beim Testen sind generell zu unterscheiden:<itemize>
              <item><em>Entwicklertests:</em> Diese werden von den Entwicklern
während der Programmierung selbst geschrieben, um einzelne Programmteile
(Methoden<index entry = "Methode"/>, 
Funktionen) separat zu testen. Es gibt eine Schule, die
propagiert, Entwicklertests vor dem Code zu 
schreiben (<em>test first</em>). Die Tests dienen in diesem Fall als
kleine Spezifikationen.</item>
              <item><em>Qualitätssicherung:</em> In der Qualitätssicherung werden
die fertigen Programme gegen ihre Spezifikation getestet (<em>black
box tests</em>). Hierzu
werden in der Regel automatisierte Testläufe geschrieben. 
Die Qualitätssicherung ist  personell von der Entwicklung
getrennt. Es kann
in der Praxis durchaus vorkommen, daß die Qualitätsabteilung 
mehr Mitarbeiter hat als die Entwicklungsabteilung.</item>
            </itemize></item>
          <item><b>Optimieren:</b> Sollten sich bei Tests oder in der 
Praxis Performanzprobleme zeigen, sei es durch zu hohen 
Speicherverbrauch als auch durch zu lange Ausführungszeiten, so wird
versucht, ein Programm zu optimieren. Hierzu bedient man sich
spezieller Werkzeuge (<em>profiler</em>), die für einen Programmdurchlauf
ein Raum- und Zeitprofil erstellen. In diesem Profil können 
Programmteile, die besonders häufig durchlaufen werden, oder Objekte,
die im großen Maße Speicher belegen, identifiziert werden. Mit diesen 
Informationen lassen sich gezielt inperformante Programmteile 
optimieren.</item>
          <item><b>Verifizieren:</b> Eine formale Verifikation eines Programms
ist ein mathematischer Beweis der Korrektheit bezüglich der
Spezifikation. Das setzt natürlich voraus, daß die Spezifikation
auch formal vorliegt. Man unterscheidet:<itemize>
              <item><em>partielle Korrektheit:</em> wenn das Programm für
eine bestimte Eingabe ein Ergebnis liefert, dann ist dieses bezüglich
der Spezifikation korrekt.</item>
              <item><em>totale Korrektheit:</em> Das Programm ist partiell korrekt
und terminiert für jede Eingabe, d.h.<white/>liefert immer nach endlich
langer Zeit ein Ergebnis.</item>
            </itemize>
Eine formale Verifikation ist notorisch schwierig und allgemein nicht
automatisch durchführbar. In der Praxis werden nur in ganz speziellen
kritischen Anwendungen formale Verifikationen durchgeführt, z.B.<white/>bei
Steu\-er\-un\-gen gefahrenträchtiger Maschinen, so daß Menschenleben von
der Korrektheit eines Programms abhängen können. </item>
          <item><b>Wartung/Pflege:</b> den größten Teil seiner Zeit verbringt
ein Programmierer nicht mit der Entwicklung neuer Software, sondern mit der Wartung bestehender Software. Hierzu gehören
die Anpassung des Programms an neue Versionen benutzter Bibliotheken oder  des Betriebssystems, auf dem das Programm läuft, 
sowie die Korrektur von Fehlern.</item>
          <item><b>Debuggen:</b> Bei einem  Programm ist immer damit
zu rechnen, daß es Fehler enthält. Diese Fehler werden im besten
Fall von der Qualitätssicherung entdeckt, im schlechteren Fall treten 
sie beim Kunden auf. Um  Fehler im Programmtext zu finden,
gibt es Werkzeuge, die ein schrittweises Ausführen des Programms
ermöglichen <em>(debugger)</em>. Dabei lassen sich die Werte, die in
bestimmten Speicherzellen stehen, auslesen und auf diese Weise der Fehler
finden. 
 </item>
          <item><b>Internationalisieren (I18N)<footnote>I18N ist eine Abkürzung
für das Wort <em>internationalization</em>, das mit einem i beginnt, mit
einem n endet und dazwischen 18 Buchstaben hat.</footnote>:</b> Softwarefirmen
wollen möglichst
viel Geld mit ihrer Software verdienen und streben deshalb an, ihre
Programme möglichst weltweit zu vertreiben. Hierzu muß gewährleistet
sein, daß das Programm auf weltweit allen Plattformen läuft und
mit verschiedenen Schriften und Textcodierungen umgehen kann. Das
Programm sollte ebenso wie mit lateinischer Schrift auch mit Dokumenten
in anderen Schriften umgehen können. Fremdländische Akzente und  
deutsche Umlaute sollten bearbeitbar sein. Aber auch unterschiedliche
Tastaturbelegungen bis hin zu unterschiedlichen Schreibrichtungen sollten
unterstützt werden. <p/>
Die Internationalisierung ist ein weites Feld, und wenn nicht am Anfang
der Programmerstellung hierauf Rücksicht genommen wird, so ist es schwer,
nachträglich das Programm zu internationalisieren.</item>
          <item><b>Lokalisieren (L12N):</b> Ebenso wie die 
Internationalisierung beschäftigt
sich die Lokalisierung damit, daß ein Programm in anderen Ländern
eingesetzt werden kann. Beschäftigt sich die Internationalisierung damit,
daß fremde Dokumente bearbeitet werden können, versucht die Lokalisierung,
das Programm komplett für die fremde Sprache zu übersetzen. Hierzu 
gehören Menueinträge in der fremden Sprache, Beschriftungen der
Schaltflächen oder auch Fehlermeldungen in fremder Sprache und Schrift.
Insbesondere haben verschiedene Schriften unterschiedlichen
Platzbedarf; auch das ist beim Erstellen der Programmoberfläche
zu berücksichtigen.</item>
          <item><b>Portieren:</b> Oft wird es nötig, ein Programm auf eine andere
Plattform zu portieren. Ein unter Windows erstelltes Programm soll
z.B.<white/>auch auf Unix-Systemen zur Verfügung stehen. </item>
          <item><b>Dokumentieren:</b> Der Programmtext allein reicht in der Regel nicht aus, damit das Programm von Fremden oder 
dem Programmierer selbst nach
geraumer Zeit gut verstanden werden kann. Um ein Programm näher
zu erklären, wird im Programmtext Kommentar eingefügt. Kommentare
erklären die benutzten Algorithmen, die Bedeutung bestimmter Datenfelder
oder die Schnittstellen und Benutzung bestimmter Methoden<index entry = "Methode"/>.<p/>
Es ist zu empfehlen, sich anzugewöhnen, Quelltextdokumentation immer auf
Englisch zu schreiben. Es ist oft nicht abzusehen, wer einmal einen
Programmtext zu sehen bekommt. Vielleicht ein japanischer Kollege,
der das Programm für Japan lokalisiert, oder der irische Kollege, der,
nachdem die Firma mit einer anderen Firma fusionierte, das 
Programm auf ein anderes Betriebssystem portiert, oder vielleicht
die englische Werksstudentin, die für ein Jahr in der Firma arbeitet.</item>
        </itemize></subsection>
      <subsection titel = "Was ist ein Programm">
Die Frage danach, was ein Programm eigentlich ist, läßt sich 
aus verschiedenen Perspektiven recht unterschiedlich beantworten.<subsubsection titel = "pragmatische Antwort">
Eine Textdatei, die durch ein anderes  Programm in einen 
ausführbaren Maschinencode
übersetzt wird. Dieses andere Programm ist ein Übersetzer, 
engl.<white/><em>compiler</em>.</subsubsection><subsubsection titel = "mathematische Antwort">
Eine Funktion, die deterministisch für Eingabewerte 
einen Ausgabewert berechnet.</subsubsection><subsubsection titel = "sprachwissenschaftliche Antwort">
Ein Satz einer durch eine Grammatik beschriebenen Sprache mit einer
operationalen Semantik.</subsubsection><subsubsection titel = "operationale Antwort">
Eine Folge von durch den Computer ausführbaren Befehlen, die den Speicher des
Computers manipulieren.</subsubsection></subsection>
      <subsection titel = "Klassifizierung von Programmiersprachen">
Es gibt mittlerweile mehr Programmiersprachen als 
natürliche Sprachen.<footnote>Wer Interesse hat, kann 
im Netz einmal suchen, ob er eine Liste
von Programmiersprachen findet.</footnote> Die meisten Sprachen führen
entsprechend nur ein Schattendasein und die Mehrzahl der Programme
konzentriert sich auf einige wenige Sprachen. Programmiersprachen lassen
sich nach den unterschiedlichsten Kriterien klassifizieren.   <subsubsection titel = "Hauptklassen">
Im folgenden eine hilfreiche Klassifizierung in fünf verschiedene 
Hauptklassen.<itemize><item><b>imperativ</b> (C, Pascal, Fortran, Cobol): das
Hauptkonstrukt dieser Sprachen sind Befehle, die den Speicher
manipulieren. </item><item><b>objektorientiert</b> (Java, C++, C\#, Eiffel, Smalltalk):
Daten werden in Form von Objekten organisiert. Diese Objekte
bündeln mit den Daten auch die auf diesen Daten anwendbaren
Methoden<index entry = "Methode"/>.</item><item><b>funktional</b> (Lisp, ML, Haskell, Scheme, Erlang, Clean):
Programme werden als mathematische Funktionen verstanden und auch
Funktionen  können Daten sein. Dieses Programmierparadigma versucht,
sich möglichst weit von der Architektur des Computers zu lösen.
Veränderbare Speicherzellen gibt es in rein funktionalen Sprachen
nicht und erst recht keine Zuweisungsbefehle.</item><item><b>Skriptsprachen</b> (Perl, AWK): solche Sprachen sind dazu
entworfen, einfache kleine Programme schnell zu erzeugen. Sie haben
meist kein Typsystem und nur eine begrenzte Zahl an 
Strukturierungsmöglichkeiten, oft aber eine mächtige Bibliothek, um
Zeichenketten zu manipulieren.</item> <item><b>logisch</b> (Prolog): aus der KI (künstlichen Intelligenz)
stammen logische Programmiersprachen. Hier wird ein Programm als
logische Formel, für die ein Beweis gesucht wird, verstanden.</item></itemize></subsubsection><subsubsection titel = "Ausführungsmodelle">
Der Programmierer schreibt  den lesbaren Quelltext seines Programmes.
Um ein Programm auf einem Computer laufen zu lassen, muß es erst 
in einen Programmcode übersetzt werden, den der Computer versteht.
Für diesen Schritt gibt es auch unterschiedliche Modelle:<itemize>
            <item><b>kompiliert</b> (C, Cobol, Fortran): in einem Übersetzungsschritt
wird aus dem Quelltext direkt das ausführbare Programm erzeugt, das dann
unabhängig von irgendwelchen Hilfen der Programmiersprache ausgeführt werden
kann.</item>
            <item><b>interpretiert</b> (Lisp, Scheme): der Programmtext wird nicht
in eine ausführbare Datei übersetzt, sondern durch einen Interpreter
Stück für Stück anhand des Quelltextes ausgeführt. Hierzu muß stets der
Interpreter zur Verfügung stehen, um das Programmm auszuführen. 
Interpretierte Programme sind langsamer in der Ausführung als
übersetzte Programme.</item>
            <item><b>abstrakte Maschine über <em>byte code</em></b> (Java, ML): dieses ist quasi eine Mischform aus den obigen zwei Ausführungsmodellen.
Der Quelltext wird übersetzt in Befehle nicht für einen konkreten
Computer, sondern für eine abstrakte Maschine. Für diese abstrakte Maschine
steht dann ein Interpreter zur Verfügung. Der Vorteil ist, daß durch
die zusätzliche Abstraktionsebene der Übersetzer unabhängig von einer konkreten
Maschine Code erzeugen kann und das Programm auf auf allen Systemen laufen
kann, für die es einen Interpreter der abstrakten Maschine gibt.</item>
          </itemize>


Es gibt Programmiersprachen, für die sowohl Interpreter als auch Übersetzer
zur Verfügung stehen. In diesem Fall wird der Interpreter gerne zur 
Programmentwicklung benutzt und der Übersetzer erst, wenn das Programm
fertig entwickelt ist.<paragraph titel = "Übersetzung und Ausführung von Javaprogrammen">
Da Java sich einer abstrakten Maschine bedient, sind, um zur Ausführung 
zu gelangen, sowohl 
ein Übersetzer als auch ein Interpreter notwendig.
Der zu übersetzende Quelltext steht in Dateien mit der Endung <tt>.java</tt>,
der erzeugte <em>byte code</em> in Dateien mit der Endung <tt>.class</tt><p/> 
Der Javaübersetzer kann von der Kommandozeile mit dem Befehl <tt>javac</tt>
aufgerufen werden. Um eine Programmdatei <tt>Test.java</tt> zu übersetzen,
kann folgendes Kommando eingegeben werden:<code>javac Test.java </code>
Im  Falle einer fehlerfreien Übersetzung wird eine Datei <tt>Test.class</tt>
im Dateisystem erzeugt. Dieses erzeugte Programm wird allgemein 
durch folgendes Kommando im Javainterpreter ausgeführt:<code>java Test</code></paragraph></subsubsection><subsubsection titel = "Übersetzen eines erste Javaprogramms">
Um ein lauffähiges Javaprogramm zu schreiben, ist es notwendig,
eine ganze Reihe von Konzepten Javas zu kennen, die nicht eigentliche
Kernkonzepte der objektorientierten Programmierung sind.
Daher geben wir hier ein minimales  Programm an, daß eine Ausgabe auf den Bildschirm macht:<code class = "FirstProgram"
                package = "."
                lang = "java">class FirstProgram{
  public static void main(String [] args){
    System.out.println(&quot;hello world&quot;);
  }
}</code>
In den kommenden  Wochen werden wir nach und nach die einzelne Bestandteile
dieses Minimalprogrammes zu verstehen lernen.<aufgabe>Schreiben Sie das obige Programm mit einen Texteditor ihrer
Wahl. Speichern Sie es als <tt>FirstProgram.java</tt> ab.
Übersetzen Sie es mit dem Java-Übersetzer <tt>javac</tt>.
 Es entsteht eine Datei <tt>FirstProgram.class</tt>. Führen 
Sie das Programm mit
dem Javainterpreter <tt>java</tt> aus. Führen Sie dieses sowohl einmal auf
Linux als auch einmal unter Windows durch.</aufgabe>


Wir können in der Folge diesen Programmrumpf benutzen, um beliebige Objekte 
auf den Bildschirm auszugeben. Hierzu werden wir das <tt>&quot;hello world&quot;</tt>
durch andere Ausdrücke ersetzen.

Wollen Sie z.B.<w/> eine Zahl auf dem Bildschirm ausgeben, so ersetzen Sie
den in Anführungszeichen eingeschlossenen Ausdruck durch diese Zahl:
 lang=&quot;java&quot;<code class = "Answer"
                lang = "java">class Answer {
  public static void main(String [] args){
    System.out.println(42);
  }
}</code></subsubsection></subsection>
      <subsection titel = "Arbeitshypothese">
Bevor im nächsten Kapitel mit der eigentlichen objektorientierten
Programmierung begonnen wird, wollen wir 
für den weiteren Verlauf der Vorlesung eine Arbeitshypothese
aufstelllen:<quote>Beim Programmieren versuchen wir, zwischen Daten und Programmen 
zu unterscheiden. Programme manipulieren Daten, indem sie sie 
löschen, anlegen oder überschreiben.<p/>
Daten können dabei einfache Datentypen sein, die Zahlen, Buchstaben oder
Buchstabenketten (Strings) repräsentieren, oder aber beliebig strukturierte
Sammlungen von Daten wie z.B.<white/>Listen, Tabellen, Baum- oder
Graphstrukturen. </quote>

Wir werden im Laufe der Vorlesung immer wieder zu prüfen haben, ob diese
starke Trennung zwischen Daten und Programmen gerechtfertigt ist.</subsection>
    </section>
  </kapitel>
  <kapitel titel = "Objektorientierte Programmierung">
    <section titel = "Grundkonzepte der Objektorientierung">
      <subsection titel = "Objekte und Klassen">
Die Grundidee der objektorientierten Programmierung ist, Daten,
die zusammen ein größeres zusammenhängendes Objekt beschreiben,
zusammenzufassen. Zusätzlich fassen wir mit diesen Daten 
noch die 
Programmteile zusammen, die diese Daten manipulieren. Ein Objekt enthält 
also nicht nur die reinen Daten,
die es repräsentiert, sondern auch Programmteile, die Operationen auf diesen
Daten durchführen. Insofern wäre vielleicht <em>subjektorientierte 
Programmierung</em>
ein passenderer Ausdruck, denn die Objekte sind nicht passive Daten, die von
außen manipuliert werden, sondern enthalten selbst als integralen Bestandteil 
Methoden<index entry = "Methode"/>, die ihre Daten manipulieren können.<subsubsection titel = "Objektorientierte Modellierung">
Bevor wir etwas in Code gießen, wollen wir ersteinmal eine informelle
Modellierung der Welt, für die  ein Programm geschrieben werden soll,
vornehmen. Hierzu empfiehlt es sich durchaus, in einem Team zusammenzusitzen
und auf Karteikarten aufzuschreiben, was es denn für Objekte in der Welt gibt,
die wir modellieren wollen.<p/>

Stellen wir uns hierzu einmal vor, wir sollen ein Programm zur
Bibliotheksverwaltung schreiben. Jetzt überlegen wir einmal, was gibt es denn
für Objektarten, die alle zu den Vorgängen in einer Bibliothek gehören. Hierzu
fällt uns vielleicht folgende Liste ein:<itemize>
            <item>Personen, die Bücher ausleihen wollen.</item>
            <item>Bücher, die ausgeliehen werden können.</item>
            <item>Tatsächliche Ausleihvorgänge, die ausdrücken, daß ein Buch bis zu einem
bestimmten Zeitraum von jemanden ausgeliehen wurde.</item>
            <item>Termine, also Objekte, die ein bestimmtes Datum kennzeichnen.</item>
          </itemize>  

Nachdem wir uns auf diese vier für unsere Anwendung wichtigen Objektarten
geinigt haben, nehmen wir vier Karteikarten und schreiben jeweils eine der
Objektarten als Überschrift auf diese Karteikarten. <p/>


Jetzt haben wir also Objektarten identifiziert. Im nächsten Schritt ist zu
überlegen, was für Eigenschaften diese Objekte haben. Beginnen wir für die
Karteikarte, auf der wir als Überschrift <em>Person</em> geschrieben haben.
Was interessiert uns an Eigenschaften einer Person? Wahrscheinlich ihr Name
mit Vornamen, Straße und Ort sowie Postleitzahl. Das sollten die Eigenschaften
einer Person sein, die für ein Bibliotheksprogramm notwendig sind. Andere
mögliche Eigenschaften wie Geschlecht, Alter, Beruf oder ähnliches
interessieren uns in diesem Kontext nicht. Jetzt schreiben wir die
Eigenschaften, die uns von einer Person interessieren, auf die Karteikarte mit
der Überschrift Person. <p/>

Schließlich müssen wir uns Gedanken darüber machen, was diese Eigenschaften
eigentlich für Daten sind. Name, Vorname, Straße und Wohnort sind sicherlich
als Texte abzuspeichern oder, wie der Informatiker gerne sagt, als
Zeichenketten. Die Postleitzahl ist hingegen als eine Zahl
abzuspeichern. Diese Art, von der die einzelnen Eigenschaften sind, nennen wir
ihren Typ. Wir schreiben auf die Karteikarte für die 
Objektart <em>Person</em> vor jede der Eigenschaften noch den Typ, den diese
Eigenschaft hat.<footnote>Es mag vielleicht verwundern, warum wir den Typ vor
die Eigenschaft und nicht etwa hinter sie schreiben. Dieses ist eine sehr alte
Tradition in der Informatik.</footnote>  Damit erhalten wir für die 
Objektart <em>Person</em> die in Abbildung<white/><ref name = "PersonKarte"/> gezeigte Karteikarte.<bild name = "PersonKarte"
                pdfscale = "0.6"
                psscale = "0.6"
                caption = "Modellierung einer Person."/> 


Gleiches können wir für die Objektart  <em>Buch</em> und für die 
Objektart <em>Datum</em>  machen. Wir erhalten dann eventuell die Karteikarten
aus Abbildung <ref name = "BuchKarte"/> und <ref name = "DatumKarte"/> .<bild name = "BuchKarte"
                pdfscale = "0.6"
                psscale = "0.6"
                caption = "Modellierung eines Buches."/><bild name = "DatumKarte"
                pdfscale = "0.6"
                psscale = "0.6"
                caption = "Modellierung eines Datums."/> 


Wir müssen uns schließlich nur noch um die Objektart einer Buchausleihe
kümmern. Hier sind drei Eigenschaften interessant: wer hat das Buch geliehen,
welches Buch wurde verliehen und wann muß es zurückgegeben werden. Wir können
also drei Eigenschaften auf die Karteikarte schreiben. Was sind die Typen dieser drei Eigenschaften? Diesmal sind es keine Zahlen oder Zeichenketten,
sondern Objekte der anderen drei bereits modellierten Objektarten. Wenn wir
nämlich eine Karteikarte schreiben, dann erfinden wir gerade einen neuen Typ,
den wir für die Eigenschaften anderer Karteikarten benutzen können.<p/>

Somit erstellen wir eine Karteikarte für den Objekttyp <em>Ausleihe</em>, wie
sie in Abbildung <ref name = "AusleihKarte"/> zu sehen ist.<bild name = "AusleihKarte"
                pdfscale = "0.6"
                psscale = "0.6"
                caption = "Modellierung eines Ausleihvorgangs."/></subsubsection><subsubsection titel = "Klassen in Java">
Wir haben in einem Modellierungsschritt im letzten Abschnitt verschiedene
Objektarten identifiziert und ihre Eigenschaften spezifiziert. Dazu haben
wir vier Karteikarten geschrieben. Jetzt können wir versuchen, diese Modellierung
in Java umzusetzen.  
In Java  beschreibt eine Klasse eine Menge von Objekten gleicher Art. 
Damit entspricht eine Klasse einer der Karteikarten in unsrer Modellierung.
Die
Klassendefinition ist eine Beschreibung der möglichen Objekte. In ihr
ist definiert, was für Daten zu den Objekten gehören. Zusätzlich können
wir in einer Klasse noch schreiben, welche Operationen
auf diesen Daten angewendet werden können. Klassendefinitionen sind die
eigentlichen Programmtexte, die der Programmierer schreibt. <wichtig>
In Java steht
genau eine Klassendefinition<footnote>Auch hier werden wir Ausnahmen
kennenlernen.</footnote> in genau einer Datei. 
Die Datei hat dabei den Namen der Klasse mit der Endung <tt>.java</tt>.</wichtig>

In Java wird eine Klasse durch das Schlüsselwort <tt>class</tt>, gefolgt
von dem Namen, den man für die Klasse gewählt hat, deklariert. 
Anschließend folgt in
geschweiften Klammern der Inhalt der Klasse bestehend aus Felddefinitionen
und Methodendefinitionen.<p/>
Die einfachste Klasse, die in Java denkbar ist, ist eine Klasse ohne
Felder oder Methoden:<code lang = "java"
                class = "Minimal">class Minimal {
}</code><wichtig>
Beachten Sie, daß Groß- und Kleinschreibung in Java relevant ist.
Alle Schlüsselwörter wie <tt>class</tt> werden stets klein geschrieben.
Klassennamen starten per Konvention immer mit einem Großbuchstaben.</wichtig><paragraph titel = "Die Stringklasse">
Java kommt bereits mit einer großen Anzahl zur Verfügung stehender
Standardklassen. Es müssen also nicht alle Klassen neu vom Programmierer
definiert werden. Eine sehr häufig benutzte Klasse ist die 
Klasse <tt>String</tt>. Sie repräsentiert Objekte, die eine Zeichenkette
darstellen, also einen Text, wie wir ihn in unserer ersten Modellierung
bereits vorausgesetzt haben.</paragraph></subsubsection><subsubsection titel = "Objekte">
Eine Klasse deklariert, wie die Objekte, 
die die Klasse beschreibt, aussehen
können. Um konkrete Objekte für eine Klasse zu bekommen, müssen diese
irgendwann im Programm einmal erzeugt werden. Dieses wird in Java 
syntaktisch gemacht, indem einem Schlüsselwort <tt>new</tt> der Klassenname
mit  einer in runden Klammern eingeschlossenen Argumentliste folgt.
Ein Objekt der obigen minimalen Javaklasse läßt sich entsprechend  
durch folgenden Ausdruck erzeugen:<code>new Minimal();</code><aufgabe>Schreiben sie ein Programm, das ein Objekt der Klasse <tt>Minimal</tt> erzeugt und auf dem Bildschirm ausgibt. Hierzu ersetzen sie
einfach im Programm <tt>Answer</tt> die <tt>42</tt> durch den 
Ausdruck <tt>new Minimal()</tt></aufgabe>

Wenn ein Objekt eine Instanz einer bestimmten Klasse ist, spricht man auch
davon, daß das Objekt den Typ dieser Klasse hat.<paragraph titel = "Objekte der Stringklasse">
Für die Klasse <tt>String</tt> gibt es eine besondere Art, Objekte zu
erzeugen. Ein in Anführungsstrichen eingeschlossener Text erzeugt ein
Objekt der Klasse <tt>String</tt>. <p/>
Aus zwei Objekten der Stringklasse
läßt sich ein neues Objekt erzeugen, indem diese beiden Objekte mit
einem Pluszeichen verbunden werden:<code>&quot;hallo &quot;+&quot;welt&quot;</code>
Hier werden die zwei Stringobjekte <tt>&quot;hallo &quot;</tt> und <tt>&quot;welt&quot;</tt>
zum neuen Objekt <tt>&quot;hallo welt&quot;</tt> verknüpft.</paragraph></subsubsection></subsection>
      <subsection titel = "Felder und Methoden"> 
Im obigen Abschnitt haben wir gesehen, wie eine Klasse definiert wird und
Objekte einer Klasse erzeugt werden können. Allerdings war unsere erste
Klasse noch vollkommen ohne Inhalt: es gab weder die Möglichkeit, 
Daten zu speichern, noch wurden Programmteile definiert, die hätten
ausgeführt werden können. 
Hierzu können Felder und Methoden<index entry = "Methode"/> deklariert 
werden. Die Gesamtheit der
Felder und Methoden<index entry = "Methode"/> nennt man mitunter 
auch <em>Features</em> oder, um einen griffigen deutschen Ausdruck zu 
verwenden, <em>Eigenschaften</em>.<subsubsection titel = "Felder">
Zum Speichern von Daten können Felder für eine Klasse definiert werden.
In einem Feld können Objekte für eine bestimmte Klasse gespeichert werden.
Bei der Felddeklaration wird angegeben, welche Art von Objekten in einem
Feld abgespeichert werden sollen. Die Felder entsprechen dabei genau den
Eigenschaften, die wir auf unsere Karteikarten geschrieben haben.<p/>


Syntaktisch wird in Java der Klassenname des Typs, von dem Objekte
gespeichert werden sollen, den frei zu wählenden Feldnamen vorangestellt.
Eine Felddeklaration endet mit einem Semikolon.<example>
Im Folgenden schreiben wir eine Klasse mit zwei Feldern:<code lang = "java"
                  class = "ErsteFelder">class ErsteFelder {
  Minimal meinFeld;
  String  meinTextFeld;
}</code>

Das erste 
Feld soll dabei einmal ein Objekt unserer minimalen Klasse sein und
das andere Mal eine Zeichenkette.<p/>
Feldnamen werden per Konvention immer klein geschrieben.</example><aufgabe>Schreiben Sie für die vier Karteikarten in der Modellierung eines
Bibliotheksystems entsprechende Klassen mit den entsprechenden Feldern.</aufgabe><paragraph titel = "Zuweisung">
In Feldern können Objekte gespeichert werden. Hierzu muß dem Feld ein
Objekt zugewiesen werden. Syntaktisch geschieht dieses durch ein 
Gleichheitszeichen, auf dessen linker Seite das Feld steht und auf dessen 
rechter Seite das Objekt, das in diesem Feld gespeichert werden soll.
Auch Zuweisungen enden mit einem Semikolon.<example>
In der folgenden Klasse definieren wir nicht nur, daß die Objekte der Klasse
zwei Felder eines bestimmten Typs haben, sondern weisen auch gleich schon
Werte, d.h. konkrete Daten diesen Feldern zu.<code lang = "java"
                    class = "ErsteFelder2">class ErsteFelder2 {
  Minimal meinFeld = new Minimal();
  String  meinTextFeld = &quot;hallo&quot;;
}</code></example>
Nach einer Zuweisung repräsentiert das Feld das ihm zugewiesene Objekt.</paragraph></subsubsection><subsubsection titel = "Methoden">
Methoden<index entry = "Methode|textbf"/><footnote>Der 
Ausdruck für <em>Methoden</em> kommt speziell aus der
objektorientierten Prorammierung. In der imperativen Programmierung
spricht man von <em>Prozeduren</em>, die funktionale Programmierung 
von <em>Funktionen</em>. Weitere Begriffe, die Ähnliches beschreiben,
sind <em>Unterprogramme</em> und <em>Subroutinen</em>.</footnote> 
sind die Programmteile, die in einer Klasse definiert sind und für
jedes Objekt dieser Klasse zur Verfügung stehen. Die Ausführung einer
Methode liefert meist ein Ergebnisobjekt. Methoden haben eine Liste von 
Eingabeparametern. Ein Eingabeparameter ist durch den gewünschten 
Klassennamen und einen frei wählbaren Parameternamen spezifiziert.<paragraph titel = "Methodendeklaration">
In Java wird eine Methode deklariert durch:
den Rückgabetyp, den Namen der Methode, der in Klammern eingeschlossenen
durch Kommas getrennten Parameterliste und den in geschweiften Klammern
eingeschlossenen Programmrumpf. Im Programmrumpf wird mit dem 
Schlüsselwort <tt>return</tt> angegeben, welches Ergebnisobjekt die
Methode liefert.<example>
Als Beispiel definieren wir eine Klasse, in der es eine 
Methode <tt>addString</tt> gibt, 
die den Ergebnistyp <tt>String</tt> und zwei Parameter vom Typ <tt>String</tt> hat:<code lang = "java"
                    class = "StringUtilMethod">class StringUtilMethod {
  String addStrings(String leftText, String rightText){
    return leftText+rightText;
  }
}</code></example>
Methoden und Parameternamen werden per Konvention immer klein geschrieben.</paragraph><paragraph titel = "Zugriff auf Felder im Methodenrumpf">
In einer Methode stehen die Felder der Klasse zur Verfügung<footnote>Das ist 
wiederum nicht die volle Wahrheit, wie in Kürze zu sehen sein wird.</footnote>.<example>
Wir können mit den bisherigen Mitteln eine kleine Klasse definieren, die
es erlaubt, Personen zu repräsentieren, so daß die Objekte dieser Klasse
eine Methode haben, um den vollen Namen der Person anzugeben:<code lang = "java"
                    class = "PersonExample1">class PersonExample1 {
  String vorname;
  String nachname;

  String getFullName(){
    return (vorname+&quot; &quot;+nachname);
  }
}</code></example></paragraph><paragraph titel = "Methoden ohne Rückgabewert">
Es lassen sich auch Methoden schreiben, die keinen eigentlichen Wert
berechnen, den sie als Ergebnis zurückgeben. Solche Methoden haben keinen
Rückgabetyp. In Java wird dieses gekennzeichnet, indem das
Schlüsselwort <tt>void</tt> statt eines Typnamens in der Deklaration
steht. Solche Methoden haben keine <tt>return</tt>-Anweisung. <example>
Folgende kleine Beispielklasse enthält zwei Methoden zum Setzen neuer Werte für ihre Felder:<code lang = "java"
                    class = "PersonExample2">class PersonExample2 {
  String vorname;
  String nachname;

  void setVorname(String newName){
    vorname = newName;
  }
  void setNachname(String newName){
    nachname = newName;
  }
}</code>
Obige Methoden weisen konkrete Objekte den Feldern des Objektes zu.</example></paragraph></subsubsection><subsubsection titel = "Konstruktoren">
Wir haben oben gesehen, wie prinzipiell Objekte einer Klasse 
mit dem <tt>new</tt>-Konstrukt erzeugt
werden. In unserem obigen Beispiel würden wir gerne bei der Erzeugung 
eines Objektes gleich konkrete Werte für die Felder mit angeben, um direkt eine
Person mit konkreten Namen erzeugen zu können. Hierzu können Konstruktoren
für eine Klasse definiert werden. Ein Konstruktor kann als eine besondere
Art der Methode betrachtet werden, deren Name der Name der Klasse ist und
für die kein Rückgabetyp spezifiziert wird. So läßt sich ein Konstruktor
spezifizieren, der in unserem Beispiel konkrete Werte für die Felder der Klasse übergeben bekommt:<code lang = "java"
                class = "Person1">class Person1 {
  String vorname;
  String nachname;

  Person1(String derVorname, String derNachname){
    vorname  = derVorname;
    nachname = derNachname;
  }  

  String getFullName(){
    return (vorname+&quot; &quot;+nachname);
  }
}</code>

Jetzt lassen sich bei der Erzeugung von Objekten des Typs <tt>Person</tt>
konkrete Werte für die Namen übergeben. <example>
Wir erzeugen ein Personenobjekt mit dem für die entsprechende Klasse geschriebenen Konstruktor:<code lang = "java"
                  class = "TestePerson1">class TestePerson1 {

  public static void main(String [] _){
    new Person1(&quot;Nicolo&quot;,&quot;Paganini&quot;);
  }
}</code>
Wie man sieht, machen wir mit diesem Personenobjekt noch nichts. Das Programm
    hat keine Ausgabe oder Funktion.</example></subsubsection><subsubsection titel = "lokale Felder">
Wir kennen bisher die Felder einer Klasse. Wir können ebenso
lokal in einem Methodenrumpf ein Feld deklarieren und benutzen. Solche 
Felder werden genutzt, um Objekten für einen relativ kurzen Programmabschnitt einen Namen zu geben, mit dem wir das Objekt benennen:<code lang = "java"
                class = "FirstLocalFields">class FirstLocalFields{
  public static void main(String [] args){
    String str1 = &quot;hello&quot;;
    String str2 = &quot;world&quot;;
    System.out.println(str1);
    System.out.println(str2);
    String str3 = str1+&quot; &quot;+str2;
    System.out.println(str3);
  }
}</code>
Im obigen Programm deklarieren wir drei lokale Felder in einem Methodenrumpf
und weisen ihnen jeweils ein Objekt vom Typ <tt>String</tt> zu.
Von dem Moment der Zuweisung an steht das Objekt unter dem Namen des Feldes
zur Verfügung.</subsubsection><subsubsection titel = "Zugriff auf Eigenschaften eines Objektes">
Wir wissen jetzt, wie Klassen definiert und Objekte einer
Klasse erzeugt werden. Es fehlt uns schließlich noch, die Eigenschaften 
eines Objektes anzusprechen. Wenn wir ein Objekt haben, lassen sich 
die Eigenschaften dieses Objekts über einen Punkt und 
den Namen der Eigenschaften
ansprechen. <paragraph titel = "Feldzugriffe">
Wenn wir also ein Objekt in einem Feld <tt>x</tt> abgelegt haben 
und das Objekt ist vom Typ <tt>Person</tt>, der ein Feld <tt>vorname</tt> hat,
so erreichen wir das Objekt, das im Feld <tt>vorname</tt> gespeichert ist,
durch den Ausdruck: <tt>x.vorname</tt>. <code lang = "java"
                  class = "GetPersonName">class GetPersonName{
  public static void main (String [] args){
    Person1 p = new Person1(&quot;August&quot;,&quot;Strindberg&quot;);

    String name = p.vorname;
    System.out.println(name);
  }
}</code></paragraph><paragraph titel = "Methodenaufrufe">
Ebenso können wir auf den Rückgabewert
einer Methode zugreifen. Wir nennen dieses dann einen Methodenaufruf. 
Methodenaufrufe unterscheiden sich syntaktisch darin von Feldzugriffen,
daß eine in runden Klammern eingeschlossene Argumentliste folgt:<code lang = "java"
                  class = "CallFullNameMethod">class CallFullNameMethod{
  public static void main (String [] args){
    Person1 p = new Person1(&quot;August&quot;,&quot;Strindberg&quot;);

    String name = p.getFullName();
    System.out.println(name);
  }
}</code></paragraph><aufgabe>Schreiben Sie Klassen, die die Objekte des Bibliotheksystems
repräsentieren können:<itemize>
              <item>Personen mit Namen, Vornamen, Straße, Ort und Postleitzahl.</item>
              <item>Bücher mit Titel und Autor.</item>
              <item>Datum mit Tag, Monat und Jahr.</item>
              <item>Buchausleihe mit Ausleiher, Buch und Datum.</item>
            </itemize>


Hinweis: der Typ, der ganze Zahlen in Java bezeichnet, heißt <tt>int</tt>.<unteraufgaben><teil>Schreiben Sie geeignete Konstruktoren für diese Klassen.</teil> <teil>Schreiben Sie für jede dieser Klassen eine  Methode <tt>public String toString()</tt> mit dem Ergebnistyp. 
Das Ergebnis soll eine gute textuelle Beschreibung
des Objektes sein.<footnote>Sie brauchen noch nicht zu verstehen, warum vor
dem Rückgabetyp noch ein Attribut <ttt>public</ttt> steht.</footnote></teil> <teil>Schreiben Sie eine Hauptmethode in einer Klasse <tt>Main</tt>, in der Sie
Objekte für jede der obigen Klassen erzeugen und die Ergebnisse der <tt>toString</tt>-Methode auf den Bildschirm ausgeben. </teil></unteraufgaben></aufgabe><aufgabe>Suchen Sie auf Ihrer lokalen Javainstallation oder im Netz
auf den Seiten von <exlink address = "http://www.javasoft.com">Sun</exlink> nach
der Dokumentation der Standardklassen von Java. Suchen Sie die
Dokumentation der Klasse <tt>String</tt>. Testen Sie einige der für
die Klasse <tt>String</tt> definierten Methoden.</aufgabe></subsubsection></subsection>
      <subsection titel = "Überladen von Methoden">
        <subsubsection titel = "Variable Parameteranzahl">

Als zusätzliches kleines Gimmik ist in Java eingebaut worden, daß Methoden
mit einer variablen Parameteranzahl definiert werden können. Dieses wird durch
drei Punkte nach dem Parametertyp in der Signatur gekennzeichnet. Damit wird
angegeben, daß eine bieliebige Anzahl dieser Parameter bei einem
Methodenaufruf geben kann. <example>
Es läßt sich so eine Methode schreiben, die mit beliebig vielen
Stringparametern aufgerufen werden kann.<code lang = "java"
                  class = "VarParams">public class VarParams{
  static public String append(String... args){
    String result=&quot;&quot;;
    for (String a:args)
      result=result+a;
    return result;
  }

  public static void main(String [] _){
    System.out.println(append(&quot;hello&quot;,&quot; &quot;,&quot;world&quot;));
  }
}</code>
Die Methode <tt>append</tt> konkateniert endlich 
viele <tt>String</tt>-Objekte.</example>

Wie schon für Aufzählungen können wir auch einmal schauen, was für Code der
Javakompilierer für solche Methoden erzeugt.<scode>sep@linux:~/fh/java1.5/examples&gt; javap -classpath classes/ name.panitz.java15.VarParams
Compiled from &quot;VarParams.java&quot;
public class name.panitz.java15.VarParams extends java.lang.Object{
    public name.panitz.java15.VarParams();
    public static java.lang.String append(java.lang.String[]);
    public static void main(java.lang.String[]);
}

sep@linux:~/fh/java1.5/examples&gt;</scode>

Wie man sieht wird für die variable  Parameteranzahl eine Reihung erzeugt. Der
Javakompilierer sorgt bei Aufrufen der Methode dafür, daß die entsprechenden
Parameter in eine Reihung verpackt werden. Daher können wir mit dem Parameter
wie mit einer Reihung arbeiten. </subsubsection>
      </subsection>
      <subsection titel = "der this-Bezeichner">
Eigenschaften sind an Objekte gebunden. Es gibt in Java 
eine Möglichkeit,
in Methodenrümpfen über das Objekt, für das eine Methode aufgerufen wurde, zu
sprechen. Dieses geschieht mit dem Schlüsselwort <tt>this</tt>. <em>this</em>
ist zu lesen als: dieses Objekt, in dem du dich gerade befindest.
Häufig wird der <tt>this</tt>-Bezeichner in Konstruktoren benutzt, um den
Namen des Parameters des Konstruktors von einem Feld zu unterscheiden:<code lang = "java"
              class = "UseThis">class UseThis {
  String aField ;
  UseThis(String aField){
    this.aField = aField;
  }
}</code></subsection>
    </section>
    <section titel = "statische Eigenschaften">
Bisher haben wir Methoden und Felder kennengelernt, die immer
nur als Teil eines konkreten Objektes existiert haben. Es muß auch eine 
Möglichkeit geben, Methoden, die unabhängig von Objekten existieren,
zu deklarieren, weil
wir ja mit irgendeiner Methoden anfangen müssen, in der erst Objekte erzeugt
werden können. Hierzu gibt es statische Methoden. Die Methoden, die immer
an ein Objekt gebunden sind, heißen im Gegensatz dazu dynamische Methoden.
Statische Methoden brauchen
kein Objekt, um aufgerufen zu werden. Sie werden exakt so deklariert wie dynamische Methoden, mit dem einzigen Unterschied, daß
ihnen das Schlüsselwort <tt>static</tt> vorangestellt wird.
Statische Methoden werden auch in einer Klasse definiert und gehören
zu einer Klasse. Da statische Methoden nicht zu den einzelnen Objekten gehören,
können sie nicht auf dynamische Felder und Methoden der Objekte zugreifen.<code lang = "java"
            class = "StaticTest">class StaticTest {
  static void printThisText(String text){
    System.out.println(text);
  }
}</code>

Statische Methoden werden direkt auf der Klasse, nicht auf einem Objekt 
der Klasse aufgerufen.<p/>

Auf statische Eigenschaften wird zugegriffen, indem vom Klassennamen per
 Punkt getrennt die Eigenschaft aufgerufen wird:<code lang = "java"
            class = "CallStaticTest">class CallStaticTest {
  public static void main(String [] args){
    StaticTest.printThisText(&quot;hello&quot;);
  }
}</code>

Ebenso wie statische Methoden gibt es auch statische Felder. Im Unterschied
zu dynamischen Feldern existieren statische Felder genau einmal, nämlich
in der Klasse. Dynamische Felder existieren für jedes Objekt der Klasse.<p/>
Statische Eigenschaften nennt man auch 
Klassenfelder bzw.<white/>Klassenmethoden.<p/>
Mit statischen Eigenschaften verläßt man quasi die objektorientierte 
Programmierung,
denn diese Eigenschaften sind nicht mehr an Objekte gebunden. Man könnte mit
statischen Eigenschaften Programme schreiben, die niemals ein Objekt erzeugen.</section>
    <aufgabe>
Ergänzen Sie jetzt die Klasse <tt>Person</tt> aus der letzten Aufgabe um ein
statisches Feld <tt>letzerVorname</tt> mit einer Zeichenkette, 
die angeben soll, welchen Vornamen das zuletzt erzeugte Objekt vom 
Typ <tt>Person</tt> hatte. Hierzu müssen Sie im Konstruktor der Klasse Person
dafür sorgen, daß nach der Zuweisung der Objektfelder auch noch das
Feld <tt>letzerVorname</tt> verändert wird. Testen Sie in einer Testklasse, daß
sich tatsächlich nach jeder Erzeugung einer neuen Person dieses Feld verändert
hat. </aufgabe>
    <section titel = "Vererben und Erben"> <index entry = "Vererbung|textbf"/>Eines der grundlegendsten Ziele der objektorientierten Programmierung ist die Möglichkeit, bestehende Programme um neue Funktionalität
erweitern zu können. Hierzu bedient man sich der Vererbung. Bei der Definition einer neuen Klassen hat man die Möglichkeit, anzugeben, daß
diese Klasse alle Eigenschaften von einer bestehenden Klasse erbt.<p/>
Wir haben in einer früheren Übungsaufgabe die Klasse <tt>Person</tt> geschrieben: <code lang = "java"
            class = "Person2">class Person2 {

  String name ;
  String address;

  Person2(String name, String address){
    this.name = name;
    this.address = address;
  }

  public String toString(){
    return name+&quot;, &quot;+address;
  }
}</code>

Wenn wir zusätzlich eine Klasse schreiben wollen, die nicht beliebige
Personen speichern kann, sondern Studenten, die als zusätzliche
Information noch eine Matrikelnummer haben, so stellen wir fest, daß
wir wieder Felder für den Namen und die Adresse anlegen müssen;
d.h.<white/>wir müssen die bereits in der Klasse <tt>Person</tt> zur Verfügung gestellte Funktionalität ein weiteres Mal schreiben:<code lang = "java"
            class = "StudentOhneVererbung">class StudentOhneVererbung {

  String name ;
  String address;
  int matrikelNummer;

  StudentOhneVererbung(String name, String address,int nr){
    this.name = name;
    this.address = address;
    matrikelNummer = nr;
  }

  public String toString(){
    return    name + &quot;, &quot; + address
            + &quot; Matrikel-Nr.: &quot; + matrikelNummer;
  }
}</code> Mit dem Prinzip der Vererbung wird es ermöglicht, diese Verdoppelung
des Codes, der bereits für die Klasse <tt>Person</tt> geschrieben
wurde, zu umgehen. <p/>
Wir werden in diesem Kapitel schrittweise eine 
Klasse <tt>Student</tt> entwickeln, die  die
Eigenschaften erbt, die wir in der Klasse <tt>Person</tt> bereits definiert
haben. <p/>
Zunächst schreibt man in der Klassendeklaration der
Klasse <tt>Student</tt>, daß deren Objekte alle Eigenschaften der 
Klasse <tt>Person</tt> erben. Hierzu wird das 
Schlüsselwort <tt>extends</tt> verwendet:<code lang = "java"
            class = "Student">class Student extends Person2 {</code>


Mit dieser <tt>extends</tt>-Klausel wird angegeben, daß die Klasse von
einer anderen Klasse abgeleitet wird und damit deren Eigenschaften erbt.
Jetzt brauchen die Eigenschaften, die schon in der  Klasse <tt>Person</tt> definiert wurden, nicht mehr neu definiert zu werden.<p/>
Mit der Vererbung steht ein Mechanismus zur Verfügung, der zwei
primäre Anwendungen hat:<itemize>
        <item><bf>Erweitern</bf>: zu den Eigenschaften der Oberklasse werden
weitere Eigenschaften hinzugefügt. Im Beispiel der Studentenklasse
soll das Feld <tt>matrikelNummer</tt> hinzugefügt werden.</item>
        <item><bf>Verändern</bf>: eine Eigenschaft der Oberklasse wird
umdefiniert. Im Beispiel der Studentenklasse soll die 
Methode <tt>toString</tt> der Oberklasse in ihrer Funktionalität
verändert werden.</item>
      </itemize><p/>
Es gibt in Java für eine Klasse immer nur genau eine direkte
Oberklasse. Eine sogenannte multiple Erbung ist in Java nicht 
möglich.<footnote>Dieses ist z.B.<white/>in C++ möglich.</footnote>
Es gibt immer maximal eine <tt>extends</tt>-Klausel in einer
Klassendefinition. <subsection titel = "Hinzufügen neuer Eigenschaften"> Unser erstes Ziel der Vererbung war, eine bestehende Klasse um neue Eigenschaften zu erweitern. Hierzu können wir jetzt einfach mit 
der <tt>extends</tt>-Klausel angeben, daß wir die Eigenschaften einer
Klasse erben. Die Eigenschaften, die wir zusätzlich haben wollen,
lassen sich schließlich wie gewohnt deklarieren:<code lang = "java"
              class = "Student"
              sequel = "true">  int matrikelNummer;</code> 
 
Hiermit haben wir eine Klasse geschrieben, die drei Felder 
hat: <tt>name</tt> und <tt>adresse</tt>, die von der 
Klasse <tt>Person</tt> geerbt werden und zusätzlich das 
Feld <tt>matrikelNummer</tt>. Diese drei Felder können für Objekte der Klasse <tt>Student</tt> in gleicher Weise benutzt werden: <code lang = "java"
              class = "Student"
              sequel = "true">String writeAllFields(Student s){
   return s.name+&quot; &quot;+s.address+&quot; &quot;+s.matrikelNummer;
}</code>

Ebenso so wie Felder lassen sich Methoden hinzufügen. Z.B.<white/>eine
Methode, die die Matrikelnummer als Rückgabewert hat:<code lang = "java"
              class = "Student"
              sequel = "true">int getMatrikelNummer(){
  return matrikelNummer;
}</code></subsection><subsection titel = "Überschreiben bestehender Eigenschaften"><index entry = "überschreiben"/>Unser zweites Ziel ist, durch Vererbung 
eine Methode in ihrem Verhalten zu verändern. In unserem Beispiel soll die 
Methode <tt>toString</tt> der Klasse <tt>Person</tt> für
Studentenobjekte so geändert werden, daß das Ergebnis auch die 
Matrikelnummer enthält. Hierzu können wir die entsprechende Methode
in der Klasse <tt>Student</tt> einfach neu schreiben:<code lang = "java"
              class = "Student"
              sequel = "true">  public String toString(){
    return    name + &quot;, &quot; + address
            + &quot; Matrikel-Nr.: &quot; + matrikelNummer;
  }</code>
Obwohl Objekte der Klasse <tt>Student</tt> auch Objekte der 
Klasse <tt>Person</tt> sind, benutzen sie nicht die  Methode <tt>toString</tt> der Klasse <tt>Person</tt>, sondern die
neu definierte Version aus der Klasse <tt>Student</tt>. <p/>
Um eine Methode zu überschreiben, muß sie  dieselbe Signatur bekommen,
die sie in der Oberklasse hat.</subsection><subsection titel = "Konstruktion">
Um für eine Klasse konkrete Objekte zu konstruieren, braucht die
Klasse entsprechende Konstruktoren. In unserem Beispiel soll jedes
Objekt der Klasse <tt>Student</tt> auch ein Objekt der 
Klasse <tt>Person</tt> sein. Daraus folgt, daß, um ein Objekt der
Klasse <tt>Student</tt> zu erzeugen,  es auch notwendig ist, ein Objekt
der Klasse <tt>Person</tt> zu erzeugen. Wenn wir also einen
Konstruktor für <tt>Student</tt> schreiben, sollten wir sicherstellen,
daß mit diesem auch ein gültiges Objekt der 
Klasse <tt>Person</tt>  erzeugt wird. Hierzu kann man den Konstruktor
der Oberklasse aufrufen. Dieses geschieht mit dem 
Schlüsselwort <tt>super</tt>. <tt>super</tt> ruft den Konstruktor der
Oberklasse auf:<code lang = "java"
              class = "Student"
              sequel = "true">   Student(String name,String adresse,int nr){
     super(name,adresse);
     matrikelNummer = nr;
   }
}</code>
In unserem Beispiel bekommt der Konstruktor der  Klasse <tt>Student</tt> alle Daten, die benötigt werden, um ein
Personenobjekt und ein Studentenobjekt zu erzeugen. Als erstes wird
im Rumpf des Studentenkonstruktors der Konstruktor der 
Klasse <tt>Person</tt> aufgerufen. Anschließend wird das zusätzliche
Feld der Klasse <tt>Student</tt> mit entsprechenden Daten initialisiert.<p/>
Ein Objekt der Klasse <tt>Student</tt> kann wie gewohnt konstruiert
werden:<code lang = "java"
              class = "TestStudent">class TestStudent {
  public static void main(String [] _){
    Student s
     = new Student(&quot;Martin Müller&quot;,&quot;Hauptstraße 2&quot;,755423);
    System.out.println(s);
  }
}</code></subsection><subsection titel = "Zuweisungskompatibilität">
Objekte einer Klasse sind auch ebenso Objekte ihrer Oberklasse. Daher können sie benutzt werden wie die Objekte ihrer Oberklasse, insbesondere bei einer Zuweisung. Da in unserem Beispiel
die Objekte der Klasse <tt>Student</tt> auch Objekte der  Klasse <tt>Person</tt>  sind,  dürfen diese auch Feldern des 
Typs <tt>Person</tt> zugewiesen werden:<code lang = "java"
              class = "TestStudent1">class TestStudent1{
  public static void main(String [] args){
    Person2 p 
     = new Student(&quot;Martin Müller&quot;,&quot;Hauptstraße&quot;,7463456);
  }
}</code>
Alle Studenten sind auch Personen.<p/>
Hingegen die andere Richtung ist nicht möglich: nicht alle Personen
sind Studenten. Folgendes Programm wird von Java mit einem Fehler
zurückgewiesen:<code lang = "java"
              classError = "StudentError1">class StudentError1{
  public static void main(String [] args){
    Student s
      = new Person2(&quot;Martin Müller&quot;,&quot;Hauptstraße&quot;);
  }
}</code>
Die Kompilierung dieser Klasse führt zu folgender Fehlermeldung:<scode>StudentError1.java:3: incompatible types
found   : Person
required: Student
    Student s = new Person2(&quot;Martin Müller&quot;,&quot;Hauptstraße&quot;);
                ^
1 error</scode>
Java weist diese Klasse zurück, weil eine Person nicht ein Student
ist. <p/>
Gleiches gilt für den Typ von Methodenparametern. Wenn die Methode einen Parameter vom Typ <tt>Person</tt> verlangt, so kann man ihm auch
Objekte eines spezielleren Typs geben, in unserem Fall der 
Klasse <tt>Student</tt>.<code lang = "java"
              class = "TestStudent2">class TestStudent2 {
   
  static void printPerson(Person2 p){
    System.out.println(p.toString());
  }

  public static void main(String [] args){
     Student s
       = new Student(&quot;Martin Müller&quot;,&quot;Hauptstraße&quot;,754545);
     printPerson(s);
  }
}</code>

Der umgekehrte Fall ist wiederum nicht möglich. Methoden, die als
Parameter Objekte der Klasse <tt>Student</tt> verlangen, dürfen nicht
mit Objekten einer allgemeineren Klasse aufgerufen werden:<code lang = "java"
              classError = "StuedentError2">class StudentError2{
   
  static void printStudent(Student s){
    System.out.println(s.toString());
  }

  public static void main(String [] args){
     Person2 p = new Person2(&quot;Martin Müller&quot;,&quot;Hauptstraße&quot;);
     printStudent(p);
  }
}</code>
Auch hier führt die Kompilierung zu einer entsprechenden
     Fehlermeldung:<scode>StudentError2.java:9: printStudent(Student) in StudentError2 
                      cannot be applied to (Person2)
     printStudent(p);
     ^
1 error</scode></subsection><subsection titel = "Späte Bindung (late binding)">
Wir haben gesehen, daß wir Methoden überschreiben können. Interessant
ist, wann welche Methode ausgeführt wird. In unserem Beispiel gibt es
je eine Methode <tt>toString</tt> in der 
Oberklasse <tt>Person</tt> als auch in der 
Unterklasse <tt>Student</tt>.<p/>
Welche dieser zwei Methoden wird wann ausgeführt? Wir können dieser
Frage experimentell nachgehen:<code lang = "java"
              class = "TestLateBinding">class TestLateBinding {
 
  public static void main(String [] args){
    Student s = new Student(&quot;Martin Müller&quot;,&quot;Hauptstraße&quot;,756456);
    Person2 p1 = new Person2(&quot;Harald Schmidt&quot;,&quot;Marktplatz&quot;);
    
    System.out.println(s.toString());
    System.out.println(p1.toString());

    Person2 p2 = new Student(&quot;Martin Müller&quot;,&quot;Hauptstraße&quot;,756456);
    System.out.println(p2.toString());
  }
}</code>
Dieses Programm erzeugt folgende Ausgabe:<scode>sep@swe10:~/fh/&gt; java TestLateBinding
Martin Müller, Hauptstraße Matrikel-Nr.: 756456
Harald Schmidt, Marktplatz
Martin Müller, Hauptstraße Matrikel-Nr.: 756456</scode>
Die ersten beiden Ausgaben entsprechen sicherlich den Erwartungen: es
wird eine Student und anschließend eine Person ausgegeben. Die dritte
Ausgabe ist interessant. Obwohl der Befehl:<code>System.out.println(p2.toString());</code>
die Methode <tt>toString</tt> auf einem Feld vom 
Typ <tt>Person</tt> ausführt, wird die Methode <tt>toString</tt> aus
der Klasse <tt>Student</tt> ausgeführt. Dieser Effekt entsteht, weil
das Objekt, das im Feld <tt>p2</tt> gespeichert wurde, als Student und
nicht als Person erzeugt wurde. Die Idee der Objektorientierung ist,
daß die Objekte die Methoden in sich enthalten. In unserem Fall
enthält das Objekt im Feld <tt>p2</tt> seine  eigene <tt>toString</tt>-Methode. Diese wird ausgeführt.  Der Ausdruck <tt>p2.toString()</tt> ist also zu lesen als:<quote>Objekt, das in Feld <tt>p2</tt> gespeichert ist, führe bitte
deine Methode <tt>toString</tt> aus.</quote>

Da dieses Objekt, auch wenn wir es dem Feld nicht ansehen, ein Objekt
der Klasse <tt>Student</tt> ist, führt es die entsprechende Methode
der Klasse <tt>Student</tt> und nicht der Klasse <tt>Person</tt> aus.<p/>
Dieses in Java realisierte Prinzip wird als <em>late binding</em>
bezeichnet.<footnote>Achtung: <em>late binding</em> funktioniert in
Java nur bei Methoden, nicht bei Feldern.</footnote><aufgabe>
In dieser Aufgabe sollen Sie eine Gui-Klasse benutzen und ihr eine eigene
Anwendungslogik übergeben.<p/> Gegeben seien die folgenden Javaklassen, wobei Sie die 
Klasse <tt>Dialogue</tt> nicht zu analysieren oder zu verstehen brauchen:<itemize>
            <item>
              <code lang = "java"
                    class = "ButtonLogic">class ButtonLogic {
  String getDescription(){
    return &quot;in Großbuchstaben umwandeln&quot;;
  }
  String eval(String x){return x.toUpperCase();}
}</code>
            </item>
            <item>
              <code lang = "java"
                    class = "Dialogue">import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
class Dialogue extends JFrame{

  final ButtonLogic logic; 

  final JButton button;
  final JTextField inputField  = new JTextField(20) ;
  final JTextField outputField = new JTextField(20) ;
  final JPanel p = new JPanel();

  Dialogue(ButtonLogic l){
    logic = l;
    button=new JButton(logic.getDescription());
    button.addActionListener
     (new ActionListener(){
        public void actionPerformed(ActionEvent _){
          outputField.setText
             (logic.eval(inputField.getText().trim()));
        }
      });
    p.setLayout(new BorderLayout());
    p.add(inputField,BorderLayout.NORTH);
    p.add(button,BorderLayout.CENTER);
    p.add(outputField,BorderLayout.SOUTH);
    getContentPane().add(p);
    pack();
    setVisible(true);
  }
}</code>
            </item>
            <item>
              <code lang = "java"
                    class = "TestDialogue">class TestDialogue {
  public static void main(String [] _){
    new Dialogue(new ButtonLogic());
  }
}</code>
            </item>
            <unteraufgaben>
              <teil>Übersetzen Sie die drei Klassen und starten Sie das Programm.</teil>
              <teil>Schreiben Sie eine Unterklasse der Klasse <tt>ButtonLogic</tt>. Sie
sollen dabei die Methoden <tt>getDescription</tt> und <tt>eval</tt> so
überschreiben, daß der Eingabestring in Kleinbuchstaben umgewandelt wird. Schreiben Sie eine Hauptmethode, in der Sie ein Objekt der 
Klasse <tt>Dialogue</tt> mit einem Objekt Ihrer Unterklasse 
von <tt>ButtonLogic</tt> erzeugen.</teil>
              <teil>Schreiben Sie jetzt eine Unterklasse der 
Klasse <tt>ButtonLogic</tt>, so daß Sie im Zusammenspiel mit der 
Guiklasse <tt>Dialogue</tt> ein Programm erhalten, in dem Sie römische Zahlen
in arabische Zahlen umwandeln können. Testen Sie Ihr Programm.</teil>
              <teil>Schreiben Sie jetzt eine Unterklasse der 
Klasse <tt>ButtonLogic</tt>, so daß Sie im Zusammenspiel mit der 
Guiklasse <tt>Dialogue</tt> ein Programm erhalten, in dem Sie arabische Zahlen
in römische Zahlen umwandeln können. Testen Sie Ihr Programm.</teil>
              <teil>Schreiben Sie jetzt ein Guiprogramm, daß eine Zahl aus ihrer Darstellung
zur Basis 10 in eine Darstellung zur Basis 2 umwandelt. Testen Sie.</teil>
            </unteraufgaben>
          </itemize></aufgabe><subsubsection titel = "Methoden als Daten">
Mit dem Prinzip der späten Methodenbindung können wir unsere
ursprüngliche Arbeitshypothese, daß Daten und Programme zwei
unterschiedliche Konzepte sind, etwas aufweichen. Objekte enthalten
in ihren Feldern die Daten und mit ihren Methoden Unterprogramme. Wenn
in einem Methodenaufruf ein Objekt übergeben wird, übergeben wir somit
in dieser Methode nicht nur spezifische Daten, sondern auch
spezifische Unterprogramme. Dieses haben wir uns in der letzten Aufgabe
zunutze gemacht, um
Funktionalität an eine graphische Benutzeroberfläche  zu übergeben.  Hierzu betrachten wir  den Konstruktor und die Benutzung der Klasse <tt>Dialogue</tt>,  die in einer der letzten Aufgaben vorgegeben war:<code>  Dialogue(ButtonLogic l){
    logic = l;
    button=new JButton(logic.getDescription());</code>
Diese Klasse hat einen Konstruktor, der als Argument ein Objekt des
Typs <tt>ButtonLogic</tt> erwartet. In dieser Klasse gibt es eine
Methode <tt>String eval(String x)</tt>, die offensichtlich
benutzt wird, um die Funktionalität der graphischen
Benutzerschnittstelle (GUI) zu bestimmen. Ebenso enthält sie eine 
Methode  <tt>String getDescription()</tt>, die festlegt, was für eine Beschriftung für den Knopf benutzt werden soll. Wir übergeben also
Funktionalität in Form von Methoden an die Klasse <tt>Dialogue</tt>. Je nachdem, wie in unserer konkreten Unterklasse 
von <tt>ButtonLogic</tt> diese beiden Methoden überschrieben sind, verhält
sich das Guiprogramm.<p/>
Die in diesem Abschnitt gezeigte Technik ist eine typische
Javatechnik. Bestehende Programme können erweitert und mit eigener
Funktionalität benutzt werden, ohne daß man die bestehenden Klassen zu
ändern braucht. Wir haben neue Guiprogramme schreiben können, ohne an der
Klasse <tt>Dialogue</tt> etwas ändern zu müssen, ohne sogar irgendetwas über
Guiprogrammierung zu wissen. Durch die Objektorientierung lassen sich in Java hervorragend verschiedene Aufgaben trennen und im Team bearbeiten sowie
Softwarekomponenten wiederverwenden.</subsubsection></subsection><subsection titel = "Zugriff auf Methoden der Oberklasse">
Vergleichen wir die Methoden <tt>toString</tt> der 
Klassen <tt>Person</tt> und <tt>Student</tt>, so sehen wir, daß in der
Klasse <tt>Student</tt> Code der Oberklasse verdoppelt wurde:<code>  public String toString(){
    return    name + &quot;, &quot; + address
            + &quot; Matrikel-Nr.: &quot; + matrikelNummer;
  }</code>
Der Ausdruck  <code>name + &quot;, &quot; + address</code> wiederholt die Berechnung
    der <tt>toString</tt>-Methode aus der Klasse <tt>Person</tt>. Es
    wäre schön, wenn an dieser Stelle die entsprechende Methode aus
    der Oberklasse benutzt werden könnte. Auch dieses ist in Java
    möglich. Ähnlich, wie der Konstruktor der Oberklasse explizit
    aufgerufen werden kann, können auch Methoden der Oberklasse
    explizit aufgerufen werden. Auch in diesem Fall ist das
    Schlüsselwort <tt>super</tt> zu benutzen, allerdings nicht in der Weise, als sei <tt>super</tt> eine Methode, sondern als sei es ein
    Feld, das ein Objekt enthält, also ohne Argumentklammern. Dieses Feld erlaubt es, direkt auf die Eigenschaften der Oberklasse
    zuzugreifen. Somit läßt sich die <tt>toString</tt>-Methode der
Klasse <tt>Student</tt> auch wie folgt schreiben:<code>  public String toString(){
    return      //<bluev>call toString of super class</bluev>
                super.toString()  
                //<bluev>add the Matrikelnummer</bluev>
            + &quot; Matrikel-Nr.: &quot; + matrikelNummer;
  }</code></subsection><subsection titel = "Die Klasse Object">
Eine berechtigte Frage ist, welche Klasse die Oberklasse für eine
Klasse ist, wenn es keine <tt>extends</tt>-Klausel gibt. Bisher haben
wir nie eine entsprechende Oberklasse angegeben.<p/>
Java hat in diesem Fall eine Standardklasse: <tt>Object</tt>. Wenn
nicht explizit eine Oberklasse angegeben wird, so ist die 
Klasse <tt>Object</tt> die direkte Oberklasse. Weil  die <tt>extends</tt>-Relation transitiv ist,  ist schließlich jede
Klasse eine Unterklasse der Klasse <tt>Object</tt>. Insgesamt bilden alle Klassen, die in Java existieren, eine Baumstruktur, deren Wurzel
die Klasse <tt>Object</tt> ist.<p/>
Es bewahrheitet sich die Vermutung über objektorientierte Programmierung, daß alles als Objekt
betrachtet wird.<footnote>Java kennt acht eingebaute primitive Typen
für Zahlen, Wahrheitswerte und Buchstaben. Diese sind zwar keine Objekte,
werden notfalls von Java aber in entsprechende Objektklassen automatisch konvertiert.</footnote> Es folgt insbesondere, daß jedes Objekt die
Eigenschaften hat, die in der Klasse <tt>Object</tt> definiert wurden. Ein Blick in die Java API Documentation zeigt, daß zu diesen
Eigenschaften auch die Methode <tt>toString</tt> gehört, wie wir sie bereits  einige mal geschrieben haben. Jetzt erkennen wir, daß
wir diese Methode dann überschrieben haben. Auch wenn wir für eine
selbstgeschriebene Klasse die Methode <tt>toString</tt> nicht
definiert haben, existiert eine solche Methode. Allerdings ist deren
Verhalten selten ein für unsere Zwecke geeignetes.<p/>
Die Eigenschaften, die alle Objekte haben, weil sie in der  Klasse <tt>Object</tt> definiert sind, sind äußerst allgemein. Sobald
wir von einem Object nur noch wissen, daß es vom 
Typ <tt>Object</tt> ist, können wir kaum noch spezifische Dinge mit
ihm anfangen.<p/><subsubsection titel = "Die Methode equals">
Eine weitere Methode, die in der Klasse <tt>Object</tt> definiert ist,
ist die Methode <tt>equals</tt>. Sie hat folgende Signatur:<code>public boolean equals(Object other)</code>

Wenn man diese Methode überschreibt, so kann definiert werden, wann
zwei Objekte einer Klasse als gleich angesehen werden sollen. Für Personen würden wir gerne definieren, daß zwei Objekte dieser Klasse
gleich sind, wenn sie ein und denselben Namen und ein und dieselbe
Adresse haben. Mit unseren derzeitigen Mitteln läßt sich dieses leider
nicht ausdrücken. Wir würden gerne die <tt>equals</tt>-Methode wie
folgt überschreiben:<code>public boolean equals(Object other){
  return        this.name.equals(other.name) 
             &amp;&amp; this.adresse.equals(other.adresse);
}</code>
Dieses ist aber nicht möglich, weil für das Objekt <tt>other</tt>, von
dem wir nur wissen, daß es vom Typ <tt>Object</tt> ist, keine
Felder <tt>name</tt> und <tt>adresse</tt> existieren. <p/>
Um dieses Problem zu umgehen, sind Konstrukte notwendig, die von allgemeineren
Typen wieder zu spezielleren Typen führen. Ein solches Konstrukt
lernen wir in den folgenden Abschnitten kennen.</subsubsection></subsection><subsection titel = "Klassentest"> Wie wir oben gesehen haben, können wir zu wenige Informationen über den
Typen eines Objektes haben. Objekte wissen aber selbst, von welcher
Klasse sie einmal erzeugt wurden. Java stellt einen binären Operator
zur Verfügung, der erlaubt, abzufragen, ob ein Objekt zu einer Klasse
gehört. Dieser Operator heißt <tt>instanceof</tt>. Er hat links ein
Objekt und rechts einen Klassennamen. Das Ergebnis ist ein bool&#39;scher
Wert, der genau dann wahr ist, wenn das Objekt eine Instanz der Klasse
ist. <code lang = "java"
              class = "InstanceOfTest">class InstanceOfTest {
  public static void main(String [] str){
     Person2 p1 = new Person2(&quot;Strindberg&quot;,&quot;Skandinavien&quot;);
     Person2 p2 = new Student(&quot;Ibsen&quot;,&quot;Skandinavien&quot;,789565);
     if (p1 instanceof Student) 
       System.out.println(&quot;p1 ist ein  Student.&quot;);
     if (p2 instanceof Student) 
       System.out.println(&quot;p2 ist einStudent.&quot;);
     if (p1 instanceof Person2) 
       System.out.println(&quot;p1 ist eine Person.&quot;);
     if (p2 instanceof Person2) 
       System.out.println(&quot;p2 ist eine Person.&quot;);
  }
}</code>
An der Ausgabe dieses Programms kann man erkennen, daß  ein <tt>instanceof</tt>-Ausdruck wahr wird, wenn das Objekt ein Objekt
  der Klasse oder aber einer Unterklasse der Klasse des zweiten
  Operanden ist.<scode>sep@swe10:~/fh&gt; java InstanceOfTest
p2 ist einStudent.
p1 ist eine Person.
p2 ist eine Person.</scode></subsection><subsection titel = "Typzusicherung (Cast)"> Im letzten Abschnitt haben wir eine Möglichkeit kennengelernt, zu
fragen, ob ein Objekt zu einer bestimmten Klasse gehört. Um ein Objekt dann auch wieder so benutzen zu können, daß es zu dieser Klasse gehört, müssen wir diesem Objekt diesen Typ erst wieder zusichern. Im
obigen Beispiel haben wir zwar erfragen können, daß das 
in Feld <tt>p2</tt> gespeicherte Objekt nicht nur eine Person, sondern
ein Student ist; trotzdem können wir noch nicht <tt>p2</tt> nach
seiner Matrikelnummer fragen. Hierzu müssen wir erst zusichern, daß
das Objekt den Typ <tt>Student</tt> hat.

Eine Typzusicherung in Java wird gemacht, indem dem entsprechenden Objekt in Klammer der Typ vorangestellt wird, den wir ihm zusichern
wollen:<code lang = "java"
              class = "CastTest">class CastTest {
  public static void main(String [] str){
    Person2 p = new Student(&quot;Ibsen&quot;,&quot;Skandinavien&quot;,789565);

    if (p instanceof Student){ 
      Student s = (Student)p;
      System.out.println(s.matrikelNummer);
    }
  }
}</code> 
Die Zeile <tt>s = (Student)p;</tt> sichert erst dem Objekt im
Feld <tt>p</tt> zu, daß es ein Objekt des Typs <tt>Student</tt> ist,
      so daß es dann als Student benutzt werden kann. Wir haben den
      Weg zurück vom Allgemeinen ins Spezifischere
      gefunden. Allerdings ist dieser Weg gefährlich. Eine Typzusicherung kann fehlschlagen: <code lang = "java"
              classError = "CastError">class CastError {
  public static void main(String [] str){
    Person2 p = new Person2(&quot;Strindberg&quot;,&quot;Skandinavien&quot;);
    Student s = (Student)p;
    System.out.println(s.matrikelNr);
  }
}</code> 
Dieses Programm macht eine Typzusicherung des 
Typs <tt>Student</tt> auf ein Objekt, das nicht von diesem Typ ist.
Es kommt in diesem Fall zu einen Laufzeitfehler:<scode>sep@swe10:~/fh&gt; java CastError       
Exception in thread &quot;main&quot; java.lang.ClassCastException: Person2
        at CastError.main(CastError.java:4)</scode>
Die Fehlermeldung sagt, daß wir in Zeile 4 des Programms eine
Typzusicherung auf ein Objekt des Typs <tt>Person</tt> vornehmen, die
fehlschlägt. 
Will man solche Laufzeitfehler verhindern, so ist man auf der sicheren 
Seite, wenn eine Typzusicherung
nur dann gemacht wird, nachdem man sich  mit  einem <tt>instanceof</tt>-Ausdruck davon überzeugt hat, daß das Objekt wirklich von dem Typ ist, den man ihm zusichern will.

Mit den jetzt vorgestellten Konstrukten können wir eine Lösung der
Methode <tt>equals</tt> für die Klasse <tt>Person</tt> mit der
erwarteten Funktionalität schreiben:<code>public boolean equals(Object other){
  boolean erg = false;
  if (other instanceof Person2){
     Person2 p = (Person2) other;
     erg = this.name.equals(p.name) 
             &amp;&amp; this.adresse.equals(p.adresse);
  }
  return erg;        
}</code> Nur, wenn das zu vergleichende Objekt auch vom Typ <tt>Person</tt> ist
  und den gleichen Namen und die gleiche Adresse hat, dann sind zwei
  Personen gleich.</subsection></section>
  </kapitel>
  <kapitel titel = "Imperative Konzepte">
Im letzten Abschnitt wurde ein erster Einstieg in die
objektorientierte Programmierung gegeben. Wie zu sehen war, ermöglicht  die objektorientierte Programmierung, das zu lösende Problem in
logische Untereinheiten zu unterteilen, die direkt mit den Teilen der
zu modellierenden Problemwelt korrespondieren.<p/>
Die Methodenrümpfe, die die eigentlichen Befehle enthalten, in denen 
etwas berechnet werden soll, waren bisher recht kurz. In diesem
Kapitel werden wir Konstrukte kennenlernen, die es ermöglichen, in den
Methodenrümpfen komplexe Berechnungen vorzunehmen. Die in diesem
Abschnitt vorgestellten Konstrukte sind herkömmliche Konstrukte der imperativen Programmierung und  in ähnlicher Weise auch in
Programmiersprachen wie C zu finden.<footnote>Gerade in diesem
Bereich wollten die Entwickler von Java einen leichten Umstieg von der
C-Programmierung nach Java ermöglichen. Leider hat Java in dieser
Hinsicht auch ein C-Erbe und ist nicht in allen Punkte so sauber
entworfen, wie es ohne diese Designvorgabe wäre.</footnote><section titel = "Primitive Typen, die klassenlose Gesellschaft">
Bisher haben wir noch überhaupt keine Berechnungen im klassischen
Sinne als das Rechnen mit Zahlen kennengelernt. Java stellt Typen zur
Repräsentation von Zahlen zur Verfügung. Leider sind diese Typen keine
Klassen; d.h.<white/>insbesondere, daß auf diesen Typen keine Felder und
Methoden existieren, auf die mit einem Punkt zugegriffen werden kann. <p/>
Die im Folgenden vorgestellten Typen nennt man primitive Typen. Sie
sind fest von Java vorgegeben. Im Gegensatz zu Klassen, die der
Programmierer selbst definieren kann, können keine neuen primitiven
Typen definiert werden. Um primitive Typnamen von Klassennamen leicht
textuell unterscheiden zu können, sind sie in Kleinschreibung
definiert worden. <p/>
Ansonsten werden primitive Typen genauso
behandelt wie Klassen. Felder können primitive Typen als Typ haben und
ebenso können Parametertypen und Rückgabetypen von Methoden primitive
Typen sein.<p/>
Um Daten der primitiven Typen aufschreiben zu können, gibt es jeweils
Literale für die Werte dieser Typen.<subsection titel = "Zahlenmengen in der Mathematik">
In der Mathematik sind wir gewohnt, mit verschiedenen Mengen von Zahlen zu
arbeiten:<itemize>
          <item><b>natürliche Zahlen</b><w/><setN/>: Eine induktiv definierbare Menge
mit einer kleinsten Zahl, so daß es für jede Zahl eine eindeutige
Nachfolgerzahl gibt.</item>
          <item><b>ganze Zahlen</b><w/><setZ/>: Die natürlichen Zahlen erweitert um die
mit einem negativen Vorzeichen behafteten Zahlen, die sich ergeben, wenn man
eine größere Zahl von einer natürlichen Zahl abzieht.</item>
          <item><b>rationale Zahlen</b><w/><setQ/>: Die ganzen Zahlen erweitert um
Brüche, die sich ergeben, wenn man eine Zahl durch eine Zahl teilt, von der
sie kein Vielfaches ist.</item>
          <item><b>reelle Zahlen</b><w/><setR/>: Die ganzen Zahlen erweitert um
irrationale Zahlen, die sich z.B.<w/>aus der Quadratwurzel von Zahlen 
ergeben, die nicht das Quadrat einer rationalen Zahl sind. </item>
          <item><b>komplexe Zahlen</b><w/><setC/>: Die reellen Zahlen erweitert um
imaginäre Zahlen, wie sie benötigt werden, um einen Wurzelwert
für  negative Zahlen darzustellen.</item>
        </itemize>

Es gilt folgende Mengeninklusion zwischen diesen Mengen:<br/><center>
          <setN/>
          <subset/>
          <setZ/>
          <subset/>
          <setQ/>
          <subset/>
          <setR/>
          <subset/>
          <setC/>
        </center>

Da bereits <setN/> nicht endlich ist, ist keine dieser Mengen endlich. </subsection><subsection titel = "Zahlenmengen im Rechner">
Da wir nur von einer endlich großen Speicherkapazität ausgehen können, lassen
sich für keine der aus der Mathematik bekannten Zahlenmengen alle Werte in
einem Rechner darstellen. Wir können also schon einmal nur Teilmengen der
Zahlenmengen darstellen.<p/>


Von der Hardwareseite stellt sich heute zumeist die folgende Situation dar: 
Der Computer hat einen linearen Speicher, der   in Speicheradressen unterteilt
ist. Eine Speicheradresse
bezeichnet einen Bereich von 32 Bit. Wir bezeichnen diese als ein Wort. Die
Einheit von 8 Bit wird als Byte bezeichnet <footnote>ein anderes selten
gebrauchtes  Wort aus dem Französischen ist: Oktett</footnote>. Heutige
Rechner verwalten also in der Regel Dateneinheiten von 32 Bit. Hieraus ergibt
sich  die Kardinalität der Zahlenmengen, mit denen ein Rechner als primitive
Typen rechnen kann. Soll mit größeren Zahlenmengen gerechnet werden, so muß
hierzu eine Softwarelösung genutzt werden.<p/></subsection><subsection titel = "natürliche Zahlen">
Natürliche Zahlen werden in der Regel durch Zeichenketten  von 
 Symbolen, den Ziffern, eines 
endlichen Alphabets dargestellt. Die Größe dieser Symbolmenge
 wird als die Basis <m>b</m> der Zahlendarstellung bezeichnet. 
Für die Basis <m>b</m> gilt: <m>b &gt; 1</m>. Die Ziffern bezeichnen die
 natürlichen Zahlen von <m>0</m> bis <m>b-1</m>. <p/>

Der Wert der Zahl einer 
Zeichenkette <m>a<subscript>n-1</subscript><dots/><w/>a<subscript>0</subscript></m> berechnet sich für die Basis <m>b</m>  nach folgender
Formel: <p/><displaymath><sum>
            <von>i=0</von>
            <bis>n-1</bis>
          </sum> a<subscript>i</subscript>*b<superscript>i</superscript>
= a<subscript>0</subscript>*b<superscript>0</superscript> + <dots/> + a<subscript>n-1</subscript>*b <superscript>n-1</superscript></displaymath>

Gebräuchliche Basen sind:<itemize>
          <item>2: Dualsystem</item>
          <item>8: Oktalsystem</item>
          <item>10: Dezimalsystem</item>
          <item>16: Hexadezimalsystem<footnote>Eine etwas unglückliche Namensgebung aus
der Mischung eines griechischen mit einem lateinischen Wort.</footnote></item>
        </itemize>

Zur Unterscheidung wird im Zweifelsfalle die Basis einer Zahlendarstellung als
Index mit angegeben.<example> Die Zahl 10 in Bezug auf unterschiedliche Basen dargestellt:<displaymath>(10)<subscript>10</subscript>=
(A)<subscript>16</subscript>=
(12)<subscript>8</subscript>=
(1010)<subscript>2</subscript></displaymath></example>

Darüberhinaus gibt es auch Zahlendarstellungen, die nicht in Bezug auf eine
Basis definiert sind, wie z.B.<w/>die römischen Zahlen.<p/>


Betrachten wir wieder unsere Hardware, die in Einheiten von 32 Bit agiert, so
lassen sich in einer Speicheradresse durch direkte Anwendung der Darstellung
im Dualsystem die natürlichen 
Zahlen von <m>0</m> bis <m>2<superscript>32</superscript>-1</m> darstellen.</subsection><subsection titel = "ganze Zahlen">
In vielen Programmiersprachen wie z.B.<w/> Java gibt es keinen primitiven
Typen, der eine Teilmenge der natürlichen Zahlen darstellt.<footnote>Wobei
wir großzügig den Typ <ttt>char</ttt> ignorieren.</footnote> Zumeist wird der
Typ <tt>int</tt> zur Darstellung ganzer Zahlen benutzt. Hierzu bedarf es einer
Darstellung vorzeichenbehafteter Zahlen in den Speicherzellen des Rechners. 
Es gibt mehrere Verfahren, wie in einem dualen System vorzeichenbehaftete
Zahlen dargestellt werden können.<subsubsection titel = "Vorzeichen und Betrag">
Die einfachste Methode ist, von den <m>n</m> für die Zahlendarstellung zur
Verfügung stehenden Bit eines zur Darstellung des Vorzeichens und die
übrigen <m>n-1</m> Bit für eine Darstellung im Dualsystem zu nutzen.<example>In der Darstellung durch Vorzeichen und Betrag werden bei einer
Wortlänge von 8 Bit die Zahlen <m>10</m> und <m>-10</m> durch folgende 
Bitmuster repräsentiert: <m>00001010</m> und <m>10001010</m>. </example>

Wenn das
linkeste Bit das Vorzeichen bezeichnet, ergibt sich daraus, daß es zwei
Bitmuster für die Darstellung der Zahl 0 
gibt: <m>10000000</m> und <m>00000000</m>. <p/>

In dieser Darstellung lassen sich bei einer 
Wortlänge <m>n</m> die Zahlen von <m>-2<superscript>n-1</superscript>-1</m> bis <m>2<superscript>n-1</superscript>-1</m> darstellen.<p/>
Die Lösung der Darstellung mit Vorzeichen und Betrag erschwert das Rechnen.
Wir müssen zwei Verfahren bereitstellen: eines zum Addieren und eines zum
Subtrahieren (so wie wir in der Schule schriftliches Addieren und Subtrahieren
getrennt gelernt haben). <example>Versuchen wir, das gängige Additionsverfahren 
für <m>10</m> und <m>-10</m> in der Vorzeichendarstellung anzuwenden, so
erhalten wir:<displaymath>
              <array layout = "cccccccc">
                <zeile>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                </zeile>
                <zeile>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                </zeile>
                <hline/>
                <zeile>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                </zeile>
              </array>
            </displaymath>



Das Ergebnis stellt keinenfalls die 
Zahl <m>0</m> dar, sondern die Zahl <m>-20</m>.</example>

Es läßt sich kein einheitlicher Algorithmus für die
Addition in dieser Darstellung finden.</subsubsection><subsubsection titel = "Einerkomplement">
Ausgehend von der Idee, daß man eine Zahlendarstellung sucht, in der allein
durch das bekannte Additionsverfahren auch mit negativen Zahlen korrekt
gerechnet wird, kann man das Verfahren des Einerkomplements wählen.
Die Idee des Einerkomplements ist, daß für jede Zahl die entsprechende
negative Zahl so dargestellt wird, indem jedes Bit gerade andersherum gesetzt
ist. <example>Bei einer Wortlänge von 8 Bit werden die 
Zahlen <m>10</m> und <m>-10</m> durch folgende Bitmuster 
dargestellt: <m>00001010</m> und <m>11110101</m>.<p/>

Jetzt können auch negative Zahlen mit dem gängigen Additionsverfahren addiert
werden, also kann die Subtraktion durch ein Additionsverfahren durchgeführt
werden. <displaymath>
              <array layout = "cccccccc">
                <zeile>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                </zeile>
                <zeile>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                </zeile>
                <hline/>
                <zeile>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                </zeile>
              </array>
            </displaymath>

Das errechnete Bitmuster stellt die <em>negative</em> Null
dar.</example>

In der Einerkomplementdarstellung läßt sich zwar fein rechnen, wir haben aber
immer noch zwei Bitmuster zur Darstellung der <m>0</m>. Für  eine 
Wortlänge <m>n</m> lassen sich auch wieder die Zahlen von <m>-2<superscript>n-1</superscript>-1</m> bis <m>2<superscript>n-1</superscript>-1</m> darstellen..

Ebenso wie in der Darstellung mit Vorzeichen und Betrag erkennt man in der
Einerkomplementdarstellung am linkesten Bit, ob es sich um eine negative oder
um eine positive Zahl handelt.</subsubsection><subsubsection titel = "Zweierkomplement">
Die Zweierkomplementdarstellung verfeinert die Einerkomplementdarstellung, so
daß es nur noch ein Bitmuster für die Null gibt. Im Zweierkomplement wird für
eine Zahl die negative Zahl gebildet, indem zu ihrer
Einerkomplementdarstellung noch 1 hinzuaddiert wird.<example>Bei einer Wortlänge von 8 Bit werden die 
Zahlen <m>10</m> und <m>-10</m> durch folgende Bitmuster 
dargestellt: <m>00001010</m> und <m>11110110</m>.<p/>

Jetzt können weiterhin auch negative Zahlen mit dem 
gängigen Additionsverfahren addiert
werden, also kann die Subtraktion durch ein Additionsverfahren durchgeführt
werden. <displaymath>
              <array layout = "cccccccc">
                <zeile>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                </zeile>
                <zeile>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                  <zelle>1</zelle>
                  <zelle>1</zelle>
                  <zelle>0</zelle>
                </zeile>
                <hline/>
                <zeile>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                  <zelle>0</zelle>
                </zeile>
              </array>
            </displaymath>


Das errechnete Bitmuster stellt die  Null
dar.</example>

Die <em>negative</em> Null aus dem Einerkomplement stellt im Zweierkomplement
keine Null dar, sondern die Zahl <m>-1</m>, wie man sich vergegenwärtigen
kann, wenn man von der 1 das Zweierkomplement bildet.</subsubsection>

Das Zweierkomplement ist die in heutigen Rechenanlagen gebräuchlichste Form
der Zahlendarstellung für ganze Zahlen. In modernen Programmiersprachen
spiegelt sich dieses in den Wertebereichen primitiver Zahlentypen wieder. So
kennt Java 4 Typen zur Darstellung ganzer Zahlen, die sich lediglich in der
Anzahl der Ziffern unterscheiden. Die Zahlen werden intern als
Zweierkomplement dargestellt.<center>
          <table layout = "|l|l|l|">
            <hline/>
            <zeile>
              <zelle>
                <b>Typname</b>
              </zelle>
              <zelle>
                <b>Länge</b>
              </zelle>
              <zelle>
                <b>Wertebereich</b>
              </zelle>
            </zeile>
            <hline/>
            <zeile>
              <zelle>
                <tt>byte</tt>
              </zelle>
              <zelle>8 Bit </zelle>
              <zelle><m>-128=-2<superscript>7</superscript></m> bis <m>127=2<superscript>7</superscript>-1</m></zelle>
            </zeile>
            <hline/>
            <zeile>
              <zelle>
                <tt>short</tt>
              </zelle>
              <zelle>16 Bit</zelle>
              <zelle><m>-32768=-2<superscript>15</superscript></m> bis <m>32767=2<superscript>15</superscript>-1</m></zelle>
            </zeile>
            <hline/>
            <zeile>
              <zelle>
                <tt>int</tt>
              </zelle>
              <zelle>32 Bit</zelle>
              <zelle><m>-2147483648=-2<superscript>31</superscript></m> bis <m>2147483647=2<superscript>32</superscript>-1</m></zelle>
            </zeile>
            <hline/>
            <zeile>
              <zelle>
                <tt>long</tt>
              </zelle>
              <zelle>64 Bit</zelle>
              <zelle><m>-9223372036854775808</m> bis <m>9223372036854775807</m></zelle>
            </zeile>
            <hline/>
          </table>
        </center>


In der Programmiersprache Java sind die konkreten Wertebereiche für die
einzelnen primitiven Typen in der Spezifikation festgelegt. In anderen
Programmiersprachen wie z.B.<w/>C ist dies nicht der Fall. Hier hängt es
vom Compiler und dem konkreten Rechner ab, welchen Wertebereich die
entsprechenden Typen haben.<p/>

Es gibt Programmiersprachen wie 
z.B.<w/>Haskell<cite label = "revisedHaskellReport"/>, in denen es einen Typ
gibt, der potentiell ganze Zahlen von beliebiger Größe darstellen kann.
 <aufgabe>
Starten Sie folgendes Javaprogramm:<code class = "TestInteger"
                lang = "java">class TestInteger {
  public static void main(String [] _){
    System.out.println(2147483647+1);
    System.out.println(-2147483648-1);
  }
}</code>
Erklären Sie die Ausgabe.</aufgabe><subsubsection titel = "Frage eines Softwaremenschen an die Hardwarebauer">
Gängige Spezifikationen moderner Programmiersprachen sehen einen
ausgezeichneten Wert <em>nan</em> für <em>not a number</em> in 
der Arithmetik vor, der ausdrücken soll,
daß es sich bei dem Wert nicht mehr um eine darstellbare Zahl handelt.  In der
Arithmetik moderne Prozessoren ist ein solcher zusätzlicher Wert nicht
vorgesehen. Warum eigentlich nicht?! Es sollte doch möglich sein, einen
Prozessor zu bauen, der beim Überlauf des Wertebereichs nicht stillschweigend
das durch den Überlauf entstandene Bitmuster wieder als Zahl interpretiert,
sondern den ausgezeichneten Wert <em>nan</em> als Ergebnis hat. Ein
Programmierer könnte dann entscheiden, wie er in diesem Fall verfahren
möchte. Eine  große Fehlerquelle wäre behoben. Warum ist eine solche
Arithmetik noch nicht in handelsüblichen Prozessoren verwirklicht?</subsubsection></subsection><subsection titel = "Kommazahlen">
Wollen wir  Kommazahlen, also Zahlen aus den 
Mengen <setQ/> und <setR/>, im Rechner darstellen,
so stoßen wir auf ein zusätzliches Problem: es gilt dann nämlich nicht mehr,
daß ein Intervall nur endlich viele Werte enthält, wie es für ganze Zahlen
noch der Fall ist. Bei ganzen Zahlen konnten wir immerhin wenigstens alle
Zahlen eines bestimmten Intervalls darstellen. Wir können also nur endlich viele
dieser unendlich vielen Werte in einem Intervall darstellen. Wir werden also
das Intervall <em>diskretisieren</em>.<subsubsection titel = "Festkommazahlen">
Vernachlässigen wir für einen Moment jetzt einmal wieder negative Zahlen. Eine
einfache und naheliegende Idee ist, bei einer Anzahl von <m>n</m> Bit, die
für die Darstellung der Kommazahlen zur Verfügung stehen, einen Teil
davon für den Anteil
vor dem Komma und den Rest für den Anteil nach dem Komma zu benutzen. Liegt
das Komma in der Mitte, so können wir eine Zahl aus <m>n</m> Ziffern durch
folgende Formel ausdrücken:

Der Wert der Zahl einer 
Zeichenkette <m>a<subscript>n-1</subscript><dots/><w/>a<subscript>n/2</subscript>,a<subscript>n/2-1</subscript><dots/><w/>a<subscript>0</subscript></m> berechnet sich für die Basis <m>b</m>  nach folgender
Formel: <p/><displaymath><sum>
              <von>i=0</von>
              <bis>n-1</bis>
            </sum> a<subscript>i</subscript><superscript>i-n/2</superscript>
= a<subscript>0</subscript>*b<superscript>-n/2</superscript> + <dots/> + a<subscript>n-1</subscript>*b<superscript>n-1-n/2</superscript></displaymath>


Wir kennen diese Darstellung aus dem im Alltag gebräuchlichen Zehnersystem.
Für Festkommazahlen ergibt sich ein überraschendes Phänomen. Zahlen, die sich
bezüglich einer Basis darstellen lassen, sind bezüglich einer anderen Basis
nicht darstellbar. So läßt sich schon die sehr einfach zur Basis 10
darstellbare Zahl <m>0,1</m> nicht zur Basis 2 als Festkommazahl darstellen,
und umgekehrt können Sie einfach zur Basis 2 als Festkommazahl darstellbare
Zahlen nicht zur Basis 10 darstellen.<p/>

Dem Leser wird natürlich nicht entgangen sein, daß wir keine irrationale Zahl 
über die Festkommadarstellung darstellen können.<p/>

Festkommazahlen spielen in der Rechnerarchitektur kaum eine Rolle. Ein sehr
verbreitetes Anwendungsgebiet für Festkommazahlen sind Währungsbeträge. Hier
interessieren in der Regel nur die ersten zwei oder drei Dezimalstellen nach
dem Komma.</subsubsection><subsubsection titel = "Fließkommazahlen">
Eine Alternative zu der Festkommadarstellung von Zahlen ist die
Fließkommadarstellung. Während die Festkommadarstellung einen Zahlenbereich
der rationalen Zahlen in einem festen Intervall durch diskrete, äquidistant
verteilte Werte darstellen kann, sind die diskreten Werte in der
Fließkommadarstellung nicht gleich verteilt.<p/>

In der Fließkommadarstellung wird eine Zahl durch zwei Zahlen charakterisiert
und ist bezüglich einer Basis <m>b</m>: <itemize>
            <item>die Mantisse für die darstellbaren Ziffern. Die Mantisse
charakterisiert die Genauigkeit der Fließkommazahl.</item>
            <item>der Exponent, der angibt, wie weit die Mantisse hinter bzw. vor dem
Komma liegt. </item>
          </itemize>

Aus Mantisse <m>m</m>, Basis <m>b</m> und Exponent <m>exp</m> ergibt sich
die dargestellte Zahl durch folgende Formel:<displaymath>z = m * b <superscript>exp</superscript></displaymath>
   
Damit lassen sich mit Fließkommazahlen sehr große und sehr kleine Zahlen
darstellen. Je größer jedoch die Zahlen werden, desto weiter liegen sie von der
nächsten Zahl entfernt.


Für die Fließkommadarstellung gibt es in Java zwei Zahlentypen, die nach der
Spezifikation des IEEE 754-1985 gebildet werden:<itemize>
            <item><b>float</b>: 32 Bit Fließkommazahl nach IEEE 754. Kleinste positive
Zahl: <m>2<superscript>-149</superscript></m>. 
Größte positive 
Zahl: <m>(2-2<superscript>-23</superscript>)*<superscript>127</superscript></m></item>
            <item><b>double</b>: 64 Bit Fließkommazahl nach IEEE 754. Kleinste positive
Zahl: <m>2<superscript>-1074</superscript></m>. 
Größte positive 
Zahl: <m>(2-2<superscript>-52</superscript>)*<superscript>1023</superscript></m></item>
          </itemize>

Im Format für <tt>double</tt> steht das erste Bit für das Vorzeichen, die
nächsten 11 Bit markieren den Exponenten und die restlichen 52 Bit kodieren
die Mantisse. <p/>

Im Format für <tt>float</tt> steht das erste Bit für das Vorzeichen, die
nächsten 8 Bit markieren den Exponenten und die restlichen 23 Bit kodieren
die Mantisse. <p/>


Bestimmte Bitmuster charakterisieren einen Wert für negative
und positive unbeschränkte Werte (unendlich) sowie Zahlen, Bitmuster, die
charakterisieren, daß es sich nicht mehr um eine Zahl handelt.<example>
Der folgende Test zeigt, daß bei einer Addition von zwei Fließkommazahlen die
kleinere Zahl das Nachsehen hat:  <code class = "DoubleTest"
                  lang = "java">class DoubleTest{
  public static void main(String [] args){
    double x = 325e200;
    double y = 325e-200;
    System.out.println(x);
    System.out.println(y);
    System.out.println(x+y);
    System.out.println(x+100000);
  } 
}</code>

Wie man an der Ausgabe erkennen kann: selbst die Addition der 
Zahl <tt>100000</tt> bewirkt keine Veränderung auf einer großen
Fließkommazahl: <scode>sep@linux:~/fh/prog3/examples/src&gt; java DoubleTest
3.25E202
3.25E-198
3.25E202
3.25E202
sep@linux:~/fh/prog3/examples/src&gt;</scode></example><example>
Das folgende kleine Beispiel zeigt, inwieweit und für den Benutzer oft auf
überraschende Weise die Fließkommadarstellung zu Rundungen führt:<code class = "Rounded"
                  lang = "java">class Rounded {
  public static void main(String [] args){
    System.out.println(8f);
    System.out.println(88f);
    System.out.println(8888f);
    System.out.println(88888f);
    System.out.println(888888f);
    System.out.println(8888888f);
    System.out.println(88888888f);
    System.out.println(888888888f);
    System.out.println(8888888888f);
    System.out.println(88888888888f);
    System.out.println(888888888888f);
    System.out.println(8888888888888f);

    System.out.println(1f+1000000000000f-1000000000000f);
  } 
}
</code>
Das Programm hat die folgende Ausgabe. Insbesondere in der letzten Zeile
  fällt auf, daß Addition und anschließende Subtraktion ein und derselben Zahl
  nicht die Identität ist. Für Fließkommazahlen gilt 
nicht: <m>x + y - y = x</m>.<scode>sep@linux:~/fh/prog3/examples/src&gt; java Rounded
8.0
88.0
8888.0
88888.0
888888.0
8888888.0
8.8888888E7
8.888889E8
8.8888893E9
8.8888885E10
8.8888889E11
8.8888889E12
0.0
sep@linux:~/fh/prog3/examples/src&gt;</scode></example></subsubsection></subsection><subsection titel = "Der Typ: boolean">
Eine in der Informatik häufig gebrauchte Unterscheidung ist, ob etwas
wahr oder falsch ist, also eine Unterscheidung zwischen genau zwei
Werten.<footnote>Wahr oder falsch, eine dritte Möglikchkeit gibt es
nicht. Logiker postulieren dieses als <em>tertium non
datur</em>.</footnote>  Hierzu bedient man sich der Wahrheitswerte aus
der formalen 
Logik. Java bietet einen primitiven Typ an, der genau zwei Werte
annehmen kann, den Typ: <tt>boolean</tt>. Die Bezeichnung ist nach dem
englischen Mathematiker und Logiker George Bool (1815--1869) gewählt 
worden. <p/>
Entsprechend der zwei möglichen Werte für diesen Typ stellt Java auch
zwei Literale zur Verfügung: <tt>true</tt> und <tt>false</tt>.<p/>
Bool&#39;sche Daten lassen sich ebenso wie numerische Daten
benutzen. Felder und Methoden können diesen Typ verwenden.<code lang = "java"
              class = "Testbool">class Testbool{
  boolean boolFeld;

  Testbool(boolean b){
    boolFeld = b;
  }

  boolean getBoolFeld(){
    return this.boolFeld;
  }

  public static void main(String [] args){
    Testbool t = new Testbool(true);
    System.out.println(t.getBoolFeld());
    t = new Testbool(false);
    System.out.println(t.getBoolFeld());
  }
}</code></subsection><subsection titel = "Boxen für primitive Typen">
Javas Typsystem ist etwas zweigeteilt. Es gibt Objekttypen und primitive
Typen. Die Daten der primitiven Typen stellen keine Objekte dar. Für jeden
primitiven Typen gibt es allerdings im Paket <tt>java.lang</tt> eine Klasse,
die es erlaubt, Daten eines primitiven Typs als Objekt zu speichern. Dieses
sind die Klassen <tt>Byte</tt>, <tt>Short</tt>, <tt>Integer</tt>, <tt>Long</tt>, <tt>Float</tt>, <tt>Double</tt>, <tt>Boolean</tt> und <tt>Character</tt>.  Objekte dieser Klassen sind nicht modifizierbar. Einmal ein
Integer-Objekt mit einer bestimmten Zahl erzeugt, läßt sich die in diesem
Objekt erzeugte Zahl nicht mehr verändern.<p/>

Wollte man in bisherigen  Klassen ein Datum eines primitiven Typen in einer
Variablen speichern, die nur Objekte speichern kann, so mußte man es in einem
Objekt der entsprechenden Klasse kapseln. Man spricht von <em>boxing</em>.
Es kam zu Konstruktoraufrufen dieser Klassen. Sollte später mit Operatoren auf
den Zahlen, die durch solche gekapselten Objekte ausgedrückt wurden, gerechnet
werden, so war der primitive Wer mit einem Methodenaufruf aus dem Objekt
wieder zu extrahieren, dem sogenannten <em>unboxing</em>. Es kam zu Aufrufen
von Methoden wie <tt>intValue()</tt> im Code.<example>
In diesem Beispiel sieht man das manuelle Verpacken und Auspacken primitiver
Daten. <code lang = "java"
                class = "ManualBoxing"
                package = "name/panitz/boxing">package name.panitz.boxing;
public class ManualBoxing{
  public static void main(String [] _){
    int i1 = 42;
    Object o = new Integer(i1);
    System.out.println(o);
    Integer i2 = new Integer(17);
    Integer i3 = new Integer(4);
    int i4 = 21;
    System.out.println((i2.intValue()+i3.intValue())*i4);
  }
}</code></example>

In Java können die primitiven Typen mit ihren entsprechenden Klassen
synonym verwendet werden. Nach außen hin werden die primitiven Typen auch zu
Objekttypen. Der Übersetzer nimmt fügt die notwendigen <em>boxing</em>- und <em>unboxing</em>-Operationen vor.<example>
Jetzt das vorherige kleine Programm ohne 
explizite <em>boxing</em>- und <em>unboxing</em>-Aufrufe.<code lang = "java"
                class = "AutomaticBoxing"
                package = "name/panitz/boxing">package name.panitz.boxing;
public class AutomaticBoxing{
  public static void main(String [] _){
    int i1 = 42;
    Object o = i1;
    System.out.println(o);
    Integer i2 = 17;
    Integer i3 = 4;
    int i4 = 21;
    System.out.println((i2+i3)*i4);
  }
}</code></example></subsection></section><section titel = "Operatoren">
Wir haben jetzt gesehen, was Java uns für Typen zur Darstellung von
Zahlen zur Verfügung stellt. Jetzt wollen wir mit diesen Zahlen nach
Möglichkeit auch noch rechnen können. Hierzu stellt Java eine feste
Anzahl von Operatoren wie <tt>*, -, /</tt> etc.<white/>zur
Verfügung. Prinzipell gibt es in der Informatik für Operatoren drei
mögliche Schreibweisen:<itemize>
        <item><b>Präfix:</b> Der Operator wird vor den Operanden geschrieben,
also z.B.<white/><tt>(* 2 21)</tt>. Im ursprünglichen Lisp gab es die
Prefixnotation für Operatoren.
 </item>
        <item><b>Postfix: </b>Der Operator folgt den Operanden, also 
z.B.<white/><tt>(21 2 *)</tt>. Forth und Postscript sind Beispiele von
Sprachen mit Postfixnotation.</item>
        <item><b>Infix:</b> Der Operator steht zwischen den Operanden. Dieses
ist die gängige Schreibweise in der Mathematik und für das Auge die
gewohnteste. Aus diesem Grunde bedient sich Java der 
Infixnotation: <tt>42 * 2</tt>.</item>
      </itemize><subsubsection titel = "Die Grundrechenarten">
Java stellt für Zahlen die vier Grundrechenarten zur Verfügung.<p/>
Bei der Infixnotation gelten für die vier Grundrechenarten die
üblichen Regeln der Bindung, nämlich Punktrechnung vor Strichrechnung.
Möchte man diese Regel durchbrechen, so sind Unterausdrücke in
Klammern zu setzen. Folgende kleine Klasse demonstriert den Unterschied:<code lang = "java"
              class = "PunktVorStrich">class PunktVorStrich{
  public static void main(String [] args){
    System.out.println(2 + 20 * 2);
    System.out.println((2 + 20) * 2);
  }
}</code>


Wir können nun also Methoden schreiben, die Rechnungen vornehmen. In
der folgenden Klasse definieren wir z.B.<white/>eine Methode zum Berechnen
der Quadratzahl der Eingabe:<code lang = "java"
              class = "Square">class Square{
  static int square(int i){
    return i*i;
  }
}</code></subsubsection><subsubsection titel = "Vergleichsoperatoren">
Obige Operatoren rechnen jeweils auf zwei Zahlen und ergeben wieder
eine Zahl als Ergebnis. Vergleichsoperatoren vergleichen zwei Zahlen
und geben einen bool&#39;schen Wert, der angibt, ob der Vergleich wahr
oder falsch ist. Java stellt die folgenden Vergleichsoperatoren zur
Verfügung: <tt>&lt;, &lt;=, &gt;, &gt;=, !=, ==</tt>. 
Für die Gleichheit ist in Java das doppelte 
Gleichheitszeichen <tt>==</tt> zu schreiben, 
denn das einfache Gleichheitszeichen ist 
bereits für den Zuweisungsbefehl vergeben. Die Ungleichheit wird mit<tt>!=</tt> bezeichnet.<p/>
Folgende Tests demonstrieren
die Benutzung der Vergleichsoperatoren:<code lang = "java"
              class = "Vergleich">class Vergleich{

  public static void main(String[] args){
    System.out.println(1+1 &lt; 42);
    System.out.println(1+1 &lt;= 42);
    System.out.println(1+1 &gt;  42);
    System.out.println(1+1 &gt;= 42);
    System.out.println(1+1 == 42);
    System.out.println(1+1 != 42);
  }
}</code></subsubsection><subsubsection titel = "Bool&#39;sche Operatoren">
In der bool&#39;schen Logik gibt es eine ganze Reihe von binären
Operatoren für logische Ausdrücke. Für zwei davon stellt Java auch
Operatoren bereit: <tt>&amp;&amp;</tt> für das logische und (<m>
          <and/>
        </m>) und <tt>||</tt> für das logische oder (<m>
          <or/>
        </m>).<p/>
Zusätzlich kennt Java noch den unären Operator der logischen
Negation $\neg$. Er wird in Java mit <tt>!</tt> bezeichnet.<p/>
Wie man im folgenden Test sehen kann, gibt es auch unter den
bool&#39;schen Operatoren eine Bindungspräzedenz, ähnlich wie bei der
Regel Punktrechnung vor Strichrechnung. Der Operator <tt>&amp;&amp;</tt>
bindet stärker als der Operator <tt>||</tt>:<code lang = "java"
              class = "TestboolOperator">class TestboolOperator{
  public static void main(String [] args){
    System.out.println(true &amp;&amp; false);
    System.out.println(true || false);
    System.out.println(!true || false);
    System.out.println(true || true &amp;&amp; false);
  }
}</code>

In der formalen Logik kennt man noch weitere Operatoren, z.B.<white/>die
Implikation $\rightarrow$. Diese Operatoren lassen sich aber durch die
in Java zur Verfügung stehenden Operatoren ausdrücken. 
$A\rightarrow B$ entspricht $\neg A\vee B$. Wir können somit eine Methode schreiben, die die logische Implikation testet:   <code lang = "java"
              class = "TestboolOperator2">class TestboolOperator2{
  static boolean implication(boolean a, boolean b){
    return !a || b;
  }

  public static void main(String [] args){
    System.out.println(implication(true, false));
  }
}</code></subsubsection></section><section titel = "Zusammengesetzte Befehle">
Streng genommen  kennen wir bisher nur einen Befehl, den
Zuweisungsbefehl, der einem Feld einen neuen Wert 
zuweist.<footnote>Konstrukte mit Operatoren nennt man dagegen
Ausdrücke.</footnote> In diesem Abschnitt lernen wir weitere Befehle
kennen. Diese Befehle sind in dem Sinne zusammengesetzt, daß sie
andere Befehle als Unterbefehle haben.<subsection titel = "Bedingungsabfrage mit: if">
Ein häufig benötigtes Konstrukt ist, daß ein Programm abhängig von 
einer bool&#39;schen Bedingung sich verschieden verhält. Hierzu stellt
Java die <b>if</b>-Bedingung zur Verfügung. Dem 
Schlüsselwort <tt>if</tt> folgt in Klammern eine bool&#39;sche 
Bedingung, anschließend
kommen in geschweiften Klammern die Befehle, die auszuführen
sind, wenn die Bedingung wahr ist. Anschließend kann optional das
Schlüsselwort <tt>else</tt> folgen mit den Befehlen, die andernfalls auszuführen sind:<code lang = "java"
              class = "FirstIf">class FirstIf {

  static void firstIf(boolean bedingung){
    if (bedingung) {
      System.out.println(&quot;Bedingung ist wahr&quot;);
    } else {
      System.out.println(&quot;Bedingung ist falsch&quot;);
    }
  }
 
  public static void main(String [] args){
     firstIf(true || false);
  }

}</code>

Das <tt>if</tt>-Konstrukt erlaubt es uns also, Fallunterscheidungen zu
treffen.  Wenn in den Alternativen nur ein Befehl steht, so können die
geschweiften Klammern auch fortgelassen werden. Unser Beispiel läßt
sich also auch schreiben als:<code lang = "java"
              class = "FirstIf2">class FirstIf2 {

  static void firstIf(boolean bedingung){
    if (bedingung) System.out.println(&quot;Bedingung ist wahr&quot;);
    else System.out.println(&quot;Bedingung ist falsch&quot;);
  }
 
  public static void main(String [] args){
     firstIf(true || false);
  }

}</code>
Eine Folge von mehreren <tt>if</tt>-Konstrukten läßt sich auch
direkt hintereinanderschreiben, so daß eine   Kette von <tt>if</tt>- und <tt>else</tt>-Klauseln entsteht:<code lang = "java"
              class = "ElseIf">class ElseIf {

  static String lessOrEq(int i,int j){
    if (i&lt;10)  return &quot;i kleiner zehn&quot;;
    else if (i&gt;10)  return &quot;i größer zehn&quot;;
    else if (j&gt;10)  return &quot;j größer zehn&quot;;
    else if (j&lt;10)  return &quot;j kleiner zehn&quot;;
    else return &quot;j=i=10&quot;;
  }
 
  public static void main(String [] args){
     System.out.println(lessOrEq(10,9));
  }

}</code>
Wenn zuviele <tt>if</tt>-Bedingungen in einem Programm einander folgen
und ineinander verschachtelt sind, dann wird das Programm schnell
unübersichtlich. Man spricht auch von <em>Spaghetti-code</em>. In
der Regel empfiehlt es sich, in solchen Fällen noch einmal über das
Design nachzudenken, ob die abgefragten Bedingungen sich nicht durch
verschiedene Klassen mit eigenen Methoden darstellen lassen. <p/>
Mit der Möglichkeit, in dem Programm abhängig von einer Bedingung
unterschiedlich weiterzurechnen, haben wir theoretisch die Möglichkeit,
alle durch ein Computerprogramm berechenbaren mathematischen
Funktionen zu programmieren. So können wir z.B.<white/>eine Methode
schreiben, die für eine Zahl <tt>i</tt> die Summe  von <tt>1</tt> bis <tt>n</tt> berechnet:<code class = "Summe"
              lang = "java">class Summe{
  static int summe(int i){
    if (i==1)  {
      return 1;
    }else {
      return summe(i-1) + i;
    }
  }
}</code>


Wir können dieses Programm von Hand ausführen, indem wir den
Methodenaufruf für <tt>summe</tt> für einen konkreten 
Parameter <tt>i</tt> durch die für diesen Wert zutreffende Alternative der
Bedingungsabfrage ersetzen. Wir kennzeichnen einen solchen Ersetzungsschritt durch einen Pfeil <rightarrow/>:<p/><tt>summe(4)</tt><br/><rightarrow/><tt>summe(4-1)+4</tt><br/><rightarrow/><tt>summe(3)+4</tt><br/><rightarrow/><tt>summe(3-1)+3+4</tt><br/><rightarrow/><tt>summe(2)+3+4</tt><br/><rightarrow/><tt>summe(2-1)+2+3+4</tt><br/><rightarrow/><tt>summe(1)+2+3+4</tt><br/><rightarrow/><tt>1+2+3+4</tt><br/><rightarrow/><tt>3+3+4</tt><br/><rightarrow/><tt>6+4</tt><br/><rightarrow/><tt>10</tt><p/>

Wie man sieht, wird für <tt>i=4</tt> die Methode <tt>summe</tt> genau
viermal wieder aufgerufen, bis schließlich die Alternative mit dem
konstanten Rückgabewert <tt>1</tt> zutrifft. Unser Trick war, im
Methodenrumpf die Methode, die wir gerade definieren, bereits zu
benutzen. Diesen Trick nennt man in der 
Informatik <em>Rekursion</em>. Mit diesem Trick ist es uns möglich,
ein Programm zu schreiben, bei dessen Ausführung ein bestimmter Teil
des Programms mehrfach durchlaufen wird.<p/>
Das wiederholte Durchlaufen von einem Programmteil ist das A und O der
Programmierung. Daher stellen Programmiersprachen in der Regel
Konstrukte zur Verfügung, mit denen man dieses direkt ausdrücken
kann. Die Rekursion ist lediglich ein feiner Trick, dieses zu
bewerkstelligen. In den folgenden Abschnitten lernen wir die
zusammengesetzten Befehle von Java kennen, die es erlauben
auszudrücken, daß ein Programmteil mehrfach zu durchlaufen ist.<aufgabe>Ergänzen Sie ihre Klasse <tt>Ausleihe</tt> um eine 
Methode <tt>void verlaengereEinenMonat()</tt>, die den Rückgabetermin des
Buches um einen Monat erhöht.</aufgabe><aufgabe>Modellieren und schreiben Sie eine Klasse <tt>Counter</tt>,
die einen Zähler darstellt. Objekte dieser Klasse sollen folgende
Funktionalität bereitsstellen:<itemize>
            <item>Eine Methode <tt>click()</tt>, die den internen Zähler um eins
erhöht. </item>
            <item>Eine Methode <tt>reset()</tt>, die den Zähler wieder auf den
Wert <tt>0</tt> setzt.</item>
            <item>Eine Methode, die den aktuellen Wert des Zählers ausgibt.</item>
          </itemize>
Testen Sie Ihre Klasse.</aufgabe><aufgabe>Schreiben Sie mit den bisher vorgestellten Konzepten ein Programm,
das unendlich oft das Wort <tt>Hallo</tt> auf den Bildschirm ausgibt. Was
beobachten Sie, wenn sie das Programm lange laufen lassen?</aufgabe><aufgabe>Schreiben Sie eine Methode, die für eine ganze Zahl die
Fakultät dieser Zahl berechnet. Testen Sie die Methode zunächst mit
kleinen Zahlen, anschließend mit großen Zahlen. Was stellen Sie fest?</aufgabe><aufgabe>Modellieren und schreiben Sie eine Klasse, die ein Bankkonto
darstellt. Auf das Bankkonto sollen Einzahlungen und Auszahlungen
vorgenommen werden können. Es gibt einen maximalen Kreditrahmen. Das
Konto soll also nicht beliebig viel in die Miese gehen
können. Schließlich muß es eine Möglichkeit geben, Zinsen zu berechnen
und dem Konto gutzuschreiben.</aufgabe></subsection><subsection titel = "Iteration">
Die im letzten Abschnitt kennengelernte Programmierung der Programmwiederholung durch Rekursion kommt ohne zusätzliche
zusammengesetzte Befehle von Java aus. Da Rekursionen von der
virtuellen Maschine Javas nur bis zu einem gewissen Maße unterstützt
werden, bietet Java spezielle Befehle an, die es erlauben, einen
Programmteil kontrolliert mehrfach zu durchlaufen. Die entsprechenden
zusammengesetzten Befehle heißen Iterationsbefehle. Java kennt drei
unterschiedliche Iterationsbefehle.<subsubsection titel = "Schleifen mit: while">
Ziel der Iterationsbefehle ist es, einen bestimmten Programmteil
mehrfach zu durchlaufen. Hierzu ist es notwendig, eine Bedingung
anzugeben, für wie lange eine Schleife zu durchlaufen
ist. <tt>while</tt>-Schleifen in Java haben somit genau zwei Teile:<itemize>
            <item>die Bedingung</item>
            <item>und den Schleifenrumpf.</item>
          </itemize>

Java unterscheidet zwei Arten von <tt>while</tt>-Schleifen: Schleifen,
für die vor dem Durchlaufen der Befehle des Rumpfes die Bedingung geprüft wird, und Schleifen, für die nach Durchlaufen des Rumpfes die
Bedingung geprüft wird.<paragraph titel = "Vorgeprüfte Schleifen">
Die vorgeprüften Schleifen haben folgendes Schema in Java:<p/><center>
              <fbox>
                <ttt>while (</ttt>
                <em>pred</em>
                <ttt>)<lpar/></ttt>
                <em>body</em>
                <ttt>
                  <rpar/>
                </ttt>
              </fbox>
            </center> <p/><em>pred</em> ist hierbei ein Ausdruck, der zu einem bool&#39;schen Wert
auswertet. <em>body</em> ist eine Folge von Befehlen. Java arbeitet
die vorgeprüfte Schleife ab, indem erst die Bedingung <em>pred</em>
ausgewertet wird. Ist das Ergebnis <tt>true</tt>, dann wird der 
Rumpf <em>(body)</em> der Schleife durchlaufen. Anschließend wird
wieder die Bedingung geprüft. Dieses wiederholt sich so lange, bis die
Bedingung zu <tt>false</tt> auswertet.<p/>
Ein simples Beispiel einer vorgeprüften Schleife ist folgendes Programm,  das
die Zahlen von 0 bis 9 auf dem Bildschirm ausgibt:<code class = "WhileTest"
                  lang = "java">class WhileTest {
  public static void main(String [] args){
    int i = 0;
    while (i &lt; 10){
      i = i+1;
      System.out.println(i);    
    }
  }
}</code>

Mit diesen Mitteln können wir jetzt versuchen, die im letzten
Abschnitt rekursiv geschriebene Methode <tt>summe</tt> iterativ zu
schreiben:<code class = "Summe2"
                  lang = "java">class Summe2 {
  public static int summe(int n){

    int erg = 0 ;              // <bluev>Feld für Ergebnis</bluev>.
    <redv>int j   = n</redv> ;              // <bluev>Feld zur Schleifenkontrolle</bluev>.

    while (<redv>j&gt;0</redv>){               // <bluev>j läuft von n bis 1</bluev>.     
      erg = erg + j;           // <bluev>akkumuliere das Ergebnis</bluev>.
      <redv>j = j-1</redv>;                 // <bluev>verringere Laufzähler</bluev>.
    }

    return erg;
  }
}</code> 

Wie man an beiden Beispielen oben sieht, gibt es oft ein Feld, das zur
Steuerung der Schleife benutzt wird. Dieses Feld verändert innerhalb
des Schleifenrumpfes seinen Wert. Abhängig von diesem Wert wird die
Schleifenbedingung beim nächsten Bedingungstest wieder wahr oder
falsch.<p/>
Schleifen haben die unangenehme Eigenschaft, daß sie eventuell nie
verlassen werden. Eine solche Schleife läßt sich minimal wie folgt
schreiben: <code class = "Bottom"
                  lang = "java">class Bottom {
   static public void bottom(){
     while (wahr()){};
   }

   static boolean wahr(){return true;}

   public static void main(String [] _){bottom();}
}</code>

Ein Aufruf der Methode <tt>bottom</tt> startet eine nicht endende
Berechnung. <p/> Häufige Programmierfehler sind inkorrekte Schleifenbedingungen oder
falsch kontrollierte Schleifenvariablen. Das Programm terminiert dann
mitunter nicht. Solche Fehler sind in komplexen Programmen oft schwer
zu finden.</paragraph><paragraph titel = "Nachgeprüfte Schleifen">
In der zweiten Variante der <tt>while</tt>-Schleife steht die
Schleifenbedingung syntaktisch nach dem Schleifenrumpf:<p/> <center>
              <fbox>
                <ttt>do <lpar/></ttt>
                <em>body</em>
                <ttt><rpar/> while (</ttt>
                <em>pred</em>
                <ttt>)</ttt>
              </fbox>
            </center><p/>
Bei der Abarbeitung einer solchen Schleife wird entsprechend der
Notation, die Bedingung erst nach der Ausführung des Schleifenrumpfes 
geprüft. Am Ende wird also geprüft, ob die Schleife ein weiteres Mal
zu durchlaufen ist. Das impliziert insbesondere, daß der Rumpf
mindestens einmal durchlaufen wird.<p/>
Die erste Schleife, die wir für die vorgeprüfte Schleife geschrieben
haben, hat folgende  nachgeprüfte Variante:<code class = "DoTest"
                  lang = "java">class DoTest {
  public static void main(String [] args){
    int i = 0;
    do {
      System.out.println(i);    
      i = i+1;
    } while (i &lt; 10);
  }
}</code>

Man kann sich leicht davon vergewissern, daß die nachgeprüfte Schleife
mindestens einmal durchlaufen<footnote>Der Javaübersetzer macht kleine
Prüfungen auf konstanten Werten, ob Schleifen jeweils durchlaufen
werden oder nicht terminieren. Deshalb brauchen wir 
die Hilfsmethode {\tt falsch()}.</footnote> wird:<code class = "VorUndNach"
                  lang = "java">class VorUndNach {

  public static void main(String [] args){

      while (falsch()) 
         {System.out.println(&quot;vorgeprüfte Schleife&quot;);};

      do {System.out.println(&quot;nachgeprüfte Schleife&quot;);} 
      while (false);
  }

  public static boolean falsch(){return false;}
}</code></paragraph></subsubsection><subsubsection titel = "Schleifen mit: for">
Das syntaktisch aufwendigste Schleifenkonstrukt in Java ist 
die <em>for</em>-Schleife. <p/>
Wer sich die obigen Schleifen anschaut, sieht, daß sie an drei
verschiedenen Stellen im Programmtext Code haben, der kontrolliert,
wie oft die Schleife zu durchlaufen ist. Oft legen wir ein spezielles
Feld an, dessen Wert die Schleife kontrollieren soll. Dann gibt es im
Schleifenrumpf einen Zuweisungsbefehl, der den Wert dieses Feldes
verändert. Schließlich wird der Wert dieses Feldes in der
Schleifenbedingung abgefragt.<p/>
Die Idee der <em>for</em>-Schleife ist, diesen 
Code, der kontrolliert, wie oft die Schleife durchlaufen werden
soll, im Kopf der Schleife zu bündeln. Solche Daten sind oft Zähler
vom Typ <tt>int</tt>, die bis zu einem bestimmten Wert herunter oder
hoch gezählt werden. Später werden wir noch die 
Standardklasse <tt>Iterator</tt> kennenlernen, die benutzt wird, um
durch Listenelemente durchzuiterieren. <p/>
Eine <em>for</em>-Schleife hat im Kopf <itemize>
            <item> eine Initialisierung der
relevanten Schleifensteuerungsvariablen <em>(init)</em>,</item>
            <item>ein Prädikat als 
Schleifenbedingung <em>(pred)</em></item>
            <item>und einen
Befehl, der die Schleifensteuerungsvariable 
weiterschaltet <em>(step)</em>.</item>
          </itemize><p/> <p/><center>
            <fbox>
              <ttt>for (</ttt>
              <em>init, pred, step</em>
              <ttt>)<lpar/></ttt>
              <em>body</em>
              <ttt>
                <rpar/>
              </ttt>
            </fbox>
          </center><p/> Entsprechend sieht unsere jeweilige erste Schleife (die Ausgabe der Zahlen von 0 bis 9) in der <tt>for</tt>-Schleifenversion wie folgt aus:  <code class = "ForTest"
                lang = "java">class ForTest {
  public static void main(String [] args){

    for (int i=0; i&lt;10; i=i+1){
      System.out.println(i);    
    }  

  }
}</code>

Die Reihenfolge, in der die verschiedenen Teile 
der <tt>for</tt>-Schleife 
durchlaufen werden, wirkt erst etwas verwirrend,
ergibt sich aber natürlich aus der Herleitung 
der <tt>for</tt>-Schleife aus der vorgeprüften <tt>while</tt>-Schleife:<p/>
Als erstes wird genau einmal die Initialisierung der Schleifenvariablen
ausgeführt. Anschließend wird die Bedingung geprüft. Abhängig davon
wird der Schleifenrumpf ausgeführt. Als letztes wird die
Weiterschaltung ausgeführt, bevor wieder die Bedingung geprüft wird.<p/>
Die nun schon hinlänglich bekannte Methode <tt>summe</tt> stellt sich in der Version mit der <tt>for</tt>-Schleife wie folgt dar:<code class = "Summe3"
                lang = "java">class Summe3 {
  public static int summe(int n){

    int erg = 0 ;                   // <bluev>Feld für Ergebnis</bluev>

    for (<redv>int j = n</redv>;<bluev>j&gt;0</bluev>;<greenv>j=j-1</greenv>){      // <bluev>j läuft von n bis 1</bluev>     
      erg = erg + j;                // <bluev>akkumuliere das Ergebnis</bluev>
    }

    return erg;
  }
}</code> 

Beim Vergleich mit der <tt>while</tt>-Version erkennt man, wie sich
die Schleifensteuerung im Kopf der <tt>for</tt>-Schleife nun gebündelt
an einer syntaktischen Stelle befindet.<p/>
Die drei Teile des Kopfes einer <tt>for</tt>-Schleife können auch leer
sein. Dann wird in der Regel an einer anderen Stelle der Schleife
entsprechender Code zu finden sein. So können wir die Summe auch mit
Hilfe der <tt>for</tt>-Schleife so schreiben, daß die Schleifeninitialisierung und Weiterschaltung vor der Schleife bzw.<white/>im
Rumpf durchgeführt wird:<code class = "Summe4"
                lang = "java">class Summe4 {
  public static int summe(int n){

    int erg = 0 ;              // <bluev>Feld für Ergebnis</bluev>.
    <redv>int j   = n</redv>;              // <bluev>Feld zur Schleifenkontrolle</bluev>

    for (;<bluev>j&gt;0</bluev>;){               // <bluev>j läuft von n bis 1</bluev>     
      erg = erg + j;           // <bluev>akkumuliere das Ergebnis</bluev>.
      <greenv>j = j-1</greenv>;                 // <bluev>verringere Laufzähler</bluev>  
    }

    return erg;
  }
}</code> 

Wie man jetzt sieht, ist die <tt>while</tt>-Schleife nur ein
besonderer Fall der <tt>for</tt>-Schleife. 
Obiges Programm ist ein schlechter Programmierstil. Hier wird ohne Not
die Schleifensteuerung mit der eigentlichen Anwendungslogik vermischt.</subsubsection><subsubsection titel = "Vorzeitiges Beenden von Schleifen">
Java bietet innerhalb des Rumpfes seiner Schleifen zwei Befehle an,
die die eigentliche Steuerung der Schleife durchbrechen. Entgegen der
im letzten Abschnitt vorgestellten Abarbeitung der
Schleifenkonstrukte, führen diese Befehle zum plötzlichen Abbruch des
aktuellen Schleifendurchlaufs.<paragraph titel = "Verlassen der Schleife">
Der Befehl, um eine Schleife komplett zu verlassen, 
heißt <tt>break</tt>. Der <tt>break</tt> führt zum sofortigen Abbruch der nächsten äußeren Schleife.<p/>
Der <tt>break</tt>-Befehl wird in der Regel mit 
einer <tt>if</tt>-Bedingung auftreten.<p/> Mit diesem Befehl läßt sich die Schleifenbedingung auch im Rumpf der
Schleife ausdrücken. Das Programm der Zahlen 0 bis 9 läßt sich
entsprechend unschön auch mit Hilfe des <tt>break</tt>-Befehls wie
folgt schreiben.<code class = "BreakTest"
                  lang = "java">class BreakTest {
  public static void main(String [] args){
    <redv>int i = 0</redv>;
    while (true){
      if (<bluev>i&gt;9</bluev>) {break;};
      <greenv>i = i+1</greenv>;
      System.out.println(i);    
    }
  }
}</code>

Gleichfalls läßt sich der <tt>break</tt>-Befehl in 
der <tt>for</tt>-Schleife anwenden. Dann wird der Kopf  der <tt>for</tt>-Schleife vollkommen leer: <code class = "ForBreak"
                  lang = "java">class ForBreak {
  public static void main(String [] args){
    <redv>int i = 0</redv>;
    for (;;){
        if (<bluev>i&gt;9</bluev>) break;
        System.out.println(i);
        <greenv>i=i+1</greenv>; 
    }  
  }
}</code>

In der Praxis wird der <tt>break</tt>-Befehl gerne für besondere Situationen inmitten einer längeren Schleife benutzt, z.B. für externe
Signale. </paragraph><paragraph titel = "Verlassen des Schleifenrumpfes"> Die zweite Möglichkeit, den Schleifendurchlauf zu unterbrechen, ist der
Befehl <tt>continue</tt>. Diese Anweisung bricht nicht die Schleife
komplett ab, sondern nur den aktuellen Durchlauf. Es wird zum nächsten 
Durchlauf gesprungen. <p/>
Folgendes kleines Programm druckt mit Hilfe 
des <tt>continue</tt>-Befehls die Zahlen aus, die durch 17 oder 19 teilbar sind:<code class = "ContTest"
                  lang = "java">class ContTest{
  public static void main(String [] args){
     for (int i=1; i&lt;1000;i=i+1){           
        if (!(i % 17 == 0 || i % 19 == 0) )
   //<bluev>wenn nicht die Zahl durch 17 oder 19 ohne Rest teilbar ist</bluev>
            continue;
	System.out.println(i);  
     }
  }
}</code>

Wie man an der Ausgabe dieses Programms sieht, wird mit dem 
Befehl <tt>continue</tt> der Schleifenrumpf verlassen und die
Schleife im Kopf weiter abgearbeitet. Für die <tt>for</tt>-Schleife
heißt das insbesondere, daß die Schleifenweiterschaltung der nächste
Ausführungsschritt ist. 
 </paragraph></subsubsection><aufgabe>Schreiben Sie jetzt die Methode zur Berechnung der Fakultät, indem
Sie eine Iteration und nicht eine Rekursion benutzen.</aufgabe><aufgabe>Schreiben Sie eine 
Methode<br/><tt>static String darstellungZurBasis(int x,int b)</tt>, 
die als Parameter eine  
Zahl <m>x</m> und eine zweite Zahl <m>b</m> erhält. 
Sie dürfen annehmen, daß <m>x&gt;0</m> und <m>1&lt;b&lt;11</m>.
Das Ergebnis soll 
eine Zeichenkette vom Typ <tt>String</tt> sein, in der die 
Zahl <m>x</m> zur Basis <m>b</m> dargestellt ist. Testen Sie ihre Methode mit
unterschiedlichen Basen.<p/><b>Hinweis:</b> Der zweistellige Operator <tt>%</tt> berechnet den
ganzzahligen Rest einer Division. Bei einem geschickten Umgang mit den
Operatoren <tt>%, /</tt> und <tt>+</tt> und einer <tt>while</tt>-Schleife
kommen Sie mit sechs Zeilen im Rumpf der Methode aus. </aufgabe><aufgabe>Schreiben Sie eine Methode <tt>static int readIntBase10(String str)</tt>. Diese 
Methode soll einen String, der nur aus Ziffern besteht, in die von ihm repräsentierte Zahl umwandeln. Benutzen sie
hierzu die Methode <tt>charAt</tt> der <tt>String</tt>-Klasse, 
die es erlaubt, einzelne
Buchstaben einer Zeichenkette zu selektieren. </aufgabe></subsection><subsection titel = "die switch Anweisung">
Aus C erbt Java eine sehr spezielle zusammengesetzte Anweisung, 
die <b>switch</b>-Anweisung.
Es ist eine Anweisung für eine Fallunterscheidung mit
mehreren Fällen, die <tt>switch</tt>-Anweisung. Die Idee dieser
Anweisung ist, eine Kette von 
mehreren <tt>if</tt>-<tt>then</tt>-Anweisungen zu vermeiden. Leider ist 
die  <tt>switch</tt>-Anweisung in seiner Anwendungsbereite recht
begrenzt und in Form und Semantik ziemlich veraltet.<p/>
Schematisch hat die <tt>switch</tt>-Anweisung die folgende Form:<center>
          <fbox>
            <minipage dimension = "0.3\textwidth">
              <ttt>switch (</ttt>
              <em>expr</em>
              <ttt>)<lpar/></ttt>
              <br/>
              <indent/>
              <ttt>  case </ttt>
              <em>const</em>
              <ttt>: </ttt>
              <em>stats</em>
              <br/>
              <indent/>
              <indent/>
              <ttt/>
              <dots/>
              <br/>
              <indent/>
              <ttt>  case </ttt>
              <em>const</em>
              <ttt>: </ttt>
              <em>stats</em>
              <br/>
              <indent/>
              <ttt>  default: </ttt>
              <em>stats</em>
              <br/>
              <indent/>
              <ttt>  case </ttt>
              <em>const</em>
              <ttt>: </ttt>
              <em>stats</em>
              <br/>
              <indent/>
              <indent/>
              <ttt/>
              <dots/>
              <br/>
              <indent/>
              <ttt>  case </ttt>
              <em>const</em>
              <ttt>: </ttt>
              <em>stats</em>
              <br/>
              <ttt>
                <rpar/>
              </ttt>
            </minipage>
          </fbox>
        </center>

Dem Schlüsselwort <tt>switch</tt> folgt ein Ausdruck, nach dessen Wert
eine Fallunterscheidung getroffen werden soll. In geshweiften Klammern
folgen die verschiedenen Fälle. Ein Fall beginnt mit dem 
Schüsselwort <tt>case</tt> gefolgt von einer Konstante. Diese
Konstante ist von einem ganzzahligen Typ und darf kein Ausdruck sein,
der erst während der Laufzeit berechnet wird. Es muß hier eine Zahl
stehen. Die Konstante muß während der Übersetzungszeit des Programms
feststehen. Der Konstante folgt ein Doppelpunkt, dem dann die
Anweisungen für diesen Fall folgen.<p/>
Ein besonderer Fall ist der <tt>default</tt>-Fall. Dieses ist der
Standardfall. Er wird immer ausgeführt, egal was für einen Wert der
Ausdruck nach dem die <tt>switch</tt>-Anweisung unterscheidet hat.<example>
Ein kleines Beispiel soll die operationale Semantik dieser Anweisung
verdeutlichen. <code class = "Switch"
                lang = "java">class Switch {

  public static void main (String [] args){
    switch (4*new Integer(args[0]).intValue()){
      case 42 : System.out.println(42);
      case 52 : System.out.println(52);
      case 32 : System.out.println(32);
      case 22 : System.out.println(22);
      case 12 : System.out.println(12);
      default : System.out.println(&quot;default&quot;);
    }
  }
}</code>
Starten wir das Programm mit dem Wert <tt>13</tt>, so daß der
    Ausdruck, nach dem wir die Fallunterscheidung durchführen 
zu <tt>52</tt> auswertet, so bekommen wir folgende Ausgabe:<scode>sep@swe10:~/fh/internal/beispiele&gt; java Switch 13
52
32
22
12
default
sep@swe10:~/fh/internal/beispiele&gt;
</scode>
Wie man sieht, springt die <tt>switch</tt>-Anweisung zum Fall für den
Wert <tt>52</tt>, führt aber nicht nur dessen Anweisungen aus, sondern
alle folgenden Anweisungen.</example>

Das oben beobachtete Verhalten ist verwirrend. Zumeist will man in
einer Fallunterscheidung, daß nur die entsprechenden Anweisung für den
vorliegenden Fall ausgeführt werden und nicht auch für alle folgenden
Fälle. Um dieses zu erreichen, gibt es die <tt>break</tt>-Anweisung,
wie wir sie auch schon von den Schleifenanweisungen kennen. Endet man
jeden Fall mit der <tt>break</tt>-Anweisung, dann erhälz man das
meistens erwünschte Verhalten.<example>
Das obige Beispiel läßt sich durch Hinzufügen 
der <tt>break</tt>-Anweisung so ändern, daß immer nur ein Fall
ausgeführt wird.<code>class Switch2 {

  public static void main (String [] args){
    switch (4*new Integer(args[0]).intValue()){
      case 42 : System.out.println(42);break;
      case 52 : System.out.println(52);break;
      case 32 : System.out.println(32);break;
      case 22 : System.out.println(22);break;
      case 12 : System.out.println(12);break;
      default : System.out.println(&quot;default&quot;);
    }
  }
}</code>
An der Ausgabe sehen wir, daß zu einem Fall gesprungen wird und am
    Ende dieses Falls die Anweisung verlassen wird. <scode>sep@swe10:~/fh/internal/beispiele&gt; java Switch2 13
52
sep@swe10:~/fh/internal/beispiele&gt;</scode></example></subsection><subsection titel = "Rekursion und Iteration">
Wir kennen zwei Möglichkeiten, um einen Programmteil wiederholt
auszuführen: Iteration und Rekursion. Während die Rekursion kein
zusätzliches syntaktisches Konstrukt benötigt, sondern lediglich auf
den Aufruf einer Methode in ihrem eigenen Rumpf beruht, benötigte die
Iteration spezielle syntaktische Konstrukte, die wir lernen mußten.<p/> Javas virtuelle Maschine ist nicht darauf ausgerichtet, Programme mit
hoher Rekursionstiefe auszuführen. Für jeden Methodenaufruf fordert
Java intern einen bestimmten Speicherbereich an, der erst wieder
freigegeben wird, wenn die Methode vollständig beendet wurde. 
Dieser Speicherbereich wird als der <em>stack</em> bezeichnet.
Er kann relativ schnell ausgehen. Javas Maschine hat keinen Mechanismus, um zu erkennen, wann dieser Speicher für den Methodenaufruf
eingespart werden kann. <p/>
Folgendes Programm illustriert, wie für eine Iteration über viele
Schleifendurchläufe gerechnet werden kann, die Rekursion hingegen zu
einen Programmabbruch führt, weil nicht genug Speicherplatz auf 
dem <em>stack</em> vorhanden ist.<code class = "StackTest"
              lang = "java">class StackTest {
  public static void main(String [] args){
    System.out.println(count1(0));
    System.out.println(count2(0));
  }

  public static int count1(int k){
    int j = 2;
    for (int i= 0;i&lt;1000000000;i=i+1){
      j=j+1;
    }  
    return j;
  }

  public static int count2(int i){
      if (i&lt;1000000000) return count2(i+1) +1; else return 2;
  }

}
</code></subsection></section><section titel = "Ausdrücke und Befehle">
Wir kennen mitlerweile eine große Anzahl mächtiger Konstrukte
Javas. Dem aufmerksamen Leser wird aufgefallen sein, daß sich diese
Konstrukte in zwei große Gruppen einteilen lassen: Ausdrücke 
und Befehle<footnote>In der Literatur findet man mitunter auch den
Ausdruck <em>Anweisung</em> für das, was wir als Befehl
bezeichnen. <em>Befehl</em> bezeichnet dann den Oberbegriff für
Anweisungen und 
Ausdrücke.</footnote> (englisch: <em>expressions</em> und <em>statements</em>).<p/>
Ausdrücke berechnen direkt einen Objekt oder ein Datum eines primitiven Typs. Ausdrücke haben also immer einen Wert. Befehle hingegen sind Konstrukte, die Felder verändern oder Ausgaben auf dem
Bildschirm erzeugen.<p/><table layout = "l|l">
        <zeile>
          <zelle>
            <b>Ausdrücke</b>
          </zelle>
          <zelle>
            <b>Befehle</b>
          </zelle>
        </zeile>
        <hline/>
        <hline/>
        <zeile>
          <zelle>Literale: <tt>1, &quot;fgj&quot;</tt></zelle>
          <zelle>Zuweisung: <tt>x=1;</tt></zelle>
        </zeile>
        <hline/>
        <zeile>
          <zelle>Operatorausdrücke: <tt>1*42</tt></zelle>
          <zelle>Felddeklaration: <tt>int i;</tt></zelle>
        </zeile>
        <hline/>
        <zeile>
          <zelle>Feldzugriffe: <tt>obj.myField</tt></zelle>
          <zelle>
            <minipage dimension = "0.45\textwidth">zusammengesetzte 
Befehle (if, while, for)</minipage>
          </zelle>
        </zeile>
        <hline/>
        <zeile>
          <zelle>
            <minipage dimension = "0.45\textwidth">Methodenaufrufe 
mit Methodenergebnis:<br/><tt>obj.toString()</tt></minipage>
          </zelle>
          <zelle>
            <minipage dimension = "0.45\textwidth">Methodenaufrufe 
ohne Methodenergebnis:<br/><tt>System.out.println(&quot;hallo&quot;)</tt></minipage>
          </zelle>
        </zeile>
        <hline/>
        <zeile>
          <zelle>
            <minipage dimension = "0.45\textwidth"> 
Erzeugung neuer
Objekte<br/><tt>new MyClass(56)</tt></minipage>
          </zelle>
          <zelle>
            <minipage dimension = "0.45\textwidth"> 
Ablaufsteuerungsbefehle 
wie<br/><tt>break, continue, return</tt></minipage>
          </zelle>
        </zeile>
        <hline/>
      </table><p/>
 
Ausdrücke können sich aus Unterausdrücken zusammensetzen. So hat ein
binärer Operatorausdruck zwei Unterausdrücke als Operanden. Hingegen
kann ein Ausdruck niemals einen Befehl enthalten.<p/>
Beispiele für Befehle, die Unterbefehle und Unterausdrücke enthalten,
haben wir bereits zu genüge gesehen. An bestimmten Stellen von
zusammengesetzten Befehle müssen Ausdrücke eines bestimmten Typs
stehen: so muß z.B.<white/>die Schleifenbedingung ein Ausdruck des 
Typs <tt>boolean</tt> sein.<subsection titel = "Bedingungen als Befehl oder als Ausdruck">
Die Bedingung kennen wir bisher nur als Befehl in Form  des <tt>if</tt>-Befehls. Java kennt auch einen Ausdruck, der eine
Unterscheidung auf Grund einer Bedingung macht. Dieser Ausdruck hat
drei Teile: die bool&#39;sche Bedingung und jeweils die positive und
negative Alternative. Syntaktisch wird die Bedingung durch ein Fragezeichen von den Alternativen und die Alternativen werden mit einem Doppelpunkt voneinander getrennt:<p/><center>
          <fbox>
            <em>pred</em>
            <ttt>?</ttt>
            <em>alt1</em>
            <ttt>:</ttt>
            <em>alt2</em>
          </fbox>
        </center><p/> Im Gegensatz zum <tt>if</tt>-Befehl, in dem die <tt>else</tt>-Klausel
fehlen kann, müssen im Bedingungsausdruck stets beide Alternativen
vorhanden sein (weil ja ein Ausdruck per Definition einen
Ergebniswert braucht). Die beiden Alternativen brauchen den gleichen
Typ. Dieser Typ ist der Typ des Gesamtausdrucks.<p/>
Folgender Code:<code class = "CondExpr"
              commandchars = "|~^"
              lang = "java">class CondExpr {
  public static void main(String [] _){
    System.out.println(true?1:2);
    System.out.println(false?3:4);
  }
}</code>
druckt erst die Zahl 1 und dann die Zahl 4.<scode>sep@linux:~/fh/prog1/examples/classes&gt; java CondExpr
1
4
sep@linux:~/fh/prog1/examples/classes&gt;</scode></subsection><subsection titel = "Auswertungsreihenfolge und Seiteneffekte von Ausdrücken">
Wir haben uns bisher wenig Gedanken darüber gemacht, in welcher
Reihenfolge  Unterausdrücke von der Javamaschine ausgewertet werden. Für Befehle war die Reihenfolge, in der sie von Java
abgearbeitet werden, intuitiv sehr naheliegend. Eine Folge von Befehlen
wird in der Reihenfolge ihres textuellen Auftretens abgearbeitet,
d.h. von links nach rechts und von oben nach unten. Zusammengesetze
Befehle wie Schleifen und Bedingungen geben darüberhinaus einen
expliziten Programmablauf vor.<p/>
Für Ausdrücke ist eine solche explizite Reihenfolge nicht unbedingt
ersichtlich. Primär interessiert das Ergebnis eines Ausdrucks, z.B.<white/>
für den Ausdruck <tt>(23-1)*(4-2)</tt> interessiert nur das Ergebnis   <tt>42</tt>. Es ist im Prinzip egal, ob erst <tt>23-1</tt> oder 
erst <tt>4-2</tt> gerechnet wird. Allerdings können Ausdrücke in Java
nicht nur einen Wert berechnen, sondern gleichzeitig auch noch
zusätzliche Befehle sozusagen unter der Hand ausführen. In diesem Fall
sprechen wir von Seiteneffekten. <subsubsection titel = "Reihenfolge der Operanden"> Wir können Seiteneffekte, die eine Ausgabe auf den Bildschirm drucken,
dazu nutzen, zu testen, in welcher Reihenfolge Unterausdrücke
ausgewertet werden. Hierzu schreiben wir eine Subtraktionsmethode mit einem derartigen Seiteneffekt:<code class = "Minus"
                lang = "java">class Minus {

  static public int sub(int x,int y){
    int erg = x-y;
    System.out.println(&quot;eine Subtraktion mit Ergebnis: &quot;
                       +erg+&quot; wurde durchgeführt.&quot;);
    return erg;
  }
}</code>

Obige Methode <tt>sub</tt> berechnet nicht nur die Differenz zweier
Zahlen und gibt diese als Ergebnis zurück, sondern zusätzlich druckt
sie das Ergebnis auch noch auf dem Bildschirm. Dieses Drucken ist bei
einem Audruck, der einen Aufruf der Methode <tt>sub</tt> enthält, ein
Seiteneffekt. Mit Hilfe solcher Seiteneffekte, die eine Ausgabe erzeugen,  können wir testen, wann ein Ausdruck ausgewertet wird:<code class = "Operatorauswertung"
                lang = "java">class Operatorauswertung {

   public static void main(String [] args){
     System.out.println(Minus.sub(23,1)*Minus.sub(4,2));
   }
}</code> 
Anhand dieses Testprogramms kann man erkennen, daß Java die Operanden
     eines Operatorausdrucks von links nach rechts auswertet:<scode>sep@swe10:~/fh/prog1/beispiele&gt; java Operatorauswertung 
eine Subtraktion mit Ergebnis: 22 wurde durchgeführt.
eine Subtraktion mit Ergebnis: 2 wurde durchgeführt.
44
sep@swe10:~/fh/prog1/beispiele&gt; </scode></subsubsection><subsubsection titel = "Auswertung der Methodenargumente">
Ebenso wie für die Operanden eines Operatorausdrucks müssen wir 
für die Argumente eines Methodenaufrufs untersuchen, ob, wann und in
welcher Reihenfolge diese ausgewertet werden. Hierzu schreiben wir
eine Methode, die eines ihrer Argumente ignoriert und das zweite als
Ergebnis zurückgibt:<code class = "Reihenfolge"
                lang = "java"
                commandchars = "?$^">public class Reihenfolge{

    /**
       Returns second argument.
       @param x ignored  argument.
       @param y returned argument.
       @return projection on second argument.
     **/
  public static int snd(int x,int y){return y;}
</code>
Desweiteren eine Methode, die einen Seiteneffekt hat und einen konstanten Wert zurückgibt:<code class = "Reihenfolge"
                sequel = "true"
                lang = "java"
                commandchars = "?$^">    /**
       Returns the constants 1 and prints its argument.  
       @param  str The String that is printed as side effect.
       @return constantly 1. 
    **/
  public static int eins(String str){
    System.out.println(str); return 1;
  }</code>
Damit läßt sich überprüfen, daß die Methode <tt>snd</tt> tatsächlich beide Argumente auswertet, und zwar auch von links nach rechts. Obwohl
ja streng genommen die Auswertung des ersten Arguments zum Berechnen des Ergebnisses nicht notwendig wäre:<code class = "Reihenfolge"
                lang = "java"
                sequel = "true">  public static void main(String [] args){
    //&lt;bluev&gt;test, in which order arguments are evaluated.&lt;/bluev&gt;
    snd(eins(&quot;a&quot;),eins(&quot;b&quot;));
}}</code></subsubsection><subsubsection titel = "Terminierung"> Spannender noch wird die Frage,  ob und wann die Argumente ausgewertet
werden  , wenn bestimmte Argumente nicht terminieren. Auch dieses
läßt sich experimentell untersuchen. Wir schreiben eine Methode, die
nie terminiert:<code class = "TerminationTest"
                commandchars = "?$^"
                lang = "java">class TerminationTest {
    /**
      Nonterminating method.
      @return never returns anything.
     **/
  public static int bottom( ){while(wahr()){};return 1; }

    /**
       Returns the constants 1 and prints its argument.  
       @param  str The String that is printed as side effect.
       @return constantly 1. 
    **/
  public static int eins(String str){
    System.out.println(str); return 1;
  }

    /**
       Constantly true method.
       @return constantly the value true.
    **/
  public static boolean wahr( ){return true; }</code> 
Den Bedingungsausdruck können wir für einen festen Typen der beiden
       Alternativen als Methode schreiben:<code class = "TerminationTest"
                commandchars = "|~^"
                sequel = "true"
                lang = "java">    /**
       Method mimicking conditional expression.
       @param pre The boolean condition.
       @param a1 The positive alternative.
       @param a2 The negative alternative.
       @return in case of pre the second otherwise third argument
     **/
  public static int wenn(boolean pre,int a1,int a2 ){
    return pre?a1:a2; }</code>
Ein Test kann uns leicht davon überzeugen, daß der Methodenaufruf mit
       dem entsprechenden Bedingungsausdruck im Terminierungsverhalten
       nicht äquivalent ist.<code class = "TerminationTest"
                commandchars = "|~^"
                sequel = "true"
                lang = "java">  public static void main(String [] args){

    //test, whether both alternatives of conditional
    //expression are evaluated or just one.

    //this will terminate:
    System.out.println(      false?bottom():eins(&quot;b&quot;)   );
    
    //this won&#39;t terminate:
    System.out.println(wenn( false,bottom(),eins(&quot;b&quot;) )  );
  }
}</code>
Man sieht also, daß eine äquivalente Methode zum Bedingungsausdruck in
    Java nicht geschrieben werden kann.<p/></subsubsection>
So natürlich uns die in diesem Abschnitt festgestellten
Auswertungsreihenfolgen von Java erscheinen, so sind sie doch nicht
selbstverständlich. Es gibt funktionale Programmiersprachen, die nicht
wie Java vor einem Methodenaufruf erst alle Argumente des Aufrufs auswerten. Diese Auswertungsstrategie wird dann 
als <em>nicht strikt</em> bezeichnet, während man die
Auswertungsstrategie von Java als <em>strikt</em> bezeichnet.</subsection><subsection titel = "Auswertung der bool&#39;schen Operatoren">
Wir haben die beiden zweistelligen Infixoperatoren für das 
logische <em>und</em><w/><tt>&amp;&amp;</tt> und das  logische <em>oder</em><w/><tt>||</tt> kennengelernt. Aus der formalen Logik ist
bekannt:<quote><m>true <or/> A = true</m> und <m>false <and/> A = false</m></quote>

In bestimmten Fällen läßt sich das Ergebnis einer bool&#39;schen Operation bereits
bestimmen, ohne den zweiten Operanden anzuschauen. Die Frage ist, ob auch Java in diesen Fällen sich zunächst den linken Operanden anschaut und
nur bei Bedarf noch den rechten Operanden betrachtet. Hierzu können wir ein
Testprogramm schreiben. Wir bedienen uns dabei wieder einer Methode, die nicht nur einen bool&#39;schen Wert als Ergebnis, sondern auch einen
Seiteneffekt in Form einer Ausgabe auf den Bildschirm hat: <code class = "LazyBool"
              lang = "java">class LazyBool {

  static boolean booleanExpr(){
    System.out.println(&quot;in booleanExpr&quot;);
    return true;
  }

  static public void main(String [] _){
    System.out.println(true || booleanExpr());
    System.out.println(false &amp;&amp; booleanExpr());
  }

}</code> An der Ausgabe dieses Programms läßt sich schließlich erkennen, ob Java   bei der Auswertung auch noch den rechten Operanden betrachtet , obwohl durch den
linken Operanden der Wert des Gesamtausdrucks bereits ermittelt werden kann:<scode>sep@linux:~/fh/prog1/examples/classes&gt; java LazyBool
true
false
sep@linux:~/fh/prog1/examples/classes&gt;</scode> 

Und tatsächlich bekommen wir keine Ausgabe aus der 
Methode <tt>booleanExpr</tt>. Java wertet also den linken Operanden in diesem
Fall nicht mehr aus. Die beiden bool&#39;schen Operatoren <tt>&amp;&amp;</tt> und <tt>||</tt> werden in Java nicht strikt ausgewertet.<subsubsection titel = "strikte bool&#39;sche Operatoren">
Zu den beiden logischen binären 
Operatoren <tt>&amp;&amp;</tt> und <tt>||</tt> gibt es zwei Versionen, in
denen das entsprechende Zeichen nicht doppelt 
steht: <tt>&amp;</tt> und <tt>|</tt>. Sie stehen auch für das 
logische <em>und</em> bzw.<white/><em>oder</em>. 
Die einfachen Versionen der bool&#39;schen Operatoren haben eine andere
Strategie, wie sie das Ergebnis berechnen. Sie werten zunächst beide
Operanden aus, um dann das Ergebnis aus deren Werten zu berechnen.<p/> Die Strategie, immer erst alle Operanden einer Operation
(entsprechend die Parameter eines Methodenaufrufs)  komplett anzuschauen und auszuwerten, nennt man <em>strikt</em>. Die gegenteilige Strategie, nur das Notwendigste von den Operanden auszuwerten, entsprechend nicht-strikt.<footnote>Kommt zur nicht-strikten
Strategie noch eine Strategie hinzu, die verhindert, daß Ausdrücke
doppelt ausgewertet werden, so spricht man von einer 
faulen <em>(lazy)</em> Auswertung.</footnote>

Wenn wir jetzt im obigen Testprogramm statt der nicht-strikten Operatoren die
beiden strikten Operatoren benutzen, beobachten wir den Seiteneffekt aus der Methode <tt>booleanExpr</tt>:<code class = "StrictBool"
                lang = "java">class StrictBool {

  static boolean booleanExpr(){
    System.out.println(&quot;in booleanExpr&quot;);
    return true;
  }

  static public void main(String [] _){
    System.out.println(true | booleanExpr());
    System.out.println(false &amp; booleanExpr());
  }

}</code> Und tatsächlich bekommen wir jetzt zusätzliche Ausgaben auf dem Bildschirm:<scode>sep@linux:~/fh/prog1/examples/classes&gt; java StrictBool
in booleanExpr
true
in booleanExpr
false
sep@linux:~/fh/prog1/examples/classes&gt;</scode></subsubsection><aufgabe><bf>Für die Lösung dieser Aufgabe gibt es 3 Punkte, die auf die
Klausur angerechnet werden. Voraussetzung hierzu ist, daß die Lösung
mir  in der Übung gezeigt und erklärt werden
kann. </bf><p/>
In dieser Aufgabe sollen Sie eine Klasse für römische Zahlen entwickeln. <unteraufgaben>
            <teil>Schreiben Sie eine Klasse <tt>Roman</tt>. Diese Klasse soll 
eine natürliche Zahl
darstellen. </teil>
            <teil>Schreiben Sie für Ihre Klasse <tt>Roman</tt> einen Konstruktor, der ein
Stringobjekt als Parameter hat. Dieser Stringparameter soll eine römische Zahl
darstellen. Der Konstruktor soll diese Zahl lesen und in einem Feld des 
Typs <tt>int</tt> abspeichern.</teil>
            <teil>Implementieren Sie die Methode <tt>public String toString()</tt> für
Ihre Klasse <tt>Roman</tt>, die die intern gespeicherte Zahl als römische Zahl
dargestellt zurückibt.</teil>
            <teil>Fügen Sie ihrer Klasse <tt>Roman</tt> die folgenden Methoden für
arithmetische Rechnungen hinzu.<itemize>
                <item>
                  <tt>Roman add(Roman other)</tt>
                </item>
                <item>
                  <tt>Roman sub(Roman other)</tt>
                </item>
                <item>
                  <tt>Roman mul(Roman other)</tt>
                </item>
                <item>
                  <tt>Roman div(Roman other)</tt>
                </item>
              </itemize></teil>
            <teil>Testen Sie Ihre Klasse <tt>Roman</tt>.</teil>
          </unteraufgaben></aufgabe></subsection></section><section titel = "Reihungen">
Java kennt, wie fast alle Programmiersprachen, ein weiteres Konzept von
Sammlungen: Reihungen (eng.<white/>arrays).<footnote>In der
deutschen Literatur findet man oft den Ausdruck <em>Datenfeld</em> für
Reihungen. Wir haben uns gegen diesen Ausdruck entschieden, um nicht
mit Feldern einer Klasse durcheinander zu kommen.</footnote> Reihungen
stellen im Gegensatz zu Listen oder Mengen eine Menge von Daten gleichen Typs mit fester Anzahl dar. Jedes Element einer Reihung hat einen festen Index, über den es direkt angesprochen werden kann.<subsection titel = "Deklaration von Reihungen">
Eine Reihung hat im Gegensatz zu den Sammlungsklassen<footnote>Dies
wird sich mit den generischen Typen ab Java<white/>1.5  ändern.</footnote> einen festen Elementtyp.<p/>
Ein Reihungstyps wird deklariert, indem dem Elementtyp ein eckiges
Klammernpaar nachgestellt wird, z.B. ist <ttt>String []</ttt> eine
Reihung von Stringelementen. Die Elemente einer Reihung können sowohl von einem Objekttyp als auch von einem primitiven Typ sein, also gibt es auch den Typ <ttt>int []</ttt> oder 
z.B.<white/><ttt>boolean []</ttt>.<p/>
Reihungen sind Objekte. Sie sind zuweisungskompatibel für
Objektfelder, es lassen sich Typzusicherungen auf Reihungen
durchführen und Reihungen haben ein Feld <tt>length</tt>vom  Typ <tt>int</tt>, das die feste Länge einer Reihung angibt.<code class = "ObjectArray"
              lang = "java">class ObjectArray {
  public static void main(String [] args){
    Object as = args;
    System.out.println(((String [])as).length);
  }
}</code></subsection><subsection titel = "Erzeugen von Reihungen">
Es gibt zwei Verfahren, um Reihungen zu erzeugen: indem die Elemente der Reihung aufgezählt werden oder indem die Länge der Reihung
angegeben wird. Eine Mischform, in der sowohl Länge als auch die
einzelnen Elemente angegeben werden, gibt es nicht.<subsubsection titel = "Aufzählung der Reihung">
Die einfachste Art, um eine Reihung zu erzeugen, ist, die Elemente
aufzuzählen. Hierzu sind die Elemente in geschweiften Klammern mit Komma getrennt aufzuzählen:<code class = "FirstArray"
                lang = "java">class FirstArray {

 static String [] komponisten
  = {&quot;carcassi&quot;,&quot;carulli&quot;,&quot;giuliani&quot;
    ,&quot;molino&quot;,&quot;monzino&quot;,&quot;paganini&quot;,&quot;sor&quot;};

  public static void main(String [] args){
    System.out.println(komponisten.length);
    System.out.println(komponisten.toString());
  }
}</code> Wie man beim Starten dieser kleinen Klasse erkennen kann, ist für
    Reihungen keine eigene Methode <tt>toString</tt> in Java
    implementiert worden.</subsubsection><subsubsection titel = "Uninitialisierte Reihungen">
Eine weitere Methode zur Erzeugung  von Reihungen ist, noch nicht die einzelnen Elemente der Reihung anzugeben, sondern nur die Anzahl der Elemente:<code class = "SecondArray"
                lang = "java">class SecondArray {

  static int [] zahlenReihung = new int[10];

  public static void main(String [] args){
    System.out.println(zahlenReihung);
  }
}</code></subsubsection></subsection><subsection titel = "Zugriff auf Elemente">
Die einzelnen Elemente einer Reihung können über einen Index
angesprochen werden. Das erste Element einer Reihung hat den 
Index <tt>0</tt>, das letzte Element den Index <tt>length-1</tt>. <p/>
Als Syntax benutzt Java die auch aus anderen Programmiersprachen bekannte Schreibweise mit eckigen Klammern: <code>String [] stra = {&quot;hallo&quot;,&quot;welt&quot;};
String str = stra[1];</code>
Typischer Weise wird mit einer <tt>for</tt>-Schleife über den Index
einer Reihung iteriert. So läßt sich z.B.<white/>eine Methode, die eine Stringdarstellung für Reihungen erzeugt, wie folgt schreiben:<code class = "ArrayToString"
              lang = "java">public class ArrayToString{
  static public String arrayToString(String [] obja){
    StringBuffer result = new StringBuffer(&quot;{&quot;);
    for (int i=0;i&lt;obja.length;i=i+1){
      if (i&gt;0) result.append(&quot;,&quot;);
      result.append(obja[i].toString());
    }
    result.append(&quot;}&quot;);
    return result.toString();
  }
}</code></subsection><subsection titel = "Ändern von Elementen"> Eine Reihung kann als ein Komplex von vielen einzelnen Feldern
gesehen werden. Die Felder haben keine eigenen Namen, sondern werden über den Namen der Reihung zusammen mit ihrem Index angesprochen. Mit
diesem Bild ergibt sich automatisch, wie nun einzelnen
Reihungselementen neue Objekte zugewiesen werden können:<code>String [] stra = {&quot;hello&quot;,&quot;world&quot;};
stra[0]=&quot;hallo&quot;;
stra[1]=&quot;welt&quot;;</code></subsection><subsection titel = "Das Kovarianzproblem">
Beim Entwurf von Java wurde in Bezug auf Reihungen eine
Entwurfsentscheidung getroffen, die zu Typfehlern während der Laufzeit
führen können.<p/>
Seien gegeben zwei Typen <tt>A</tt> und <tt>B</tt>, so daß 
gilt: <tt>B extends A</tt>. Dann können Objekte des 
Typs <tt>B []</tt> Feldern des Typs  <tt>A []</tt> zugewiesen werden. <p/>
Eine solche Zuweisung ist gefährlich.<footnote>Und daher in
generischen Klassen in Java<white/>1.5 nicht zulässig, 
sprich <ttt>List&lt;Object&gt;</ttt> darf z.B.~ kein Objekt des 
Typs <ttt>List&lt;String&gt;</ttt> zugewiesen werden.</footnote> Diese
Zuweisung führt dazu, daß Information verloren geht. Hierzu betrachte man folgendes kleine Beispiel:<code class = "Kovarianz"
              lang = "java">class Kovarianz {

  static String [] stra = {&quot;hallo&quot;,&quot;welt&quot;};

  //gefährliche Zuweisung  
  static Object [] obja = stra;

  public static void main(String [] args) {
    //dieses ändert auch stra. Laufzeitfehler!
    obja[0]=new Integer(42);     

    String str = stra[0];
    System.out.println(str);
  }
}</code>
Die Zuweisung <ttt>obja = stra;</ttt> führt dazu, 
daß <tt>stra</tt> und <tt>obja</tt> auf ein und dieselbe Reihung
    verweisen. Das Feld <tt>stra</tt> erwartet, daß 
nur <tt>String</tt>-Objekte in der Reihung sind, das 
Feld <tt>obja</tt> ist weniger streng und läßt Objekte beliebigen Typs
als Elemente der Reihung zu. Aus diesem Grund läßt der statische
Typcheck die Zuweisung <tt>obja[0]=new Integer(42);</tt> zu. In der
    Reihung, die über das Feld <tt>obja</tt> zugreift, wird ein Objekt
    des Typs <tt>Integer</tt> gespeichert. Der statische Typcheck läßt
    dieses zu, weil beliebige Elemente in dieser Reihung stehen
    dürfen. Erst bei der Ausführung der Klasse kommt es bei dieser
     Zuweisung zu einem Laufzeitfehler:<scode>sep@swe10:~/fh/beispiele&gt; java Kovarianz
Exception in thread &quot;main&quot; java.lang.ArrayStoreException
        at Kovarianz.main(Kovarianz.java:10)
</scode>
Die Zuweisung hat dazu geführt, daß in der Reihung des 
Feldes <tt>stra</tt> ein Element eingefügt wird, daß 
kein <tt>String</tt>-Objekt ist. Dieses führt zu 
obiger <tt>ArrayStoreException</tt>. Ansonsten würde der 
Reihungszugriff <tt>stra[0];</tt> in der nächsten Zeile 
kein <tt>String</tt>-Objekt ergeben.<p/> Dem Kovarianzproblem kann man entgehen, wenn man solche Zuweisungen
wie <tt>obja = stra;</tt> nicht durchführt, also nur Reihungen einander zuweist, die exakt ein und denselben Elementtyp haben. In
der virtuellen Maschine wird es trotzdem bei jeder Zuweisung auf ein
Reihungselement zu einen dynamischen Typcheck kommen, der zu Lasten
der Effizienz geht.<p/>
Die Entwurfsentscheidung, die zum Kovarianzproblem führt, ist nicht
vollkommen unmotiviert. Wäre die entsprechende Zuweisung, die zu
diesem Problem führt, nicht erlaubt, so ließe sich nicht die 
Methode <tt>ArrayToString.arrayToString</tt>  so schreiben, daß
sie für Reihungen mit beliebigen Elementtypen<footnote>Primitive Typen sind dabei ausgenommen.</footnote>  angewendet werden könnte.</subsection><subsection titel = "Weitere Methoden für Reihungen">
Im Paket <tt>java.util</tt> steht eine Klasse <tt>Arrays</tt> zur
Verfügung, die eine Vielzahl statischer Methoden zur Manipulation von
Reihungen  beinhaltet.<p/>
In der Klasse <tt>java.lang.System</tt> gibt es eine Methode <code>public static void arraycopy(Object src,
                             int srcPos,
                             Object dest,
                             int destPos,
                             int length)</code>
zum Kopieren bestimmter Reihungsabschnitte in eine zweite Reihung.</subsection><subsection titel = "Reihungen von Reihungen">
Da Reihungen ganz normale Objekttypen sind, lassen sich, ebenso 
wie es Listen von Listen geben kann, auch Reihungen von Reihungen
erzeugen. Es entstehen mehrdimensionale Räume. Hierzu ist nichts neues
zu lernen, sondern lediglich die bisher gelernte Technik von Reihungen
anwendbar. Angenommen, es gibt eine Klasse <tt>Schachfigur</tt>, die
die  14 verschiedenen Schachfiguren modelliert, dann läßt sich ein
Schachbrett wie folgt über eine zweidimensionale Reihenstruktur darstellen:<code class = "SchachFeld"
              lang = "java">class SchachFeld {
  Schachfigur [][] spielFeld
    =  {new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       ,new Schachfigur[8]
       };

  public void zug(int vonX,int vonY,int nachX,int nachY){
    spielFeld[nachX][nachY] = spielFeld[vonX][vonY];
    spielFeld[vonX][vonY] = null;
  }
}
class Schachfigur {}</code></subsection><subsection titel = "Iteration durch Reihungen">


Zum Iterieren über einen Zahlenbereich können wir eine entsprechende Klasse
vorsehen. <code class = "FromTo"
              package = "name/panitz/crempel/util"
              lang = "java">package name.panitz.crempel.util;

import java.util.Iterator;

public class FromTo implements Iterable&lt;Integer&gt;,Iterator&lt;Integer&gt;{
  private final int to; 
  private int from; 
  public FromTo(int f,int t){to=t;from=f;}
  public boolean hasNext(){return from&lt;=to;}
  public Integer next(){int result = from;from=from+1;return result;}
  public Iterator&lt;Integer&gt; iterator(){return this;}
  public void remove(){new UnsupportedOperationException();}
}</code></subsection><subsection titel = "Blubbersortierung">

Der Name <em>bubble sort</em> leitet sich davon
ab, daß Elemente wie die Luftblasen in einem Mineralwasserglass
innerhalb der Liste aufsteigen, wenn sie laut der Ordnung an ein
späteres Ende gehören. Ein vielleicht phonetisch auch ähnlicher
klingender deutscher Name wäre <em>Blubbersortierung</em>. Dieser Name
ist jedoch nicht in der deutschen Terminologie etabliert und es wird
in der Regel der englische Name genommen.<p/>
Die Idee des <em>bubble sort</em> ist, jeweils nur zwei benachbarte
Elemente einer Liste zu betrachten und diese gegebenenfalls in ihrer
Reihenfolge zu vertauschen. Eine Liste wird also von vorne bis hinten
durchlaufen, immer zwei benachbarte Elemente betrachtet und diese,
falls das vordere nicht kleiner ist als das hintere, getauscht. Wenn
die Liste in dieser Weise einmal durchgegangen wurde, ist sie entweder fertig sortiert oder muß in gleicher Weise nocheinmal durchgegangen werden, solange, bis keine Vertauschungen mehr vorzunehmen sind.<p/>
Die Liste <tt>(&quot;z&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;)</tt> wird durch  den <em>bubble sort</em>-Algorithmus in folgender Weise sortiert:<p/><b> 1. Bubble-Durchlauf</b><br/><tt>(&quot;z&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;)</tt><br/><tt>(&quot;b&quot;,&quot;z&quot;,&quot;c&quot;,&quot;a&quot;)</tt><br/><tt>(&quot;b&quot;,&quot;c&quot;,&quot;z&quot;,&quot;a&quot;)</tt><br/><tt>(&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;z&quot;)</tt><p/>
Das Element <tt>&quot;z&quot;</tt> ist in diesem Durchlauf an das Ende der Liste
geblubbert. <p/><b> 2. Bubble-Durchlauf</b><br/><tt>(&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;z&quot;)</tt><br/><tt>(&quot;b&quot;,&quot;a&quot;,&quot;c&quot;,&quot;z&quot;)</tt><p/> In diesem Durchlauf ist das Element <tt>&quot;c&quot;</tt> um einen Platz nach
hinten geblubbert.<p/><b> 3. Bubble-Durchlauf</b><br/><tt>(&quot;b&quot;,&quot;a&quot;,&quot;c&quot;,&quot;z&quot;)</tt><br/><tt>(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;z&quot;)</tt><p/> Im letzten Schritt ist das Element <tt>&quot;b&quot;</tt> auf seine endgültige
Stelle geblubbert.<p/>

Blubbersortierung läßt sich relativ leicht für Reihungen implementieren. Eine
Reihung ist dabei nur mehrfach zu durchlaufen und nebeneinanderstehende
Elemente sind eventuell in der Reihenfolge zu vertauschen. Dieses wird so
lange gemacht, bis keine Vertauschung mehr stattfindet.<code class = "BubbleSort"
              lang = "java">class BubbleSort {
  static void bubbleSort(Comparable [] obja){
    boolean toBubble = true;
    while (toBubble){ toBubble = bubble(obja);}
  }

  static boolean bubble(Comparable [] obja){
    boolean result = false;
    for (int i=0;i&lt;obja.length;i=i+1){
      try {
        if (obja[i].compareTo(obja[i+1])&gt;0){
          Comparable o = obja[i];
          obja[i]=obja[i+1];
          obja[i+1]=o;
          result=true;
        }
      }catch (ArrayIndexOutOfBoundsException _){}
    }
    return result;
  }  

  static public void main(String [] args){
    String [] stra = {&quot;a&quot;,&quot;zs&quot;,&quot;za&quot;,&quot;bb&quot;,&quot;aa&quot;,&quot;aa&quot;,&quot;y&quot;};
    System.out.println(ArrayToString.arrayToString(stra));
    bubbleSort(stra);
    System.out.println(ArrayToString.arrayToString(stra));
  }

}</code>
Die Umsetzung von <em>quicksort</em> auf Reihungen ist hingegen eine
schwierige und selbst für erfahrene Programmierer komplizierte Aufgabe.</subsection><aufgabe><b>(3 Punkte)</b><p/> In dieser Aufgabe soll ein Spielbrett für das Spiel Vier gewinnt
implementiert werden. Laden Sie hierzu die 
Datei<br/><link local = "prog1/"
              address = "load/vier.zip">vier.zip</link><unteraufgaben>
          <teil>Schreiben Sie eine Klasse <tt>VierImplementierung</tt>, die die
Schnittstelle <tt>VierLogik</tt> entsprechend der Dokumentation 
implementiert.</teil>
          <teil>Schreiben Sie folgende Hauptmethode und starten Sie diese. Sie sollten jetzt in der Lage sein, über die Eingabekonsole Vier
gewinnt zu spielen.<code>public static void main(String[] args) {
  new VierKonsole().spiel(new VierImplementierung());
}</code> Suchen Sie sich einen Spielpartner und versuchen Sie, gegen ihn zu gewinnen.</teil>
        </unteraufgaben></aufgabe></section><section titel = "Aufzählungstypen">
Häufig möchte man in einem Programm mit einer endlichen Menge von Werten
rechnen. Java bot bis Version 1.4 kein ausgezeichnetes Konstrukt an, um dieses
auszudrücken. Man war gezwungen in diesem Fall sich des 
Typs <tt>int</tt> zu bedienen und statische Konstanten dieses Typs zu 
deklarieren. Dieses sieht man auch häufig in Bibliotheken von Java
umgesetzt. Etwas mächtiger und weniger primitiv ist, eine Klasse zu schreiben,
in der es entsprechende Konstanten dieser Klasse gibt, die durchnummeriert
sind. Dieses ist ein Programmiermuster, das Aufzählungsmuster.<p/>

Mit Java 1.5 ist ein expliziter Aufzählungstyp in Java integriert
worden. Syntaktisch erscheint dieser wie eine Klasse, die statt des
Schlüsselworts <tt>class</tt> das Schlüsselwort <tt>enum</tt> hat. Es folgt als
erstes in diesen Aufzählungsklassen die Aufzählung der einzelnen Werte.<example>
Ein erster Aufzählungstyp für die Wochentage. <code class = "Wochentage"
              package = "name/panitz/enums"
              lang = "java">package name.panitz.enums;
public enum Wochentage {
  montag,dienstag,mittwoch,donnerstag
 ,freitag,sonnabend,sonntag;
}</code>

Auch dieses neue Konstrukt wird von Javaübersetzer in eine herkömmlige
Javaklasse übersetzt. Wir können uns davon überzeugen, indem wir uns einmal
den Inhalt der erzeugten Klassendatei mit <tt>javap</tt> wieder anzeigen
lassen: <scode>sep@linux:fh/&gt; javap name.panitz.enums.Wochentage
Compiled from &quot;Wochentage.java&quot;
public class name.panitz.enums.Wochentage extends java.lang.Enum{
    public static final name.panitz.enums.Wochentage montag;
    public static final name.panitz.enums.Wochentage dienstag;
    public static final name.panitz.enums.Wochentage mittwoch;
    public static final name.panitz.enums.Wochentage donnerstag;
    public static final name.panitz.enums.Wochentage freitag;
    public static final name.panitz.enums.Wochentage sonnabend;
    public static final name.panitz.enums.Wochentage sonntag;
    public static final name.panitz.enums.Wochentage[] values();
    public static name.panitz.enums.Wochentage valueOf(java.lang.String);
    public name.panitz.enums.Wochentage(java.lang.String, int);
    public int compareTo(java.lang.Enum);
    public int compareTo(java.lang.Object);
    static {};
}</scode></example>

Eine der schönen Eigenschaften der Aufzählungstypen ist, daß sie in 
einer <tt>switch</tt>-Anweisung benutzt werden können.<example>
Wir fügen der Aufzählungsklasse eine Methode zu, um zu testen ob der Tag ein
Werktag ist. Hierbei läßt sich eine <tt>switch</tt>-Anweisung benutzen.<code class = "Tage"
              package = "name/panitz/enums"
              lang = "java">package name.panitz.enums;
public enum Tage {
  montag,dienstag,mittwoch,donnerstag
 ,freitag,sonnabend,sonntag;

  public boolean isWerktag(){
    switch (this){
      case sonntag    :
      case sonnabend  :return false;
      default         :return true;
    }
  }

  public static void main(String [] _){
    Tage tag = freitag;
    System.out.println(tag);
    System.out.println(tag.ordinal());
    System.out.println(tag.isWerktag());
    System.out.println(sonntag.isWerktag());
  }
}</code>
Das Programm gibt die erwartete Ausgabe:<scode>sep@linux:~/fh/java1.5/examples&gt; java -classpath classes/ name.panitz.enums.Tage
freitag
4
true
false
sep@linux:~/fh/java1.5/examples&gt;</scode></example>

Eine angenehme Eigenschaft der Aufzählungsklassen ist, daß sie in einer
Reihung alle Werte der Aufzählung enthalten, so daß mit der 
neuen <tt>for</tt>-Schleife bequem über diese iteriert werden kann.<example>
Wir iterieren in diesem Beispiel einmal über alle Wochentage. <code class = "IterTage"
              package = "name/panitz/enums"
              lang = "java">package name.panitz.enums;
public class IterTage {
  public static void main(String [] _){
    for (Tage tag:Tage.values()) 
      System.out.println(tag.ordinal()+&quot;: &quot;+tag);
  }
}</code>
Die erwarttete Ausgabe ist:<scode>sep@linux:~/fh/java1.5/examples&gt; java -classpath classes/ name.panitz.enums.IterTage
0: montag
1: dienstag
2: mittwoch
3: donnerstag
4: freitag
5: sonnabend
6: sonntag
sep@linux:~/fh/java1.5/examples&gt;</scode></example>

Schließlich kann man den einzelnen Konstanten einer Aufzählung noch Werte
übergeben. <example>Wir schreiben eine Aufzählung für die Euroscheine. Jeder
Scheinkonstante wird noch eine ganze Zahl mit übergeben. Es muß hierfür ein
allgemeiner Konstruktor geschrieben werden, der diesen Parameter übergeben
bekommt. <code class = "Euroschein"
              package = "name/panitz/enums"
              lang = "java">package name.panitz.enums;
public enum Euroschein {
   fünf(5),zehn(10),zwanzig(20),fünfzig(50),hundert(100)
  ,zweihundert(200),tausend(1000);
  private int value;
  Euroschein(int v){value=v;}
  public int value(){return value();}

  public static void main(String [] _){
    for (Euroschein schein:Euroschein.values()) 
      System.out.println
        (schein.ordinal()+&quot;: &quot;+schein+&quot; -&gt; &quot;+schein.value);
  }
}</code>
Das Programm hat die folgende Ausgabe:<scode>sep@linux:~/fh/java1.5/examples&gt; java -classpath classes/ name.panitz.enums.Euroschein
0: fünf -&gt; 5
1: zehn -&gt; 10
2: zwanzig -&gt; 20
3: fünfzig -&gt; 50
4: hundert -&gt; 100
5: zweihundert -&gt; 200
6: tausend -&gt; 1000
sep@linux:~/fh/java1.5/examples&gt;</scode></example></section></kapitel>
  <kapitel titel = "Weiterführende Konzepte">
    <section titel = "Pakete">
Java bietet die Möglichkeit, Klassen in Paketen zu sammeln. Die Klassen
eines Paketes bilden zumeist eine funktional logische Einheit. Pakete
sind hierarchisch strukturiert, d.h.<white/>Pakete können Unterpakete haben.
Damit entsprechen Pakete Ordnern im Dateisystem. Pakete ermöglichen
verschiedene Klassen gleichen Namens, die 
unterschiedlichen Paketen zugeordnet sind.<subsection titel = "Paketdeklaration">
Zu Beginn einer Klassendefinition kann eine Paketzugehörigkeit für die
Klasse definiert werden. Dieses geschieht mit dem 
Schlüsselwort <tt>package</tt> gefolgt von dem gewünschten Paket. Die
Paketdeklaration schließt mit einem Semikolon. <p/>
Folgende Klasse definiert sie dem Paket <tt>testPackage</tt> zugehörig:<code lang = "java"
              class = "MyClass"
              package = "testPackage">package testPackage;
class MyClass {
}</code>

Unterpakete werden von Paketen mit Punkten abgetrennt. Folgende Klasse
wird dem Paket <tt>testPackages</tt> zugeordnet, das ein Unterpaket des  Pakets <tt>panitz</tt> ist, welches wiederum ein Unterpaket des 
Pakets <tt>name</tt> ist:<code lang = "java"
              class = "TestPaket"
              package = "name/panitz/testPackages">package name.panitz.testPackages;
class TestPaket {
  public static void main(String [] args){
    System.out.println(&quot;hello from package \&#39;testpackages\&#39;&quot;);
  }
}</code>

Paketnamen werden per Konvention in lateinischer Schrift immer mit Kleinbuchstaben als erstem Buchstaben geschrieben.<p/>
Wie man sieht, kann man eine weltweite Eindeutigkeit seiner Paketnamen
erreichen, wenn man die eigene Webadresse hierzu
benutzt.<footnote>Leider ist es in Deutschland weit verbreitet, einen
Bindestrich in Webadressen zu verwenden. Der Bindestrich ist leider eines der wenigen Zeichen, die Java in Klassen- und Paketnamen nicht
zuläßt.</footnote> Dabei wird die Webadresse rückwärts verwendet.<p/>
Paketname und Klassenname zusammen identifizieren eine Klasse
eindeutig. Jeder Programmierer schreibt sicherlich eine Vielzahl von
Klassen <tt>Test</tt>, es gibt aber in der Regel nur einen
Programmierer, der diese für das 
Paket <tt>name.panitz.testPackages</tt> schreibt. Paket- und
Klassenname zusammen durch einen Punkt getrennt werden
der <em>vollqualifizierte Name</em> der Klasse genannt, im obigen
Beispiel ist entsprechend der vollqualifizierte Name:<br/><tt>name.panitz.testPackages.Test</tt><p/>

Der Name einer Klasse ohne die Paketnennung heißt unqualifiziert. </subsection><subsection titel = "Übersetzen von Paketen"> Bei größeren Projekten ist es zu empfehlen, die Quelltexte der Javaklassen in
Dateien zu speichern, die im Dateisystem in einer Ordnerstruktur, die der Paketstruktur entspricht, liegen. Dieses ist allerdings nicht unbedingt
zwingend notwendig. Hingegen zwingend notwendig ist es, die erzeugten
Klassendateien in Ordnern entsprechend der Paketstruktur zu speichern. <p/>
Der Javainterpreter <tt>java</tt> sucht nach Klassen in den Ordnern
entsprechend ihrer Paketstruktur. <tt>java</tt> erwartet also, daß die
obige Klasse <tt>Test</tt> in einem Ordner <tt>testPackages</tt> steht, der
ein Unterordner des Ordners <tt>panitz</tt> ist, der ein Unterordner des
Ordners <tt>tfhberlin</tt> ist.<white/>usw. <tt>java</tt> sucht
diese Ordnerstruktur von einem oder mehreren Startordnern ausgehend.
Die Startordner werden in einer Umgebungsvariablen <tt>CLASSPATH</tt> des 
Betriebssystems und über den 
Kommandozeilenparameter <tt>-classpath</tt> festgelegt.<p/>
Der Javaübersetzer <tt>javac</tt> hat eine Option, mit der gesteuert wird, daß <tt>javac</tt> für seine <tt>.class</tt>-Dateien die
notwendige Ordnerstruktur erzeugt und die Klassen in die ihren Paketen entsprechenden Ordner schreibt. Die Option 
heißt <tt>-d</tt>.  Dem <tt>-d</tt> ist nachgestellt, von welchem Startordner aus die Paketordner erzeugt werden sollen. Memotechnisch steht
das <tt>-d</tt> für <em>destination</em>.<p/>
Wir können die obige Klasse z.B.<white/>übersetzen mit folgendem Befehl auf
der Kommandozeile:<br/><tt>javac -d . Test.java</tt><p/>

Damit wird ausgehend vom aktuellem Verzeichnis<footnote>Der Punkt steht in den
meisten Betriebssystemen für den aktuellen Ordner, in dem gerade ein Befehl
ausgeführt wird.</footnote> ein 
Ordner <tt>de</tt> mit Unterordner <tt>tfhberlin</tt> etc.<white/>erzeugt.</subsection><subsection titel = "Starten von Klassen in Paketen">
Um Klassen vom Javainterpreter zu starten, reicht es nicht, ihren Namen
anzugeben, sondern der vollqualifizierte Name ist anzugeben. Unsere
obige kleine Testklasse wird also wie folgt gestartet:<scode>sep@swe10:~/&gt; java name.panitz.testPackages.Test
hello from package &#39;testpackages&#39;
sep@swe10:~/&gt;</scode>
Jetzt erkennt man auch, warum dem Javainterpreter nicht die
Dateiendung <tt>.class</tt> mit angegeben wird. Der Punkt separiert
Paket- und Klassennamen.<p/>

Aufmerksame Leser werden bemerkt haben, daß der Punkt in Java durchaus
konsistent mit einer Bedeutung verwendet wird: hierzu lese man ihn 
als <em>&#39;enthält ein&#39;</em>. Der Ausdruck:<br/><tt>name.panitz.testPackages.Test.main(args)</tt><br/>
liest sich so als: das Paket <tt>de</tt> enthält ein 
Unterpaket <tt>tfhberlin</tt>, das ein 
Unterpaket <tt>panitz</tt> enthält, das ein 
Unterpaket <tt>testpackages</tt> enthält, das eine 
Klasse <tt>Test</tt> enthält, die eine Methode <tt>main</tt> enthält.</subsection><subsection titel = "Das Java Standardpaket">
Die mit Java mitgelieferten Klassen sind auch in Paketen gruppiert. Die
Standardklassen wie z.B.<white/><tt>String</tt> und <tt>System</tt> und
natürlich auch <tt>Object</tt> liegen im 
Java-Standardpaket <tt>java.lang</tt>. Java hat aber noch eine ganze
Reihe weitere Pakete, so z.B.<white/><tt>java.util</tt>, in dem sich
Listenklassen befinden, <tt>java.applet</tt>, in dem Klassen zur
Programmierung von Applets auf HTML-Seiten liegen,
oder <tt>java.io</tt>, welches Klassen für Eingaben und Ausgaben enthält.</subsection><subsection titel = "Benutzung von Klassen in anderen Paketen">
Um Klassen benutzen zu können, die in anderen Paketen liegen, müssen
diese eindeutig über ihr Paket identifiziert werden. Dieses kann
dadurch geschehen, daß die Klassen immer vollqualifiziert angegeben
werden. Im folgenden Beispiel benutzen wir die 
Standardklasse <tt>ArrayList</tt><footnote><ttt>ArrayList</ttt> ist eine
generische Klasse, ein Konzept, das wir erst in einem späteren Kapitel
kennenlernen werden.</footnote> aus dem Paket <tt>java.util</tt>.<code lang = "java"
              class = "TestArrayList"
              package = "name/panitz/utilTest">package name.panitz.utilTest;
class TestArrayList {
  public static void main(String [] args){
    java.util.ArrayList&lt;String&gt; xs = new java.util.ArrayList&lt;String&gt;();
    xs.add(&quot;friends&quot;);
    xs.add(&quot;romans&quot;);
    xs.add(&quot;countrymen&quot;);
    System.out.println(xs);
  }
}</code>

Wie man sieht, ist der Klassenname auch beim Aufruf des Konstruktors
vollqualifiziert anzugeben.</subsection><subsection titel = "Importieren von Paketen und Klassen">
        <subsubsection titel = "Importieren von Klassen">
Vollqualifizierte Namen können sehr lang werden.
Wenn Klassen, die in einem anderen Paket als die eigene Klasse liegen,
unqualifiziert benutzt werden sollen, dann kann dieses zuvor angegeben
werden. Dieses
geschieht zu Beginn einer Klasse in einer Importanweisung. Nur die
Klassen aus dem Standardpaket <tt>java.lang</tt> brauchen nicht
explizit durch eine Importanweisung bekannt gemacht zu werden.<p/>
Unsere Testklasse aus dem letzten Abschnitt kann mit Hilfe einer
Importanweisung so geschrieben werden, daß die 
Klasse <tt>ArrayList</tt> unqualifiziert<footnote>Aus historischen Gründen
wird in diesem Kapitel als Beispiel bereits mit den  generischen 
Klassen <ttt>ArrayList</ttt> und <ttt>Vector</ttt> ein Konzept benutzt, das
erst im nächsten Kapitel erklärt wird.</footnote> benutzt werden kann:<code lang = "java"
                class = "TestImport"
                package = "name/panitz/utilTest">package name.panitz.utilTest;

import java.util.ArrayList;

class TestImport {
  public static void main(String [] args){
    ArrayList&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add(&quot;friends&quot;);
    xs.add(&quot;romans&quot;);
    xs.add(&quot;countrymen&quot;);
    System.out.println(xs);
  }
}</code>
Es können mehrere Importanweisungen in einer Klasse stehen.  So können
  wir z.B. zusätzlich die Klasse <tt>Vector</tt> importieren:<code lang = "java"
                class = "TestImport2"
                package = "name/panitz/utilTest">package name.panitz.utilTest;

import java.util.ArrayList;
import java.util.Vector;

class TestImport2 {
  public static void main(String [] args){
    ArrayList&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add(&quot;friends&quot;);
    xs.add(&quot;romans&quot;);
    xs.add(&quot;countrymen&quot;);
    System.out.println(xs);

    Vector&lt;String&gt; ys = new Vector&lt;String&gt;();
    ys.add(&quot;friends&quot;);
    ys.add(&quot;romans&quot;);
    ys.add(&quot;countrymen&quot;);
    System.out.println(ys);
  }
}</code></subsubsection>
        <subsubsection titel = "Importieren von Paketen">
Wenn in einem Programm viele Klassen eines Paketes benutzt werden, so
können mit einer Importanweisung auch alle Klassen dieses Paketes
importiert werden. Hierzu gibt man in der Importanweisung einfach
statt des Klassennamens ein <tt>*</tt> an.<code lang = "java"
                class = "TestImport3"
                package = "name/panitz/utilTest">package name.panitz.utilTest;

import java.util.*;

class TestImport3 {
  public static void main(String [] args){
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add(&quot;friends&quot;);
    System.out.println(xs);

    Vector&lt;String&gt; ys = new Vector&lt;String&gt;();
    ys.add(&quot;romans&quot;);
    System.out.println(ys);
  }
}</code>
Ebenso wie mehrere Klassen können auch mehrere komplette Pakete
    importiert werden. Es können auch gemischt einzelne Klassen und
    ganze Pakete importiert werden. </subsubsection>
      </subsection><subsection titel = "Statische Imports">
Statische Eigenschaften einer Klasse werden in Java dadurch angesprochen, daß
dem Namen der Klasse mit Punkt getrennt die gewünschte Eigenschaft folgt. 
Werden in einer Klasse sehr oft statische Eigenschaften einer anderen Klasse
benutzt, so ist der Code mit deren Klassennamen durchsetzt. Die Javaentwickler
haben mit Java 1.5 ein Einsehen. Man kann jetzt für eine Klasse alle ihre
statischen Eigenschaften importieren, so daß diese unqualifiziert benutzt
werden kann. Die <tt>import</tt>-Anweisung sieht aus wie ein gewohntes
Paktimport, nur daß das Schlüsselwort <tt>static</tt> eingefügt ist und erst
dem klassennamen der Stern folgt, der in diesen Fall für alle statischen
Eigenschaften steht. <example>Wir schreiben eine Hilfsklasse zum Arbeiten mit Strings, in der wir
eine Methode zum umdrehen eines Strings vorsehen:<code class = "StringUtil"
                package = "name/panitz/staticImport"
                lang = "java">package name.panitz.staticImport;
public class StringUtil {
  static public String reverse(String arg) {
    StringBuffer result = new StringBuffer();
    for (char c:arg.toCharArray()) result.insert(0,c);
    return result.toString();
  }
}</code>
Die Methode <tt>reverse</tt> wollen wir in einer anderen Klasse
benutzen. Importieren wir  die statischen Eigenschaften 
von <tt>StringUtil</tt>, so können wir auf die Qualifizierung des Namens der
Methode <tt>reverse</tt> verzichten:<code class = "UseStringUtil"
                package = "name/panitz/staticImport"
                lang = "java">package name.panitz.staticImport;
import static name.panitz.staticImport.StringUtil.*;
public class UseStringUtil {
  static public void main(String [] args) {
    for (String arg:args) 
     System.out.println(reverse(arg));
  }
}</code>

Die Ausgabe dieses programms:<scode>sep@linux:fh&gt; java -classpath classes/ name.panitz.staticImport.UseStringUtil hallo welt
ollah
tlew
sep@linux:~/fh/java1.5/examples&gt;</scode></example></subsection></section>
    <section titel = "Sichtbarkeitsattribute">
Sichtbarkeiten<footnote>Man findet in der Literatur auch den Ausdruck<em>Erreichbarkeiten</em>.</footnote> erlauben es, zu kontrollieren,
wer auf Klassen und ihre Eigenschaften zugreifen kann. 
Das <em>wer</em> bezieht sich hierbei auf andere Klassen und Pakete.<subsection titel = "Sichtbarkeitsattribute für Klassen">
Für Klassen gibt es zwei Möglichkeiten der Sichtbarkeit. Entweder darf von überall aus eine Klasse benutzt werden oder nur von Klassen im gleichen Paket. Syntaktisch wird dieses dadurch ausgedrückt, daß der
Klassendefinition entweder das Schlüsselwort <tt>public</tt> vorangestellt ist oder aber kein solches Attribut voransteht:<code lang = "java"
              class = "MyPublicClass"
              package = "name/panitz/p1">package name.panitz.p1;
public class MyPublicClass {
}</code><code lang = "java"
              class = "MyNonPublicClass"
              package = "name/panitz/p1">package name.panitz.p1;
class MyNonPublicClass {
}</code> In einem anderen Paket dürfen wir nur die als öffentlich deklarierte
Klasse benutzen. Folgende Klasse übersetzt fehlerfrei:<code lang = "java"
              class = "UsePublic"
              package = "name/panitz/p2">package name.panitz.p2;

import name.panitz.p1.*;

class UsePublic {
  public static void main(String [] args){
    System.out.println(new MyPublicClass());
  }
}</code> Der Versuch, eine nicht öffentliche Klasse aus einem anderen Paket heraus zu benutzen, gibt hingegen einen Übersetzungsfehler: <code lang = "java"
              classError = "UseNonPublic"
              package = "name/panitz/p2">package name.panitz.p2;

import name.panitz.p1.*;

class UseNonPublic {
  public static void main(String [] args){
    System.out.println(new MyNonPublicClass());
  }
}</code>
Java gibt bei der Übersetzung eine entsprechende gut verständliche
Fehlermeldung: <scode>sep@swe10:~&gt; javac -d . UseNonPublic.java
UseNonPublic.java:7: name.panitz.p1.MyNonPublicClass is not
public in name.panitz.pantitz.p1; 
cannot be accessed from outside package
        System.out.println(new MyNonPublicClass());
                               ^
UseNonPublic.java:7: MyNonPublicClass() is not 
public in name.panitz.p1.MyNonPublicClass; 
cannot be accessed from outside package
        System.out.println(new MyNonPublicClass());
                           ^
2 errors
sep@swe10:~&gt;</scode>

Damit stellt Java eine Technik zur Verfügung, die es erlaubt,
bestimmte Klassen eines Softwarepaketes als rein interne Klassen zu
schreiben, die von außerhalb des Pakets nicht benutzt werden können.</subsection><subsection titel = "Sichtbarkeitsattribute für Eigenschaften">
Java stellt in Punkto Sichtbarkeiten eine noch feinere Granularität
zur Verfügung. Es können nicht nur ganze Klassen als nicht-öffentlich
deklariert, sondern für einzelne Eigenschaften von Klassen
unterschiedliche Sichtbarkeiten deklariert werden. <p/>
Für Eigenschaften gibt es vier verschiedene Sichtbarkeiten:<br/><tt>public</tt>, <tt>protected</tt>, kein Attribut, <tt>private</tt><p/> Sichbarkeiten hängen zum einem von den Paketen ab, in denen sich die
Klassen befinden, darüberhinaus unterscheiden sich Sichtbarkeiten auch
darin, ob Klassen Unterklassen voneinander sind. Folgende Tabelle gibt
eine Übersicht über die vier verschiedenen Sichtbarkeiten:<p/><center>
          <table layout = "|p{0.2\textwidth}|p{0.7\textwidth}|"><hline/><zeile>
              <zelle>Attribut</zelle>
              <zelle>Sichtbarkeit</zelle>
            </zeile><hline/> <zeile>
              <zelle>
                <tt>public</tt>
              </zelle>
              <zelle>Die Eigenschaft darf von jeder Klasse aus
benutzt werden. </zelle>
            </zeile><hline/><zeile>
              <zelle>
                <tt>protected</tt>
              </zelle>
              <zelle> Die Eigenschaft darf für jede Unterklasse und jede Klasse im gleichen Paket 
benutzt werden. </zelle>
            </zeile><hline/><zeile>
              <zelle>kein Attribut</zelle>
              <zelle>Die Eigenschaft darf nur von  Klassen im gleichen Paket benutzt werden. </zelle>
            </zeile><hline/><zeile>
              <zelle>
                <tt>private</tt>
              </zelle>
              <zelle>Die Eigenschaft darf nur von  der Klasse, in der sie definiert ist, benutzt werden.</zelle>
            </zeile><hline/></table>
        </center><p/>

Damit kann in einer Klasse auf Eigenschaften mit jeder dieser vier
Sichtbarkeiten zugegriffen werden. Wir können die Fälle einmal systematisch
durchprobieren. In einer öffentlichen Klasse eines 
Pakets <tt>p1</tt> definieren wir hierzu vier Felder mit den vier
unterschiedlichen Sichtbarkeiten: <code lang = "java"
              class = "VisibilityOfFeatures"
              package = "name/panitz/p1">package name.panitz.p1;

public class VisibilityOfFeatures{
  private   String s1 = &quot;private&quot;;
            String s2 = &quot;package&quot;;
  protected String s3 = &quot;protected&quot;;
  public    String s4 = &quot;private&quot;;

  public static void main(String [] args){
    VisibilityOfFeatures v = new VisibilityOfFeatures();
    System.out.println(v.s1);
    System.out.println(v.s2);
    System.out.println(v.s3);
    System.out.println(v.s4);
  }
}</code>

In der Klasse selbst können wir auf alle vier Felder zugreifen.<p/> In einer anderen Klasse, die im gleichen Paket ist, können private
Eigenschaften nicht mehr benutzt werden:<code lang = "java"
              class = "PrivateTest"
              package = "name/panitz/p1">package name.panitz.p1;

public class PrivateTest 
{

  public static void main(String [] args){
    VisibilityOfFeatures v = new VisibilityOfFeatures();
    //s1 is private and cannot be accessed; 
    //we are in a  different class.
    //System.out.println(v.s1);
    System.out.println(v.s2);
    System.out.println(v.s3);
    System.out.println(v.s4);
  }
}</code>

Von einer Unterklasse können unabhängig von ihrem Paket 
die <em>geschützten</em>  Eigenschaften benutzt werden. Ist die Unterklasse in einem anderen Paket, können Eigenschaften mit der Sichtbarkeit <tt>package</tt> nict mehr benutzt werden:<code lang = "java"
              class = "PackageTest"
              package = "name/panitz/p2">package name.panitz.p2;
import name.panitz.p1.VisibilityOfFeatures;

public class  PackageTest extends VisibilityOfFeatures{

  public static void main(String [] args){
    PackageTest v = new PackageTest();
    //s1 is private and cannot be accessed
    // System.out.println(v.s1);

    //s2 is package visible and cannot be accessed;
    //we are in a different package.
    //System.out.println(v.s2);

    System.out.println(v.s3);
    System.out.println(v.s4);
  }
}</code> Von einer Klasse, die weder im gleichen Paket noch eine Unterklasse ist, können nur noch öffentliche Eigenschaften benutzt werden:<code lang = "java"
              class = "ProtectedTest"
              package = "name/panitz/p2">package name.panitz.p2;
import name.panitz.p1.VisibilityOfFeatures;

public class ProtectedTest  {

  public static void main(String [] args){
    VisibilityOfFeatures v = new VisibilityOfFeatures();
    //s1 is private and cannot be accessed
    // System.out.println(v.s1);
    
    //s2 is package visible and cannot be accessed. We are
    //in a different package
    //System.out.println(v.s2);

    //s2 is protected and cannot be accessed. 
    //We are not a subclass
    //System.out.println(v.s3);

    System.out.println(v.s4);
  }
}</code> Java wird in seinem Sichtbarkeitskonzept oft kritisiert, und das von
zwei Seiten. Einerseits ist es mit den vier Sichtbarkeiten schon
relativ unübersichtlich; die verschiedenen Konzepte der Vererbung und
der Pakete spielen bei Sichtbarkeiten eine Rolle. Andererseits ist es
nicht vollständig genug und kann verschiedene denkbare Sichtbarkeiten
nicht ausdrücken.<p/>
In der Praxis fällt die Entscheidung zwischen privaten und
öffentlichen Eigenschaften leicht. Geschützte Eigenschaften sind
hingegen selten. Das Gros der Eigenschaften hat die Standardsichtbarkeit der Paketsichtbarkeit.</subsection><subsection titel = "Private Felder mit get- und set-Methoden"> Der direkte Feldzufriff ist in bestimmten Anwendungen nicht immer
wünschenswert, so z.B. wenn ein Javaprogramm verteilt auf mehreren Rechner
ausgeführt wird oder wenn der Wert eines Feldes in einer Datenbank
abgespeichert liegt. Dann ist es sinnvoll, den Zugriff auf ein Feld durch zwei
Methoden zu kapseln: eine Methode, um den Wert des Feldes abzufragen, und eine
Methode, um das Feld mit einem neuen Wert zu belegen. Solche Methoden heißen
get- bzw.<w/>set-Methoden. Um technisch zu verhindern, daß direkt auf das Feld
zugegriffen wird, wird das Feld hierzu als <em>private</em> attributiert und
nur die get- und set-Methoden werden als öffentlich attributiert. Dabei ist
die gängige Namenskonvention, daß zu einem Feld mit Namen <tt>name</tt> die
get- und set-Methoden <tt>getName</tt> bzw.<w/><tt>setName</tt> heißen.<example>Eine kleine Klasse mit Kapselung eines privaten Feldes:<code lang = "java"
                classError = "GetSetMethods">package name.panitz.sep.skript;

public class GetSetMethod {
  private int value=0;

  public void setValue(int newValue) {value=newValue;}
  public int  getvalue(){return value;} 
}</code></example></subsection><subsection titel = "Überschriebene Methodensichtbarkeiten"> Beim Überschreiben einer Methode darf ihr Sichtbarkeitsattribut nicht enger
gemacht werden. Man darf also eine öffentliche Methode aus der Oberklasse
nicht mit einer privaten, geschützten oder paketsichtbaren Methode überschreiben. Der Javaübersetzer weist solche Versuche, eine Methode zu überschreiben, zurück:<code lang = "java"
              classError = "OverrideToString">class OverrideToString {
  String toString(){return &quot;Objekt der Klasse OverrideToString&quot;;}
}</code> Der Versuch, diese Klasse zu übersetzen, führt zu folgender Fehlermeldung:<scode>ep@linux:~/fh/prog1/examples/src&gt; javac OverrideToString.java
OverrideToString.java:2: 
toString() in OverrideToString cannot override toString() in java.lang.Object; 
attempting to assign weaker access privileges; 
was public
  String toString(){return &quot;Objekt der Klasse OverrideToString&quot;;}
         ^
1 error
sep@linux:~/fh/prog1/examples/src&gt;</scode>

Die Oberklasse <tt>Object</tt> enthält eine öffentliche 
Methode <tt>toString</tt>. Wollen wir diese Methode überschreiben, muß sie mindestens so sichtbar sein wie in der Oberklassen.</subsection></section>
    <section titel = "Schnittstellen (Interfaces) und abstrakte Klassen">
Wir haben schon Situationen kennengelernt, in denen wir eine Klasse
geschrieben haben, von der nie ein Objekt konstruiert werden sollte,
sondern für die wir nur Unterklassen definiert und instanziiert
haben. 
Die Methoden in
diesen Klassen hatten eine möglichst einfache Implementierung; sie
sollten ja nie benutzt werden, sondern die überschreibenden Methoden
in den Unterklassen. Ein Beispiel für eine solche Klassen war die
Klasse <tt>ButtonLogic</tt>, mit der die Funktionalität eines GUIs
definiert wurde.<p/>
Java bietet ein weiteres Konzept an, mit dem Methoden ohne eigentliche
Implementierung deklariert werden können, die Schnittstellen.<subsection titel = "Schnittstellen"><subsubsection titel = "Schnittstellendeklaration">
Eine Schnittstelle sieht  einer Klasse sehr ähnlich. Die
syntaktischen Unterschiede sind: <itemize>
            <item>statt des Schlüsselworts <tt>class</tt> steht das 
Schlüsselwort <tt>interface</tt>.</item>
            <item>die Methoden haben keine Rümpfe, sondern nur eine Signatur.</item>
          </itemize>

So läßt sich für unsere Klasse <tt>ButtonLogic</tt> eine
entsprechende Schnittstelle schreiben:<code lang = "java"
                class = "DialogueLogic"
                package = "name/panitz/dialoguegui">package name.panitz.dialoguegui;

public <redv>interface</redv> DialogueLogic {
  public String getDescription();
  public String eval(String input);
}</code>

Schnittstellen sind ebenso wie Klassen mit dem Javaübersetzer zu
übersetzen. Für Schnittstellen werden auch Klassendateien mit der
Endung <tt>.class</tt> erzeugt.<p/>
Im Gegensatz zu Klassen haben Schnittstellen keinen Konstruktor. Das
bedeutet insbesondere, daß mit einer Schnittstelle kein Objekt erzeugt
werden kann. Was hätte ein solches Objekt auch für ein Verhalten? Die
Methoden haben ja gar keinen Code, den sie ausführen könnten. 
Eine Schnittstelle ist vielmehr ein Versprechen, daß Objekte Methoden
mit den in der Schnittstelle definierten Signaturen enthalten. Objekte
können aber immer nur über Klassen erzeugt werden.</subsubsection><subsubsection titel = "Implementierung von Schnittstellen">
Objekte, die die Funktionalität einer Schnittstelle enthalten, können
nur mit Klassen erzeugt werden, die diese Schnittstelle implementieren.
Hierzu gibt es zusätzlich zur <tt>extends</tt>-Klausel in Klassen auch noch die Möglichkeit, eine <tt>implements</tt>-Klausel anzugeben.<todo>implements vs extends erklärem</todo><p/>
Eine mögliche Implementierung der obigen Schnittstelle ist:<code lang = "java"
                class = "ToUpperCase"
                package = "name/panitz/dialoguegui">package name.panitz.dialoguegui;

public class ToUpperCase <redv>implements DialogueLogic</redv>{
  protected String result;

  public String getDescription(){
    return &quot;convert into upper cases&quot;;
  }
  public String eval(String input){
    result = input.toUpperCase();
    return result;
  }
}</code>

Die Klausel <tt>implements DialogueLogic</tt> verspricht, daß in
dieser Klasse für alle Methoden aus der Schnittstelle eine
Implementierung existiert. In unserem Beispiel waren zwei
Methoden zu implementieren, die 
Methode <tt>eval</tt> und <tt>getDescription()</tt>.<p/>
Im Gegensatz zur <tt>extends</tt>-Klausel von Klassen können in 
einer <tt>implements</tt>-Klausel auch mehrere Schnittstellen
angegeben werden, die implementiert werden. <p/>
Definieren wir zum Beispiel ein zweite Schnittstelle:<code lang = "java"
                class = "ToHTMLString"
                package = "name/panitz/html">package name.panitz.html;

public interface ToHTMLString {
  public String toHTMLString();
}</code>  

Diese Schnittstelle verlangt, daß implementierende Klassen eine
Methode haben, die für das Objekt eine Darstellung als HTML erzeugen
können.  <p/>
Jetzt können wir eine Klasse schreiben, die die beiden
Schnittstellen implementiert.<code lang = "java"
                class = "ToUpper"
                package = "name/panitz/dialoguegui">package name.panitz.dialoguegui;

import name.panitz.html.*;

public class ToUpper extends    ToUpperCase 
                     implements ToHTMLString, DialogueLogic {

  public String toHTMLString(){
     return   &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;+getDescription()
            + &quot;&lt;/title&gt;&lt;/head&gt;&quot;
            + &quot;&lt;body&gt;&lt;b&gt;Small Gui application&lt;/b&gt;&quot;
            + &quot; for convertion of &quot;
            + &quot; a &lt;b&gt;String&lt;/b&gt; into &lt;em&gt;upper&lt;/em&gt;&quot;
            + &quot; case letters.&lt;br&gt;&lt;/br&gt;&quot;
            + &quot;The result of your query was: &lt;p&gt;&quot;
            + &quot;&lt;span style=\&quot;font-family: monospace;\&quot;&gt;&quot;
            + result
            + &quot;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
  }
}</code>

Schnittstellen können auch einander erweitern. Dieses geschieht
dadurch, daß Schnittstellen auch eine <tt>extends</tt>-Klausel haben. Wir können also auch eine Schnittstelle definieren, die die beiden obigen
Schnittstellen zusammenfaßt:<code lang = "java"
                class = "DialogueLogics"
                package = "name/panitz/dialoguegui">package name.panitz.dialoguegui;

import name.panitz.html.*;

public interface DialogueLogics 
        <redv>extends ToHTMLString, DialogueLogic</redv> {}</code></subsubsection>

Ebenso können wir jetzt eine Klasse ableiten, die diese Schnittstelle
implementiert:<code lang = "java"
              class = "UpperConversion"
              package = "name/panitz/dialoguegui">package name.panitz.dialoguegui;

class UpperConversion extends ToUpper
                      implements DialogueLogics{}</code><subsubsection titel = "Benutzung von Schnittstellen">
Schnittstellen sind genauso Typen wie Klassen. Wir kennen jetzt also
drei Arten von Typen: <itemize>
            <item>primitive Typen</item>
            <item>Klassen</item>
            <item>Schnittstellen</item>
          </itemize>

Parameter können vom Typ einer Schnittstellen sein, ebenso wie Felder
oder Rückgabetypen von Methoden. Die Zuweisungkompatibilität nutzt
nicht nur die Unterklassenbeziehung, sondern auch die
Implementierungsbeziehung. Ein Objekt der Klasse <tt>C</tt> darf einem
Feld des Typs der Schnittstelle  <tt>I</tt> zugewiesen werden, 
wenn <tt>C</tt> die Schnittstelle <tt>I</tt> implementiert.<p/> Im Folgenden eine kleine Gui-Anwendung, die wir im einzelnen noch nicht
verstehen müssen. Man beachte, daß der Typ <tt>DialogueLogics</tt> an
mehreren Stellen benutzt wird wie ein ganz normaler Klassentyp. Nur einen
Konstruktoraufruf mit <tt>new</tt> können wir für diesen Typ nicht machen.<code lang = "java"
                class = "HtmlDialogue"
                package = "name/panitz/dialoguegui">package name.panitz.dialoguegui;
import java.awt.event.*;
import java.awt.*;
import javax.swing.*;
import javax.swing.plaf.basic.*; 
import javax.swing.text.*; 
import javax.swing.text.html.*; 

public class HtmlDialogue extends JFrame{
  final <redv>DialogueLogics logic</redv>; 
  final JButton button;
  final JTextField inputField = new JTextField(20) ;
  final JTextPane outputField = new JTextPane();
  final JPanel p = new JPanel();

  public HtmlDialogue(<redv>DialogueLogics</redv> l){
    outputField.setEditorKit(new HTMLEditorKit());
    logic = l;
    button=new JButton(<redv>logic.getDescription()</redv>);
    button.addActionListener
     (new ActionListener(){
        public void actionPerformed(ActionEvent _){
          <redv>logic.eval(inputField.getText().trim())</redv>;
          outputField.setText(<redv>logic.toHTMLString()</redv>);
          pack();
        }
      });

    p.setLayout(new BorderLayout());
    p.add(inputField,BorderLayout.NORTH);
    p.add(button,BorderLayout.CENTER);
    p.add(outputField,BorderLayout.SOUTH);
    getContentPane().add(p);
    pack();
    setVisible(true);
  }
}</code>

Schließlich können wir ein Objekt der Klasse <tt>UpperConversion</tt>, die die Schnittstelle <tt>DialogueLogics</tt> implementiert, konstruieren und der Gui-Anwendung übergeben:<code lang = "java"
                class = "HtmlDialogueTest"
                package = "name/panitz/dialoguegui">package name.panitz.dialoguegui;
public class HtmlDialogueTest {
  public static void main(String [] args){
    new HtmlDialogue(<redv>new UpperConversion()</redv>);
  }
}</code>

Die Anwendung in voller Aktion kann in 
Abbildung <ref name = "HtmlDialogue"/> bewundert werden. <bild name = "HtmlDialogue"
                pdfscale = "0.7"
                psscale = "0.7"
                caption = "Ein Gui-Dialog mit Html-Ausgabe."/></subsubsection><subsubsection titel = "Semantische Einschränkungen für Schnittstellen">
Es gibt einige semantische Einschränkungen, die über die syntaktischen
Einschränkungen hinausgehen:<itemize><item>Schnittstellen können nur Schnittstellen, nicht 
aber Klassen erweitern.</item><item>Jede Methode einer Schnittstelle muß öffentlich sein, braucht also das
Attribut <tt>public</tt>. Wenn dieses für eine Methode nicht
deklariert ist, so wird Java dieses von selbst hinzufügen. Trotzdem müssen implementierende Klassen diese Methode dann als öffentlich deklarieren. Daher ist es besser, das Attribut <tt>public</tt> auch
hinzuschreiben.</item><item>Es gibt keine statischen Methoden in Schnittstellen. </item><item>Jede Methode ist abstrakt, d.h.<white/>hat keinen 
Rumpf. Man kann dieses noch
zusätzlich deutlich machen, indem man das 
Attribut <tt>abstract</tt> für die Methode mit angibt.</item> <item>Felder einer Schnittstelle sind immer statisch, brauchen also das Attribut <tt>static</tt> und  zusätzlich
noch das Attribut <tt>final</tt>.</item></itemize></subsubsection><subsubsection titel = "Iteratorschnittstellen">
Wir kennen bereits das Programmierprinzip der Iteration, das wir benutzen,
indem wir mit einem Schleifenkonstrukt für  die Werte einer Liste einen
bestimmten Codeblock wiederholt ausführen. In Java werden für die Iteration
mit einer <tt>for</tt>-Schleife häufig bestimmte Iteratorobjekte 
benutzt.
Ein Iteratorobjekt kennzeichnet sich durch zwei Methoden:<itemize><item>einer Methode <tt>next</tt>, die jeweils das nächste Element der Iteration zurückgibt.</item> <item>einer Methode <tt>hasNext</tt>, die in einem bool&#39;schen Rückgabewert
angibt, ob es weitere Elemente gibt, die über <tt>next</tt> erfragt werden
könnten. </item></itemize>

Die Funktionalität eines Iteratorobjekts läßt sich über eine
Schnittstellendefinition gut beschreiben.<footnote>Und das wird auch
tatsächlich in Javas Standardklassen so gemacht.</footnote><p/>

Wir sehen einen Iterator vor, dessen Elemente vom primitiven 
Typ <tt>int</tt> sind:<code lang = "java"
                class = "IntIterator"
                package = "name/panitz/iterator">package name.panitz.iterator;
public interface IntIterator{
  public int next();
  public boolean hasNext();
}</code>

Iteratoren sind also Objekte, von denen so lange, bis die 
Methode <tt>hasNext()</tt> einmal <tt>false</tt> zurückgibt, nach einen nächsten Element gefragt werden kann: <code lang = "java"
                class = "PrintIntIteratorElements"
                package = "name/panitz/iterator">package name.panitz.iterator;
public class PrintIntIteratorElements{ 
  static void print(IntIterator it){
    while (it.hasNext()) System.out.print(it.next()+&quot; &quot;);
  }
}</code>

Jetzt können wir verschiedene Iteratoren für <tt>int</tt>-Zahlen schreiben. Ein typischer Iterator soll uns, angefangen von einem Anfangswert bis zu einem Endwert, nacheinander Zahlen geben, und zwar in einer bestimmten Schrittweite:<code lang = "java"
                class = "FromToStep"
                package = "name/panitz/iterator">package name.panitz.iterator;
public class FromToStep implements IntIterator{
  private int from; 
  private int to; 
  private int step; 

  public FromToStep(int from,int to,int step){
    this.from=from;this.to=to;this.step=step;}

  public boolean hasNext(){return from&lt;=to;}
  public int next(){
    int result = from;
    from=from+step;
    return result;
  }
}</code>
Wollen wir immer nur um eins weiterzählen, so können wir eine Subklasse schreiben, die die Schrittweite auf <tt>1</tt> setzt:<code lang = "java"
                class = "FromTo"
                package = "name/panitz/iterator">package name.panitz.iterator;
public class FromTo extends FromToStep{
  public FromTo(int from,int to){super(from,to,1);}
}</code> Wir können einmal versuchen, diesen Iterator mit 
unserer <tt>print</tt>-Methode auszugeben:<code lang = "java"
                class = "TestFromTo"
                package = "name/panitz/iterator">package name.panitz.iterator;
public class TestFromTo {
  public static void main(String []_){
    PrintIntIteratorElements.print(new FromTo(17,42));
  }
}</code><scode>sep@linux:~/fh/prog1/examples/src&gt; java name.panitz.iterator.TestFromTo
17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 
sep@linux:~/fh/prog1/examples/src&gt;</scode><aufgabe>In dieser Aufgabe sollen Sie ein Programm schreiben, das nach und
nach die Primzahlen ausgibt. <unteraufgaben>
              <teil>Schreiben sie eine Unterklasse <tt>From</tt> der 
Klasse <tt>FromTo</tt>, die von einem Startwert an in Einerschritten 
ganze Zahlen zurückgibt und für die <tt>hasNext</tt> immer wahr ist.</teil>
              <teil>Schreiben Sie eine Klasse <tt>Sieb</tt>, die die 
Schnittstelle <tt>IntIterator</tt> implementiert. Die Klasse soll zwei Felder haben: eine ganze Zahl und ein weiteres Objekt, das die 
Schnittstelle <tt>IntIterator</tt> implementiert. Der Konstruktor habe die
Signatur:<br/><tt>public Sieb(int i,IntIterator it)</tt><br/>
Die Methode <tt>next</tt> soll das nächste Element des inneren 
Iterators <tt>it</tt> zurückgeben, das nicht durch die 
Zahl <tt>i</tt> teilbar ist.<p/>
Beispiel: <tt>PrintIntIteratorElements.print(new Sieb(3,new From(1)))</tt> gibt alle nicht
durch 3 teilbaren natürlichen Zahlen auf dem Bildschirm aus.</teil>
              <teil>Übersetzen Sie ihren Code mit folgender Klasse:<code lang = "java"
                      classError = "PrimIterator"
                      package = "name/panitz/iterator">package name.panitz.iterator;
class PrimIterator implements IntIterator{
  private IntIterator sieb = new From(2);
  public boolean hasNext(){return sieb.hasNext();}
  public int next(){
    int result = sieb.next();
    sieb= new Sieb(result,sieb);
    return result;
  }
}</code>
Lassen Sie sich alle Werte von <tt>PrimIterator</tt> mit der 
Methode <tt>PrintIntIteratorElements.print</tt> ausgeben. </teil>
            </unteraufgaben></aufgabe></subsubsection></subsection><subsection titel = "Abstrakte Klassen">

Im vorangegangenen Abschnitt haben wir zusätzlich zu Klassen noch das
Konzept der Schnittstellen kennengelernt. Klassen enthalten Methoden
und Implementierungen für die Methoden. Jede Methode hat einen Rumpf.
Schnittstellen enthalten nur Methodensignaturen. Keine Methode einer
Schnittstelle hat eine Implementierung. Es gibt keine
Methodenrümpfe. Java kennt noch eine Mischform zwischen Klassen und
Schnittstellen: abstrakte Klassen.<subsubsection titel = "Definition abstrakter Klassen">
Eine Klasse wird als abstrakt deklariert, indem dem 
Schlüssenwort <tt>class</tt> das 
Schlüsselwort <tt>abstract</tt> vorangestellt wird. Eine abstrakte
Klasse kann nun Methoden mit und Methoden ohne Rumpf
enthalten. Methoden, die in einer abstrakten Klassen keine
Implementierung enthalten, sind mit dem Attribut <tt>abstract</tt> zu
kennzeichnen. Für abstrakte Klassen gilt also, daß bestimmte Methoden bereits implementiert sind und andere Methoden in Unterklassen zu
implementieren sind. </subsubsection><subsubsection titel = "Abstrakte Klassen und Schnittstellen">
Abstrakte Klassen können auch Schnittstellen implementieren. Entgegen konkreter Klassen brauchen sie aber nicht alle Eigenschaften einer Schnittstelle zu implementieren. Erst eine konkrete Klasse muß alle abstrakten Eigenschaften, die sie auf irgendeinem Weg erbt, implementieren. </subsubsection></subsection></section>
    <section titel = "Ausnahme- und Fehlerbehandlung">
Es gibt während des Ablaufs eines Programmes Situationen, die als
Ausnahmen zum eigentlichen Programmablauf betrachtet werden
können.  Im Normalfall gibt diese
Methode das vorderste Listenelement zurück. Eine Ausnahmefall ist,
wenn dieses Element nicht existiert, weil die Liste leer ist. Java
hält ein Konzept bereit, das die Behandlung von Ausnahmen abseits der
eigentlichen Programmlogik erlaubt.<subsection titel = "Ausnahme- und Fehlerklassen">
Java stellt Standardklassen zur Verfügung, deren Objekte einen
bestimmten Ausnahme- oder Fehlerfall ausdrücken. Die gemeinsame
Oberklasse aller Klassen, die Fehler- oder Ausnahmefälle ausdrücken, ist <tt>java.lang.Throwable</tt>. Diese Klasse hat zwei Unterklassen,
nämlich: <itemize>
          <item><tt>java.lang.Error</tt>: alle Objekte dieser Klasse drücken
aus, daß ein ernsthafter Fehlerfall aufgetreten ist, der in der Regel
von dem Programm selbst nicht zu beheben ist.</item>
          <item><tt>java.lang.Exception</tt>: alle Objekte dieser Klasse stellen
Ausnahmesituationen dar. Im Programm kann eventuell beschrieben sein,
wie bei einer solchen Ausnahmesituation weiter zu verfahren ist.
Eine Unterklasse von <tt>Exception</tt> ist die 
Klasse <tt>java.lang.RuntimeException</tt>.</item>
        </itemize></subsection><subsection titel = "Werfen von Ausnahmen">
Ein Objekt vom Typ <tt>Throwable</tt> allein zeigt noch nicht an, daß ein Fehler aufgetreten ist. Hierzu gibt es einen speziellen Befehl, der im Programmablauf dieses kennzeichnet, der Befehl <tt>throw</tt>. <p/><tt>throw</tt> ist ein Schlüsselwort, dem ein Objekt des  Typs <tt>Throwable</tt> folgt. Bei einem <tt>throw</tt>-Befehl 
verläßt Java die eigentliche Ausführungsreihenfolge des Programms  und unterrichtet die
virtuelle Maschine
davon, daß eine Ausnahme aufgetreten ist. Z.B.<white/>können wir für die
Fakultätsmethoden bei einem Aufruf mit einer negativen Zahl eine
Ausnahme werfen:<code lang = "java"
              class = "FirstThrow"
              package = "name/panitz/exceptions">package name.panitz.exceptions;
public class FirstThrow {

  public static int fakultät(int n){
    if (n==0) return 1;
    if (n&lt;0) throw new RuntimeException();
    return n*fakultät(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakultät(5));
    System.out.println(fakultät(-3));
    System.out.println(fakultät(4));
  }
}</code>
Wenn wir dieses Programm starten, dann sehen wir, daß zunächst die
    Fakultät für die Zahl 5 korrekt berechnet und ausgegeben wird, dann der Fehlerfall auftritt, was dazu führt, daß der Fehler auf der Kommandozeile ausgegeben wird und das Programm sofort beendet
    wird. Die Berechnung der Fakultät von 4 wird nicht mehr durchgeführt.
Es kommt zu folgender Ausgabe:<scode>swe10:~&gt; java name.panitz.exceptions.FirstThrow
120
Exception in thread &quot;main&quot; java.lang.RuntimeException
  at name.panitz.exceptions.FirstThrow.fakultät(FirstThrow.java:6)
  at name.panitz.exceptions.FirstThrow.main(FirstThrow.java:12)
swe10:~&gt;</scode> Wie man sieht, unterrichtet uns Java in der ersten Zeile davon, daß
eine Ausnahme des Typs <tt>RuntimeException</tt> geworfen wurde. In der zweiten Zeile erfahren wir, daß dieses  bei der Ausführung der
Methode <tt>fakultät</tt> in Zeile 6 der  Klasse <tt>FirstThrow</tt> geschehen ist. Anschließend, in den Zeilen
weiter unten, gibt Java jeweils an, in welcher Methode der Aufruf der
in der drüberliegenden Methode stattfand.<p/> Die Ausgabe gibt also an, durch welchen verschachtelten Methodenaufruf 
es an die Stelle kam, in der die Ausnahme geworfen wurde. Diese
Aufrufstruktur wird als Aufrufkeller (<em>stack trace</em>) bezeichnet.<p/> Das Erzeugen eines Ausnahmeobjekts allein bedeutet noch keinen
Fehlerfall. Wenn wir das obige Programm minimal ändern, so daß wir das
Schlüsselwort <tt>throw</tt> weglassen, so wird der Sonderfall für
negative Eingaben nicht gesondert behandelt.<code lang = "java"
              class = "NonThrow"
              package = "name/panitz/exceptions">package name.panitz.exceptions;
public class NonThrow {

  public static int fakultät(int n){
    if (n==0) return 1;
    if (n&lt;0) new RuntimeException();
    return n*fakultät(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakultät(5));
    System.out.println(fakultät(-3));
    System.out.println(fakultät(4));
  }
}</code>
Wenn wir dieses Programm starten, so wird es nicht terminieren und je
    nach benutzter Javamaschine schließlich abbrechen:<scode>swe10:~&gt; java name.panitz.exceptions.NonThrow
120

An irrecoverable stack overflow has occurred.
</scode> Es reicht also nicht aus, ein Fehlerobjekt zu erzeugen, sondern es muß
dieses auch mit einem <tt>throw</tt>-Befehl geworfen werden.
Geworfen werden können alle Objekte einer Unterklasse  von <tt>Throwable</tt>. Versucht man hingegen, andere Objekte zu werfen, so führt dies schon zu einem Übersetzungsfehler.<p/>
Folgende Klasse:<code lang = "java"
              classError = "NotThrowable"
              package = "name/panitz/exceptions">package name.panitz.exceptions;
public class NotThrowable {

  public static void main(String [] args){
      throw &quot;i am not throwable&quot;;
  }
}</code> führt zu einem Übersetzungsfehler:<scode>swe10:~&gt; javac -d . NotThrowable.java
NotThrowable.java:5: incompatible types
found   : java.lang.String
required: java.lang.Throwable
      throw &quot;i am not throwable&quot;;
            ^
1 error
swe10:~&gt;</scode>

Ausnahmen können natürlich nicht nur auftreten, wenn wir sie selbst explizit geworfen haben, sondern auch von Methoden aus Klassen, die wir
selbst benutzen, geworfen werden. So kann z.B.<white/>die Benutzung der Methode <tt>charAt</tt> aus der Klasse <tt>String</tt> dazu führen, daß
eine Ausnahme geworfen wird.<code lang = "java"
              class = "ThrowIndex"
              package = "name/panitz/exceptions">package name.panitz.exceptions;
public class ThrowIndex {

  public static void main(String [] args){
      &quot;i am too short&quot;.charAt(120);
  }
}</code>
Starten wir dieses Programm, so wird auch eine Ausnahme geworfen:<scode>swe10:~&gt; java name.panitz.exceptions.ThrowIndex
Exception in thread &quot;main&quot; java.lang.StringIndexOutOfBoundsException: 
                                    String index out of range: 120
  at java.lang.String.charAt(String.java:516)
  at name.panitz.exceptions.ThrowIndex.main(ThrowIndex.java:5)
swe10:~&gt;
</scode>
Wie man an diesem Beispiel sieht, gibt Java nicht nur die Klasse der
Ausnahme, die geworfen wurde, 
aus (<tt>java.lang.StringIndexOutOfBoundsException:</tt>), sondern
auch noch eine zusätzliche Erklärung. Die Objekte der Unterklassen 
von <tt>Throwable</tt> haben in der Regel einen Konstruktor, der
erlaubt noch eine zusätzliche Information, die den Fehler erklärt, mit
anzugeben. Das können wir auch in unserem Beispielprogramm nutzen:<code lang = "java"
              class = "SecondThrow"
              package = "name/panitz/exceptions">package name.panitz.exceptions;

public class SecondThrow {
  public static int fakultät(int n){
    if (n==0) return 1;
    if (n&lt;0) 
     throw
      new RuntimeException
           (&quot;negative Zahl für Fakultätsberechnung&quot;);
    return n*fakultät(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakultät(5));
    System.out.println(fakultät(-3));
    System.out.println(fakultät(4));
  }
}</code>
Damit erhalten wir folgende Ausgabe:<scode>swe10:~&gt; java name.panitz.exceptions.SecondThrow
120
Exception in thread &quot;main&quot; java.lang.RuntimeException: 
                                    negative Zahl für Fakultätsberechnung
  at name.panitz.exceptions.SecondThrow.fakultät(SecondThrow.java:6)
  at name.panitz.exceptions.SecondThrow.main(SecondThrow.java:12)
swe10:~&gt;</scode></subsection><subsection titel = "Deklaration von geworfenen  Ausnahmen">
Um sich auf Ausnahmefälle einzustellen, ist notwendig, daß einer
Methode angesehen werden kann, ob sie bei der Ausführung eventuell
eine Ausnahme werfen wird. Java bietet an, dieses in der Signatur der
Methoden zu schreiben. Java bietet dieses nicht nur an, sondern
schreibt sogar zwingend vor, daß alle  Ausnahmeobjekte, die in einer
Methode geworfen werden, auch in der Signatur der Methode angegeben
sind. Einzig davon ausgenommen sind Objekte des 
Typs <tt>RuntimeException</tt>. Wollen wir in unserem obigen Programm eine andere Ausnahme werfen als eine <tt>RuntimeException</tt>, so
können wir das zunächst nicht:<code lang = "java"
              classError = "ThirdThrow"
              package = "name/panitz/exceptions">package name.panitz.exceptions;
public class ThirdThrow {

  public static int fakultät(int n){
    if (n==0) return 1;
    if (n&lt;0) throw new Exception
             (&quot;negative Zahl für Fakultätsberechnung&quot;);
    return n*fakultät(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakultät(5));
    System.out.println(fakultät(-3));
    System.out.println(fakultät(4));
  }
}</code> Bei der Übersetzung kommt es zu folgendem Fehler:<scode>swe10:~&gt; javac -d . ThirdThrow.java
ThirdThrow.java:6: unreported exception java.lang.Exception; 
                                      must be caught or declared to be thrown
    if (n&lt;0) throw new Exception(&quot;negative Zahl für Fakultätsberechnung&quot;);
             ^
1 error
</scode> Java verlangt, daß wir für die Methode <tt>fakultät</tt> in der Signatur angeben, daß die Methode eine Ausnahme wirft. Dieses geschieht durch
eine <tt>throws</tt>-Klausel zwischen Signatur und Rumpf der Methode. Dem Schlüsselwort <tt>throws</tt> folgen dabei durch Kommas getrennt
die Ausnahmen, die durch die Methode geworfen werden können.<p/>
In unserem Beispiel müssen wir für beide Methoden angeben, daß 
eine <tt>Exception</tt> auftreten kann, denn in der 
Methode <tt>main</tt> können ja die Ausnahmen der  Methode <tt>fakultät</tt> auftreten:<code lang = "java"
              class = "FourthThrow"
              package = "name/panitz/exceptions">package name.panitz.exceptions;
public class FourthThrow {

  public static int fakultät(int n) throws Exception{
    if (n==0) return 1;
    if (n&lt;0) 
     throw 
      new Exception(&quot;negative Zahl für Fakultätsberechnung&quot;);
    return n*fakultät(n-1);
  }

  public static void main(String [] args) throws Exception{
    System.out.println(fakultät(5));
    System.out.println(fakultät(-3));
    System.out.println(fakultät(4));
  }
}</code>

Somit stellt Java sicher, daß über die möglichen Ausnahmefälle Buch
geführt wird. </subsection><subsection titel = "Eigene Ausnahmeklassen">
Man ist bei der Programmierung nicht auf die von Java in
Standardklassen ausgedrückten Ausnahmeklassen eingeschränkt. Es können
eigene Klassen, die von der Klasse <tt>Exception</tt> ableiten, geschrieben  und ebenso wie die Standardausnahmen geworfen
werden:<code lang = "java"
              class = "NegativeNumberException"
              package = "name/panitz/exceptions">package name.panitz.exceptions;
public class NegativeNumberException extends Exception {
}</code> So kann  unser Beispielprogramm jetzt unsere eigene Ausnahme werfen :<code lang = "java"
              class = "FifthThrow"
              package = "name/panitz/exceptions">package name.panitz.exceptions;
public class FifthThrow {

  public static int fakultät(int n) throws Exception{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    return n*fakultät(n-1);
  }

  public static void main(String [] args) throws Exception{
    System.out.println(fakultät(5));
    System.out.println(fakultät(-3));
    System.out.println(fakultät(4));
  }
}</code>
Bei der Ausführung dieses Programms sehen wir jetzt unsere eigene
    Ausnahme:<scode>sep@swe10:~/fh/beispiele&gt; java name.panitz.exceptions.FifthThrow
120
Exception in thread &quot;main&quot; name.panitz.exceptions.NegativeNumberException
        at name.panitz.exceptions.FifthThrow.fakultät(FifthThrow.java:6)
        at name.panitz.exceptions.FifthThrow.main(FifthThrow.java:12)
sep@swe10:~/fh/beispiele&gt;
</scode></subsection><subsection titel = "Fangen von Ausnahmen"> Zu einem vollständigen Konzept zur Ausnahmebehandlung gehört nicht
nur, daß über Ausnahmezustände beim Programmabbruch berichtet wird, sondern auch, daß auch angegeben werden kann, wie im Falle einer
aufgetretenen Ausnahme weiter zu verfahren ist. <subsubsection titel = "Syntax">
Java stellt hierzu 
das <tt>try</tt>-und-<tt>catch</tt>  Konstrukt zur Verfügung. Es hat
folgende Struktur:<p/><center>
            <fbox>
              <ttt>try <lpar/></ttt>
              <em>stats</em>
              <ttt><rpar/> catch (</ttt>
              <em>ExceptionName</em>
              <white/>
              <em>ident</em>
              <ttt> )<lpar/></ttt>
              <em>stats</em>
              <ttt>
                <rpar/>
              </ttt>
            </fbox>
          </center><p/>


Der <tt>try</tt>-Block umschließt in diesem Konstrukt den Code, der
bei der Ausführung auf das Auftreten eventueller Ausnahmen abgeprüft
werden soll. Der <tt>catch</tt>-Block (von dem es auch mehrere geben kann)  beschreibt, was für Code im Falle des Auftretens einer Ausnahme  zur Ausnahmebehandlung auszuführen ist. Jetzt können wir programmieren, wie im Falle einer Ausnahme zu verfahren ist:<code lang = "java"
                class = "Catch1"
                package = "name/panitz/exceptions">package name.panitz.exceptions;
public class Catch1 {

  public static int fakultät(int n) throws Exception{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    return n*fakultät(n-1);
  }

  public static void main(String [] args){
    try {
      System.out.println(fakultät(5));
      System.out.println(fakultät(-3));
      System.out.println(fakultät(4));
    }catch (Exception e){
      System.out.println(&quot;Ausnahme aufgetreten: &quot;+e);
    }
  }
}</code>
Wie man sieht, braucht jetzt die Methode <tt>main</tt> nicht mehr zu
     deklarieren, daß sie eine Ausnahme wirft, denn sie fängt ja alle
     Ausnahmen, die eventuell während ihrer Auswertung geworfen wurden,
    ab. Das Programm erzeugt folgende Ausgabe:<scode>swe10:~&gt; java name.panitz.exceptions.Catch1
120
Ausnahme aufgetreten: name.panitz.exceptions.NegativeNumberException
swe10:~&gt;
</scode>

Das Programm berechnet zunächst korrekt die Fakultät für 5, es kommt
zu einer Ausnahme bei der Berechnung der Fakultät von -3. Das Programm verläßt den normalen Pro<lb/>gramm<lb/>ab<lb/>lauf und wird erst in 
der <tt>catch</tt>-Klausel wieder abgefangen. Der Code 
dieser <tt>catch</tt>-Klausel wird ausgeführt. Innerhalb 
der <tt>catch</tt>-Klausel hat das Programm Zugriff auf das Ausnahmeobjekt, das geworfen wurde. In unserem Fall benutzen wir
dieses, um es auf dem Bildschirm auszugeben.</subsubsection><subsubsection titel = "Granularität des Abfangens">
Die Granularität, für welche Programmteile eine Ausnahmebehandlung
ausgeführt werden soll, steht in unserem Belieben. Wir können
z.B.<white/>auch für jeden Aufruf der Methode <tt>fakultät</tt> einzeln 
eine Ausnahmebehandlung vornehmen:<code lang = "java"
                class = "Catch2"
                package = "name/panitz/exceptions">package name.panitz.exceptions;
public class Catch2 {

  public static int fakultät(int n) throws Exception{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    return n*fakultät(n-1);
  }

  public static void main(String [] args){
    try {
      System.out.println(fakultät(5));
    }catch (Exception _){
      System.out.println(&quot;Ausnahme für Fakultät von 5&quot;);
    } 
    try {
      System.out.println(fakultät(-3));
    }catch (Exception _){
      System.out.println(&quot;Ausnahme für Fakultät von -3&quot;);
    } 
    try {
      System.out.println(fakultät(4));
    }catch (Exception _){
      System.out.println(&quot;Ausnahme für Fakultät von 4&quot;);
    } 
  }
}</code>
Dieses Programm<footnote>Eine Konvention, die ich in funktionalen
  Programmiersprachen kennengelernt habe, benutzt für
    nichtgebrauchte Variablen den Unterstrich als Bezeichner. Da mich
     in den einzelnen {\tt catch}-Klauseln das Ausnahmeobjekt nicht
    interessiert, benutze ich jeweils den Unterstrich als
Bezeichner  dafür.</footnote> erzeugt folgende Ausgabe auf dem Bildschirm:<scode>swe10:~/fh/beispiele&gt; java name.panitz.exceptions.Catch2
120
Ausnahme für Fakultät von -3
24
swe10:~/fh/beispiele&gt;</scode></subsubsection><subsubsection titel = "Abfangen spezifischer Ausnahmen">
In allen unseren bisherigen Beispielen fangen wir in 
der <tt>catch</tt>-Klausel allgemein die Fehlerobjekte des 
Typs <tt>Exception</tt> ab. Ebenso deklarieren wir allgemein in 
der <tt>throws</tt>-Klausel der Methode <tt>fakultät</tt>, daß ein
Ausnahmeobjekt des Typs <tt>Exception</tt> geworfen wird. Hier können wir spezifischer sein und jeweils exakt die Unterklasse  
von <tt>Exception</tt> angeben, deren Objekte tatsächlich geworfen
werden: <code lang = "java"
                class = "Catch3"
                package = "name/panitz/exceptions">package name.panitz.exceptions;
public class Catch3 {

  public static int fakultät(int n) 
                        throws NegativeNumberException{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    return n*fakultät(n-1);
  }

  public static void main(String [] args){
    try {
      System.out.println(fakultät(5));
      System.out.println(fakultät(-3));
      System.out.println(fakultät(4));
    }catch (NegativeNumberException e){
      System.out.println(&quot;Ausnahme aufgetreten: &quot;+e);
    } 
  }
}</code></subsubsection><subsubsection titel = "Abfangen mehrerer Ausnahmen">
Wir können nun nicht nur eine spezifische Ausnahme abfangen, sondern für unterschiedliche Ausnahmen auch unterschiedliche Ausnahmebehandlungen vorsehen. Dieses geschieht einfach, dadurch, daß
mehrere <tt>catch</tt>-Klauseln untereinander stehen.<p/>
Hierzu definieren wir uns zunächst eine weitere Ausnahmeklasse:<code lang = "java"
                class = "NumberTooLargeException"
                package = "name/panitz/exceptions">package name.panitz.exceptions;
public class NumberTooLargeException extends Exception {
}</code> 

Jetzt können wir unterschiedliche Ausnahmen werfen und wieder fangen:<code lang = "java"
                class = "Catch4"
                package = "name/panitz/exceptions">package name.panitz.exceptions;
public class Catch4 {

  public static int fakultät(int n) 
        throws NegativeNumberException, NumberTooLargeException{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    if (n&gt;20) throw new NumberTooLargeException();
    return n*fakultät(n-1);
  }

  public static void printFakultät(int i){
    try {
      System.out.println(fakultät(i));
    }catch (NegativeNumberException _){
      System.out.println(&quot;Fakultät von negativer Zahl&quot;);
    } 
    catch (NumberTooLargeException _){
      System.out.println(&quot;Fakultät von zu großer Zahl&quot;);
    } 
  }

  public static void main(String [] args){
    printFakultät(30);
    printFakultät(-3);
    printFakultät(4);
  }
}
</code>

Dieses Programm führt zu folgender Ausgabe:<scode>swe10:~/fh/beispiele&gt; java name.panitz.exceptions.Catch4
Fakultät von zu großer Zahl
Fakultät von negativer Zahl
24
swe10:~/fh/beispiele&gt;
</scode></subsubsection><subsubsection titel = "Zusammenspiel mit Rückgabewerten"> Für Methoden mit einem Rückgabewert ist es beim Abfangen von Ausnahmen  wichtig, darauf zu achten, daß in sämtlichen Fällen von
abgefangenen Ausnahmen trotzdem ein Rückgabewert zurückgegeben
wird. Ebenso ist auch zu berücksichtigen, daß jede benutzte Variable,
bevor sie benutzt wird, auch einen Wert zugewiesen bekommen
hat. Folgendes Programm wird aus diesem Grund vom Javaübersetzer mit
einer Fehlermeldung zurückgewiesen:<code lang = "java"
                classError = "WrongCatch"
                package = "name/panitz/exceptions">package name.panitz.exceptions;
public class WrongCatch {

  public static int fakultät(int n) 
        throws NegativeNumberException, NumberTooLargeException{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    if (n&gt;20) throw new NumberTooLargeException();
    return n*fakultät(n-1);
  }

  public static int checkFakultät(int i){
    try {
      return fakultät(i);
    }catch (Exception e){
      System.out.println(&quot;Ausnahme &quot;+e+&quot; aufgetreten&quot;);
    } 
  }

  public static void main(String [] args){
    System.out.println(checkFakultät(30));
    System.out.println(checkFakultät(-3));
    System.out.println(checkFakultät(4));
  }
}</code>
Die Übersetzung führt zu folgender Fehlermeldung:<scode>sep@swe10:~/fh/beispiele&gt; javac -d . WrongCatch.java
WrongCatch.java:12: missing return statement
  public static int checkFakultät(int i){
                                        ^
1 error
sep@swe10:~/fh/beispiele&gt;
</scode> Für die im <tt>try</tt>-Block stehenden Befehle ist nicht garantiert,
daß sie tatsächlich ausgeführt werden. Tritt eine Ausnahme auf, so
wird der <tt>try</tt>-Block  verlassen, bevor der <tt>return</tt>-Befehl ausgeführt wurde, und die Methode gibt keinen
Rückgabewert zurück, was aber ihre Signatur verlangt. Wir müssen dafür
sorgen, daß auch in Ausnahmefällen ein Rückgabewert existiert. Dieses
kann durch einen <tt>return</tt>-Befehl im <tt>catch</tt>-Block
geschehen: <code lang = "java"
                class = "Catch5"
                package = "name/panitz/exceptions">package name.panitz.exceptions;
public class Catch5 {

  public static int fakultät(int n) 
        throws NegativeNumberException, NumberTooLargeException{
    if (n==0) return 1;
    if (n&lt;0) throw new NegativeNumberException();
    if (n&gt;20) throw new NumberTooLargeException();
    return n*fakultät(n-1);
  }

  public static int checkFakultät(int i){
    try {
      return fakultät(i);
    }catch (Exception e){
      System.out.println(&quot;Ausnahme &quot;+e+&quot; aufgetreten&quot;);
      return 0;
    } 
  }

  public static void main(String [] args){
    System.out.println(checkFakultät(30));
    System.out.println(checkFakultät(-3));
    System.out.println(checkFakultät(4));
  }
}
</code>
Dieses Programm läßt sich wieder fehlerfrei übersetzen und ergibt
    folgende Ausgabe:<scode>[sep@swe10:~/fh/beispiele&gt; java name.panitz.exceptions.Catch5
Ausnahme name.panitz.exceptions.NumberTooLargeException aufgetreten
0
Ausnahme name.panitz.exceptions.NegativeNumberException aufgetreten
0
24
sep@swe10:~/fh/beispiele&gt;
</scode></subsubsection></subsection><subsection titel = "Der Aufrufkeller">
Wir haben schon gesehen, daß Javas Ausnahmeobjekte wissen, wie die
Aufrufreihenfolge war, die zu der Programmstelle führt, in der die
Ausnahme erzeugt wurde. Java hat einen internen Aufrufkeller, in dem
alle Methoden übereinander stehen, die aufgerufen wurden, aber deren
Aufruf noch nicht beendet wurde. Bei der Fehlersuche kann es oft sehr
hilfreich sein, an bestimmten Stellen zu erfahren, durch welche
Aufrufhierarchie der Methoden an diese Stelle gelangt
wurde. Ausnahmeobjekte enthalten die Methode <tt>printStackTrace</tt>,
die genau diese Information auf den Bildschirm ausgibt. Wir können
diese Methode zur Fehlersuche nutzen, indem wir ein Ausnahmeobjekt
erzeugen, dieses aber nicht werfen, sondern lediglich die 
Methode <tt>printStackTrace</tt> darauf aufrufen. Die normale
Ausführungsreihenfolge wird hierdurch nicht berührt, es erscheint
lediglich eine weitere Ausgabe auf dem Bildschirm:<code lang = "java"
              class = "StackTrace"
              package = "name/panitz/exceptions">package name.panitz.exceptions;
public class StackTrace {

    public static int fakultät(int n) {
    if (n==0) {
	new Exception().printStackTrace();
      return 1;
    }
    return n*fakultät(n-1);
  }

  public static void main(String [] args){
    System.out.println(fakultät(4));
  }
}
</code>
Dieses Programm erzeugt folgende recht informative Ausgabe auf dem
    Bildschirm:<scode>sep@swe10:~/fh/beispiele&gt; java name.panitz.exceptions.StackTrace
java.lang.Exception
        at name.panitz.exceptions.StackTrace.fakultät(StackTrace.java:6)
        at name.panitz.exceptions.StackTrace.fakultät(StackTrace.java:9)
        at name.panitz.exceptions.StackTrace.fakultät(StackTrace.java:9)
        at name.panitz.exceptions.StackTrace.fakultät(StackTrace.java:9)
        at name.panitz.exceptions.StackTrace.fakultät(StackTrace.java:9)
        at name.panitz.exceptions.StackTrace.main(StackTrace.java:13)
24
sep@swe10:~/fh/beispiele&gt;
</scode>
Es läßt sich hier sehr schön die rekursive Struktur der
Fakultätsmethode nachverfolgen: Wenn von der Methode die Zeile 6 ausgeführt wird, so wurde sie schon viermal in Zeile 9 ausgeführt und
all diese Aufrufe der Methode sind noch nicht beendet. Man kann den
Aufrufkeller auch als Liste der noch zu erledigenden Methoden  betrachten. Die Ausführung aller Methoden, die dort verzeichnet sind,
wurde bereits angefangen, aber noch nicht beendet.</subsection><subsection titel = "Schließlich und finally"> Java erlaubt, am Ende eines <tt>try</tt>-und-<tt>catch</tt>-Konstruktes
noch eine <tt>finally</tt>-Klausel hinzuzufügen. Diese besteht aus dem Schlüsselwort <tt>finally</tt>, gefolgt von Anweisungen. Die
Anweisungen einer <tt>finally</tt>-Klausel werden immer ausgeführt,
unabhängig davon, ob eine Ausnahme abgefangen wurde oder nicht. Im
folgenden Programm wird in beiden Fällen der Text in  der <tt>finally</tt>-Klausel ausgegeben:<code lang = "java"
              class = "Finally">class Finally {
 
  static void m(int i) throws Exception{
    if (i&gt;0) throw new Exception();
  }

  public static void main(String [] args){
    try {m(1);}
    catch (Exception _){System.out.println(&quot;Ausnahme gefangen&quot;);}
    finally {System.out.println(&quot;erster Test&quot;);}

    try {m(-1);}
    catch (Exception _){System.out.println(&quot;Ausnahme gefangen&quot;);}
    finally {System.out.println(&quot;zweiter Test&quot;);}
  }
}</code>


Die <tt>finally</tt>-Klausel wird nicht nur ausgeführt, wenn keine Ausnahme geworfen  oder eine Ausnahme gefangen wurde, sondern
auch, wenn eine Ausnahme geworfen wurde, für die es  keine <tt>catch</tt>-Klausel gibt<footnote>Ansonsten wäre  die <em>finally</em>-Klausel ein überflüssiges Konstrukt, könnte man
seinen Code ja direkt anschließend an das <em>try-catch</em>-Konstrukt
anhängen.</footnote>.<p/>
So wird in der folgenden Klasse die Ausgabe 
der <tt>finally</tt>-Klausel sogar gemacht, obwohl eine Ausnahme
auftritt, die nicht abgefangen wird:<code lang = "java"
              class = "MoreFinally">class MoreFinally {

    static void m(int i){
	if (i&lt;0) throw new NullPointerException();
    }

    public static void main(String [] args){
	try {m(-1);}
	catch (IndexOutOfBoundsException _){}
	finally 
	{System.out.println(&quot;wird trotzdem ausgegeben&quot;);}
   }

}</code>

Wie man an dem Programmlauf sieht, tritt eine nichtabgefangene Ausnahme auf, und
trotzdem wird noch der <tt>finally</tt>-Code ausgeführt.<p/>

Die <tt>finally</tt>-Klausel ist dazu da, um Code zu einer
Ausnahmebehandlung hinzuzufügen, der sowohl nach dem Auftreten von jeder abgefangenen Ausnahme auszuführen ist als auch ,
wenn keine Ausnahme abgefangen wurde. Typisch für solchen Code
sind Verwaltungen von externen Komponenten. Wenn in einer Methode
eine Datenbankverbindung geöffnet wird, so ist diese Datenbankverbindung sowohl im
erfolgreichen Fall als auch, wenn irgendeine Ausnahme auftritt,
wieder zu schließen.</subsection><subsection titel = "Anwendungslogik per Ausnahmen">
Es gibt die Möglichkeit, Ausnahmen nicht nur für eigentliche
Ausnahmefälle zu benutzen, sondern die normale Anwendungslogik per
Ausnahmebehandlung zu programmieren. Hierbei ersetzt 
ein <tt>try</tt>-<tt>catch</tt>-Block 
eine <tt>if</tt>-Bedingung. Einer der Fälle, die normaler Weise über
eine Bedingung angefragt werden, wird als Ausnahmefall behandelt.
Statt in einer Schleife über eine Reihung die Indizes abzufragen, kann man
auch versuchen, das Ende der Reihung über eine Ausnahme abzufangen:<code class = "CatchOutOfBounds"
              lang = "java">class CatchOutOfBounds{
  public static void main(String [] args){
    int[] xs = {1,2,3,4,5,6,5,5,2,4,5,7,4,3,2,2,5,6};
    int result = 0;
    try{
      int i =0;
      while (true) {result=result+xs[i];i=i+2;}
    }catch (IndexOutOfBoundsException e){}
    System.out.println(result);
  }
}</code></subsection></section>
  </kapitel>
  <kapitel titel = "Generische Programmierung">
    <section titel = "Generische Typen">
Generische Typen wurden im JSR014 definiert. In der Expertengruppe des JSR014
war der Autor dieses Skripts
zeitweilig als Stellvertreter der Software AG Mitglied. Die 
Software<w/>AG hatte mit der Programmiersprache Bolero bereits einen Compiler
für generische Typen implementiert<cite label = "bolero"/>. Der 
Bolero Compiler generiert auch
Java Byte Code. Von dem ersten Wunsch nach Generizität bis zur nun 
vorliegenden Javaversion 1.5 sind viele Jahre vergangen. Andere wichtige JSRs,
die in Java 1.5 integriert werden, tragen bereits die Nummern 175 und
201. Hieran kann man schon erkennen,  wie lange  es gedauert hat, bis
generische Typen in Java integriert wurden.<p/>


Interessierten Programmierern steht schon seit Mitte der 90er Jahre eine
Javaerweiterung mit generischen Typen zur Verfügung. Unter den Namen 
Pizza <cite label = "pizza"/> existiert eine Javaerweiterung, die nicht nur
generische Typen, sondern auch algebraische Datentypen mit <em>pattern
matching</em> und Funktionsobjekten zu Java hinzufügte. Unter den 
Namen <em>GJ</em> für <em>Generic Java</em> wurde eine allein auf generische
Typen abgespeckte Version von <em>Pizza</em> publiziert. <em>GJ</em> ist
tatsächlich der direkte Prototyp für Javas generische Typen. Die Expertenrunde
des JSR014 hat <em>GJ</em> als Grundlage für die Spezifikation genommen und an
den grundlegenden Prinzipien auch nichts mehr geändert.<subsection titel = "Generische Klassen">
Die Idee für generische Typen ist, eine Klasse zu schreiben, die für
verschiedene Typen als Inhalt zu benutzen ist. Das geht bisher in Java,
allerdings mit einem kleinen Nachteil. Versuchen  wir einmal, 
in traditionellem Java eine Klasse zu schreiben, in der 
wir beliebige Objekte speichern können. Um beliebige
Objekte speichern zu können, brauchen wir ein Feld, in dem Objekte jeden Typs
gespeichert werden können. Dieses Feld muß daher den 
Typ <tt>Object</tt> erhalten:<code class = "OldBox"
              lang = "java">class OldBox {
  <redv>Object</redv> contents;
  OldBox(<redv>Object</redv> contents){this.contents=contents;}
}</code>

Der Typ <tt>Object</tt> ist ein sehr unschöner Typ; denn mit ihm verlieren wir
jegliche statische Typinformation. Wenn wir die Objekte der 
Klasse <tt>OldBox</tt> benutzen wollen, so verlieren wir sämtliche
Typinformation über das in dieser Klasse abgespeicherte Objekt. Wenn wir auf
das Feld <tt>contents</tt> zugreifen, so haben wir über das darin gespeicherte
Objekte keine spezifische Information mehr. Um das Objekt weiter sinnvoll
nutzen zu können, ist eine dynamische Typzusicherung durchzuführen: <code class = "UseOldBox"
              lang = "java">class UseOldBox{
  public static void main(String [] _){
    OldBox b = new OldBox(&quot;hello&quot;);
    String s = <redv>(String)</redv>b.contents;
    System.out.println(s.toUpperCase());
    System.out.println((<redv>(String)</redv> s).toUpperCase());
  }
}</code>

Wann immer wir mit dem Inhalt des Felds <tt>contents</tt> arbeiten wollen, ist
die Typzusicherung während der Laufzeit durchzuführen. Die dynamische
Typzusicherung kann zu einem Laufzeitfehler führen. So übersetzt das folgende
Programm fehlerfrei, ergibt aber einen Laufzeitfehler:<code class = "UseOldBoxError"
              lang = "java">class UseOldBoxError{
  public static void main(String [] _){
    OldBox b = new OldBox(new Integer(42));
    String s = <redv>(String)</redv>b.contents;
    System.out.println(s.toUpperCase());
  }
}</code><scode>sep@linux:~/fh/java1.5/examples/src&gt; javac UseOldBoxError.java
sep@linux:~/fh/java1.5/examples/src&gt; java UseOldBoxError
Exception in thread &quot;main&quot; java.lang.ClassCastException
        at UseOldBoxError.main(UseOldBoxError.java:4)
sep@linux:~/fh/java1.5/examples/src&gt;</scode>


Wie man sieht, verlieren wir Typsicherheit, sobald der 
Typ <tt>Object</tt> benutzt wird. Bestimmte Typfehler können nicht mehr
statisch zur Übersetzungszeit, sondern erst dynamisch zur Laufzeit entdeckt
werden. <p/>

Der Wunsch ist, Klassen zu schreiben, die genauso allgemein benutzbar sind wie
die Klasse <tt>OldBox</tt> oben, aber trotzdem die statische Typsicherheit
garantieren, indem sie nicht mit dem allgemeinen 
Typ <tt>Object</tt> arbeiten. Genau dieses leisten generische Klassen. Hierzu
ersetzen wir in der obigen Klasse jedes Auftreten des 
Typs <tt>Object</tt> durch einen Variablennamen. Diese Variable ist eine
Typvariable. Sie steht für einen beliebigen Typen. Dem Klassennamen fügen wir
zusätzlich in der Klassendefinition in spitzen Klammern eingeschlossen hinzu,
daß diese Klasse eine Typvariable benutzt. Wir erhalten somit aus der obigen
Klasse <tt>OldBox</tt> folgende generische Klasse <tt>Box</tt>.<code class = "Box"
              lang = "java">class Box&lt;<redv>elementType</redv>&gt; {
  <redv>elementType</redv> contents;
  Box(<redv>elementType</redv> contents){this.contents=contents;}
}</code>

Die Typvariable <tt>elementType</tt> ist als allquantifiziert zu
verstehen. Für jeden Typ <tt>elementType</tt> können wir die
Klasse <tt>Box</tt> benutzen. Man kann sich unsere 
Klasse <tt>Box</tt> analog zu einer realen Schachtel vorstellen: Beliebige
Dinge können in die Schachtel gelegt werden. Betrachten wir dann allein die
Schachtel von außen, können wir nicht mehr wissen, was für ein Objekt darin
enthalten ist. Wenn wir viele Dinge in Schachteln packen, dann schreiben
wir auf die Schachtel jeweils drauf, was in der entsprechenden Schachtel
enthalten ist. Ansonsten würden wir schnell die Übersicht verlieren. Und genau
das ermöglichen generische Klassen. Sobald wir ein konkretes Objekt der 
Klasse <tt>Box</tt> erzeugen wollen, müssen wir entscheiden, für welchen
Inhalt wir eine Box brauchen. Dieses geschieht, indem in spitzen Klammern dem
Klassennamen <tt>Box</tt> ein entsprechender Typ für den Inhalt angehängt
wird. Wir erhalten dann z.B.<w/>den Typ <tt>Box&lt;String&gt;</tt>, um Strings
in der Schachtel zu speichern, oder <tt>Box&lt;Integer&gt;</tt>, um
Integerobjekte darin zu speichern:<code class = "UseBox"
              lang = "java">class UseBox{
  public static void main(String [] _){
    Box&lt;<redv>String</redv>&gt; b1 = new Box&lt;<redv>String</redv>&gt;(&quot;hello&quot;);
    String s = b1.contents;
    System.out.println(s.toUpperCase());
    System.out.println(b1.contents.toUpperCase());

    Box&lt;<redv>Integer</redv>&gt; b2 = new Box&lt;<redv>Integer</redv>&gt;(new Integer(42));

    System.out.println(b2.contents.intValue());
  }
}</code>


Wie man im obigen Beispiel sieht, fallen jetzt die dynamischen
Typzusicherungen weg. Die Variablen <tt>b1</tt> und <tt>b2</tt> sind jetzt
nicht einfach vom Typ <tt>Box</tt>, sondern vom 
Typ <tt>Box&lt;String&gt;</tt> respektive <tt>Box&lt;Integer&gt;</tt>. <p/>


Da wir mit generischen Typen keine Typzusicherungen mehr vorzunehmen brauchen,
bekommen wir auch keine dynamischen Typfehler mehr. Der Laufzeitfehler, wie
wir ihn ohne die generische Box hatten, wird jetzt bereits zur
Übersetzungszeit entdeckt. Hierzu betrachte man das analoge Programm:<code classError = "UseBoxError"
              lang = "java">class UseBoxError{
  public static void main(String [] _){
    Box&lt;<redv>String</redv>&gt; b = new Box&lt;<redv>String</redv>&gt;(<greenv>new Integer(42)</greenv>);
    String s = b.contents;
    System.out.println(s.toUpperCase());
  }
}</code>

Die Übersetzung dieses Programms führt jetzt bereits zu einen statischen
Typfehler: <scode>sep@linux:~/fh/java1.5/examples/src&gt; javac UseBoxError.java
UseBoxError.java:3: cannot find symbol
symbol  : constructor Box(java.lang.Integer)
location: class Box&lt;java.lang.String&gt;
    Box&lt;String&gt; b = new Box&lt;String&gt;(new Integer(42));
                    ^
1 error
sep@linux:~/fh/java1.5/examples/src&gt;</scode><subsubsection titel = "Vererbung">
Generische Typen sind ein Konzept, das orthogonal zur Objektorientierung
ist. Von generischen Klassen lassen sich in gewohnter Weise Unterklassen
definieren. Diese Unterklassen können, aber müssen nicht selbst generische
Klassen sein. So können wir unsere einfache Schachtelklasse erweitern, so daß
wir zwei Objekte speichern können:
 <code class = "GPair"
                lang = "java">class <redv>GPair&lt;at,bt&gt;</redv> extends <redv>Box&lt;at&gt;</redv>{
  GPair(at x,bt y){
    super(x);
    snd = y; 
  }

  bt snd;

  public String toString(){
    return &quot;(&quot;+contents+&quot;,&quot;+snd+&quot;)&quot;;
  }
}</code>


Die Klasse <tt>GPair</tt> hat zwei Typvariablen. Instanzen 
von <tt>GPair</tt> müssen angeben von welchem Typ die beiden 
zu speichernden Objekte sein sollen. <code class = "UsePair"
                lang = "java">class UsePair{
  public static void main(String [] _){
    GPair<redv>&lt;String,Integer&gt;</redv> p
     = new GPair<redv>&lt;String,Integer&gt;</redv>(&quot;hallo&quot;,new  Integer(40));
    
    System.out.println(p);
    System.out.println(p.contents.toUpperCase());
    System.out.println(p.snd.intValue()+2);
  }
}</code>

Wie man sieht kommen wir wieder ohne Typzusicherung aus. Es gibt keinen
dynamischen Typcheck, der im Zweifelsfall zu einer Ausnahme führen könnte. <scode>sep@linux:~/fh/java1.5/examples/classes&gt; java UsePair
(hallo,40)
HALLO
42
sep@linux:~/fh/java1.5/examples/classes&gt;</scode>

Wir können auch eine Unterklasse bilden, indem wir mehrere Typvariablen
zusammenfassen. Wenn wir uniforme Paare haben wollen, die zwei Objekte
gleichen Typs speichern, können wir hierfür eine spezielle Paarklasse
definieren. <code class = "UniPair"
                lang = "java">class <redv>UniPair&lt;at&gt;</redv> extends <redv>GPair&lt;at,at&gt;</redv>{
  UniPair(at x,at y){super(x,y);}
  void swap(){
    final at z = snd;
    snd = contents;
    contents = z;
  }
}</code>

Da beide gespeicherten Objekte jeweils vom gleichen Typ sind, konnten wir
jetzt eine
Methode schreiben, in der diese beiden Objekte ihren Platz tauschen. Wie man
sieht, sind Typvariablen ebenso wie unsere bisherigen Typen zu benutzen. Sie
können als Typ für lokale Variablen oder Parameter genutzt werden.<code class = "UseUniPair"
                lang = "java">class UseUniPair{
  public static void main(String [] _){
    UniPair<redv>&lt;String&gt;</redv> p
     = new UniPair<redv>&lt;String&gt;</redv>(&quot;welt&quot;,&quot;hallo&quot;);
    
    System.out.println(p);
    p.swap();
    System.out.println(p);
  }
}</code>
 
Wie man bei der Benutzung der uniformen Paare sieht, gibt man jetzt natürlich
nur noch einen konkreten Typ für die Typvariablen an. Die 
Klasse <tt>UniPair</tt> hat ja nur  eine Typvariable.<scode>sep@linux:~/fh/java1.5/examples/classes&gt; java UseUniPair
(welt,hallo)
(hallo,welt)
sep@linux:~/fh/java1.5/examples/classes&gt;</scode>


Wir können aber auch Unterklassen einer generischen Klasse bilden, die nicht
mehr generisch ist. Dann leiten wir für eine ganz spezifische Instanz der
Oberklasse ab. So läßt sich z.B.<w/> die Klasse <tt>Box</tt> zu einer Klasse
erweitern, in der nur noch Stringobjekte verpackt werden können:<code class = "StringBox"
                lang = "java">class StringBox extends <redv>Box&lt;String&gt;</redv>{
  StringBox(String x){super(x);}
}</code>


Diese Klasse kann nun vollkommen ohne spitze Klammern benutzt werden:<code class = "UseStringBox"
                lang = "java">class UseStringBox{
  public static void main(String [] _){
    StringBox b = new StringBox(&quot;hallo&quot;);
    System.out.println(b.contents.length());
  }
}</code></subsubsection><subsubsection titel = "Einschränken der Typvariablen">
Bisher standen in allen Beispielen die Typvariablen einer generischen Klasse
für jeden beliebigen Objekttypen.  Hier erlaubt Java uns, Einschränkungen zu
machen. Es kann eingeschränkt werden, daß eine Typvariable nicht für alle
Typen ersetzt werden darf, sondern nur für bestimmte Typen. <p/>

Versuchen wir einmal, eine Klasse zu schreiben, die auch wieder der 
Klasse <tt>Box</tt> entspricht, zusätzlich aber eine <tt>set</tt>-Methode hat
und nur den neuen Wert in das entsprechende Objekt speichert, wenn es größer
ist als das bereits gespeicherte Objekt. Hierzu müssen die zu speichernden
Objekte in einer Ordnungsrelation vergleichbar sein, was in Java über die
Implementierung der Schnittstelle <tt>Comparable</tt> ausgedrückt wird. 
Im herkömmlichen Java
würden wir die Klasse wie folgt schreiben:<code class = "CollectMaxOld"
                lang = "java">class CollectMaxOld{
  private <redv>Comparable</redv> value;

  CollectMaxOld(<redv>Comparable</redv> x){value=x;}

  void setValue(<redv>Comparable</redv> x){
    if (value.compareTo(x)&lt;0) value=x;
  }

  <redv>Comparable</redv> getValue(){return value;}
}</code>

Die Klasse <tt>CollectMaxOld</tt> ist in der Lage, beliebige Objekte, die die
Schnittstelle <tt>Comparable</tt> implementieren, zu speichern. Wir haben
wieder dasselbe Problem wie in der Klasse <tt>OldBox</tt>: Greifen wir auf das
gespeicherte Objekt mit der Methode <tt>getValue</tt> erneut zu, wissen wir
nicht mehr den genauen Typ dieses Objekts und müssen eventuell eine dynamische
Typzusicherung durchführen, die zu Laufzeitfehlern führen kann. <p/>

Javas generische Typen können dieses Problem beheben. In gleicher Weise, wie
wir die Klasse <tt>Box</tt> aus der Klasse <tt>OldBox</tt> erhalten haben,
indem wir den allgemeinen Typ <tt>Object</tt> durch eine Typvariable ersetzt
haben, ersetzen wir jetzt den Typ <tt>Comparable</tt> durch eine Typvariable,
geben aber zusätzlich an, daß diese Variable für alle Typen steht, die die
Untertypen der Schnittstelle <tt>Comparable</tt> sind. Dieses wird durch eine
zusätzliche <tt>extends</tt>-Klausel für die Typvariable angegeben. Wir
erhalten somit eine generische Klasse <tt>CollectMax</tt>:<code class = "CollectMax"
                lang = "java">class CollectMax &lt;<redv>elementType</redv> extends <bluev>Comparable</bluev>&gt;{
  private <redv>elementType</redv> value;

  CollectMax(<redv>elementType</redv> x){value=x;}

  void setValue(<redv>elementType</redv> x){
    if (value.compareTo(x)&lt;0) value=x;
  }

  <redv>elementType</redv> getValue(){return value;}
}</code>

Für die Benutzung diese Klasse ist jetzt für jede konkrete Instanz der
konkrete Typ des gespeicherten Objekts anzugeben. Die 
Methode <tt>getValue</tt> liefert als Rückgabetyp nicht ein allgemeines Objekt
des Typs <tt>Comparable</tt>, sondern exakt ein Objekt des Instanzstyps. <code class = "UseCollectMax"
                lang = "java">class UseCollectMax {
  public static void main(String [] _){
    CollectMax<redv>&lt;String&gt;</redv> cm = new CollectMax<redv>&lt;String&gt;</redv>(&quot;Brecht&quot;);
    cm.setValue(&quot;Calderon&quot;);
    cm.setValue(&quot;Horvath&quot;);
    cm.setValue(&quot;Shakespeare&quot;);
    cm.setValue(&quot;Schimmelpfennig&quot;);
    System.out.println(cm.getValue().toUpperCase());
  }
}</code>
Wie man in der letzten Zeile sieht, entfällt wieder die dynamische
Typzusicherung. </subsubsection></subsection><subsection titel = "Generische Schnittstellen">
Generische Typen erlauben es, den Typ <tt>Object</tt> in Typsignaturen zu
eleminieren. Der Typ <tt>Object</tt> ist als schlecht anzusehen, denn er ist
gleichbedeutend damit, daß keine Information über einen konkreten Typ während
der Übersetzungszeit zur Verfügung steht. Im herkömmlichen Java ist in APIs
von Bibliotheken der Typ <tt>Object</tt> allgegenwärtig. Sogar in der 
Klasse <tt>Object</tt>  selbst begegnet er uns in Signaturen. Die 
Methode <tt>equals</tt> hat einen Parameter vom Typ <tt>Object</tt>, 
d.h.<w/>prinzipiell kann ein Objekt mit Objekten jeden beliebigen Typs
verglichen werden. Zumeist will man aber nur gleiche Typen miteinander
vergleichen. In diesem Abschnitt werden wir sehen, daß generische Typen es uns
erlauben, allgemein eine Gleichheitsmethode zu definieren, in der nur Objekte
gleichen Typs miteinander verglichen werden können. Hierzu werden wir eine
generische Schnittstelle definieren.<p/>


 
Generische Typen erweitern sich ohne Umstände auf Schnittstellen. Im Vergleich
zu generischen Klassen ist nichts Neues zu lernen. Syntax und Benutzung
funktionieren auf die gleiche Weise.<subsubsection titel = "Äpfel mit Birnen vergleichen">
Um zu realisieren, daß nur noch Objekte gleichen Typs miteinander verglichen
werden können, definieren wir eine Gleichheitsschnitstelle. In ihr wird eine
Methode spezifiziert, die für die Gleichheit stehen soll.  Die Schnittstelle 
ist
generisch über den Typen, mit dem vergleichen werden soll.<code class = "EQ"
                lang = "java">interface EQ&lt;<redv>otherType</redv>&gt; {
  public boolean eq(<redv>otherType</redv> other);
}</code>

Jetzt können wir für jede Klasse nicht nur bestimmen, daß sie
die Gleichheit 
implementieren soll, sondern auch, mit welchen Typen Objekte unserer Klasse
verglichen werden sollen. Schreiben wir hierzu eine Klasse <tt>Apfel</tt>. Die
Klasse Apfel soll die Gleichheit auf sich selbst implementieren. Wir wollen
nur Äpfel mit Äpfeln vergleichen können. Daher definieren wir in 
der <tt>implements</tt>-Klausel, daß 
wir <tt>EQ&lt;Apfel&gt;</tt> implementieren wollen. Dann müssen wir auch die
Methode <tt>eq</tt> implementieren, und zwar mit dem Typ <tt>Apfel</tt> als
Parametertyp:<code class = "Apfel"
                lang = "java">class Apfel implements <redv>EQ&lt;Apfel&gt;</redv>{
  String typ;

  Apfel(String typ){
    this.typ=typ;}

  public boolean eq(<redv>Apfel</redv> other){
    return this.typ.equals(other.typ); 
  }    
}</code>

Jetzt können wir Äpfel mit Äpfeln vergleichen:<code class = "TestEQ"
                lang = "java">class TestEq{
  public static void main(String []_){
    Apfel a1 = new Apfel(&quot;Golden Delicious&quot;);
    Apfel a2 = new Apfel(&quot;Macintosh&quot;);
    System.out.println(a1.eq(a2));
    System.out.println(a1.eq(a1));
  }
}</code>

Schreiben wir als nächstes eine Klasse die Birnen darstellen soll. Auch diese
implementiere die Schnittstelle <tt>EQ</tt>, und zwar dieses Mal für Birnen:<code class = "Birne"
                lang = "java">class Birne implements EQ&lt;<redv>Birne</redv>&gt;{
  String typ;

  Birne(String typ){
    this.typ=typ;}

  public boolean eq(<redv>Birne</redv> other){
    return this.typ.equals(other.typ); 
  }    
}</code>

Während des statischen Typchecks wird überprüft, ob wir nur Äpfel mit Äpfeln
und Birnen mit Birnen vergleichen. Der Versuch, Äpfel mit Birnen zu
vergleichen, führt zu einem Typfehler:<code classError = "TestEQError"
                lang = "java">class TesteEqError{
  public static void main(String []_){
    Apfel a = new Apfel(&quot;Golden Delicious&quot;);
    Birne b = new Birne(&quot;williams&quot;);
    System.out.println(a.equals(b));
    System.out.println(<redv>a.eq(b)</redv>);
  }
}</code>

Wir bekommen die verständliche Fehlermeldung, daß die Gleichheit auf Äpfel
nicht für einen Birnenparameter aufgerufen werden kann.<scode>./TestEQError.java:6: eq(Apfel) in Apfel cannot be applied to (Birne)
    System.out.println(a.eq(b));
                        ^
1 error</scode>

Wahrscheinlich ist es jedem erfahrenden Javaprogrammierer schon einmal
passiert, daß er zwei Objekte verglichen hat, die er gar nicht vergleichen
wollte. Da der statische Typcheck solche Fehler nicht erkennen kann, denn die
Methode <tt>equals</tt> läßt jedes Objekt als Parameter zu, sind solche Fehler
mitunter schwer zu lokalisieren.<p/>

Der statische Typcheck stellt auch sicher, daß eine generische Schnittstelle
mit der korrekten Signatur implementiert wird. Der Versuch, eine Birneklasse zu
schreiben, die eine Gleichheit mit Äpfeln implementieren soll, dann aber die
Methode <tt>eq</tt> mit dem Parametertyp <tt>Birne</tt> zu
implementieren, führt ebenfalls zu einer Fehlermeldung:<code classError = "BirneError"
                lang = "java">class BirneError implements EQ&lt;<redv>Apfel</redv>&gt;{
  String typ;

  BirneError(String typ){
    this.typ=typ;}

  public boolean eq(<redv>Birne</redv> other){
    return this.typ.equals(other.typ); 
  }    
}</code>

Wir bekommen folgende Fehlermeldung:<scode>sep@linux:~/fh/java1.5/examples/src&gt; javac BirneError.java
BirneError.java:1: BirneError is not abstract and does not override abstract method eq(Apfel) in EQ
class BirneError implements EQ&lt;Apfel&gt;{
^
1 error
sep@linux:~/fh/java1.5/examples/src&gt;</scode></subsubsection></subsection><subsection titel = "Kovarianz gegen Kontravarianz">
Gegeben seien zwei Typen <tt>A</tt> und <tt>B</tt>. Der Typ <tt>A</tt> soll
Untertyp des Typs <tt>B</tt> sein, also entweder ist <tt>A</tt> eine
Unterklasse der Klasse <tt>B</tt> oder <tt>A</tt> implementiert die
Schnittstelle <tt>B</tt> oder die Schnittstelle <tt>A</tt> erweitert die
Schnittstelle <tt>B</tt>. Für diese Subtyprelation schreiben wir das
Relationssymbol <m>\sqsubseteq</m>. Es gelte also <m>A \sqsubseteq B</m>. Gilt
damit auch für einen generischen Typ <tt>C</tt>: <tt>C&lt;A&gt;</tt><m>\sqsubseteq</m><tt>C&lt;B&gt;</tt>?<p/>

Man mag geneigt sein, zu sagen ja. Probieren wir dieses einmal aus:<code classError = "Kontra"
              lang = "java">class Kontra{
  public static void main(String []_){
    Box&lt;<redv>Object</redv>&gt; b  = new Box&lt;<redv>String</redv>&gt;(&quot;hello&quot;);
  }
}</code>

Der Javaübersetzer weist dieses Programm zurück: <scode>sep@linux:~/fh/java1.5/examples/src&gt; javac Kontra.java
Kontra.java:4: incompatible types
found   : Box&lt;java.lang.String&gt;
required: Box&lt;java.lang.Object&gt;
    Box&lt;Object&gt; b  = new Box&lt;String&gt;(&quot;hello&quot;);
                     ^
1 error
sep@linux:~/fh/java1.5/examples/src&gt;</scode>
Eine <tt>Box&lt;String&gt;</tt> ist keine <tt>Box&lt;Object&gt;</tt>. Der
Grund für diese Entwurfsentscheidung liegt darin, daß bestimmte
Laufzeitfehler vermieden werden sollen. Betrachtet man ein Objekt des 
Typs <tt>Box&lt;String&gt;</tt>  über eine Referenz des 
Typs <tt>Box&lt;Object&gt;</tt>, dann können in dem 
Feld <tt>contents</tt> beliebige  Objekte gespeichert werden. Die Referenz
über den Typ <tt>Box&lt;String&gt;</tt> geht aber davon aus, daß 
in <tt>contents</tt> nur Stringobjekte gespeichert werden.<p/>
Man vergegenwärtige sich nochmals, daß Reihungen in Java sich hier
anders verhalten. Bei Reihungen ist die entsprechende Zuweisung erlaubt. Eine
Reihung von Stringobjekten darf einer Reihung beliebiger Objekte zugewiesen
werden. Dann kann es bei der Benutzung der Reihung von Objekten zu einen
Laufzeitfehler kommen.<code class = "Ko"
              lang = "java">class Ko{
  public static void main(String []_){
    String [] x = {&quot;hello&quot;};
    Object [] b  = x;
    b[0]=new Integer(42);
    x[0].toUpperCase();
  }
}</code>

Das obige Programm führt zu folgendem Laufzeitfehler:<scode>sep@linux:~/fh/java1.5/examples/classes&gt; java Ko
Exception in thread &quot;main&quot; java.lang.ArrayStoreException
        at Ko.main(Ko.java:5)
sep@linux:~/fh/java1.5/examples/classes&gt;</scode>

Für generische Typen wurde ein solcher Fehler durch die Strenge des statischen
Typchecks bereits ausgeschlossen.</subsection><subsection titel = "Sammlungsklassen">
Die Paradeanwendung für generische Typen sind natürlich Sammlungsklassen, also
die Klassen für Listen und Mengen, wie sie im 
Paket <tt>java.util</tt> definiert sind. Mit der Version 1.5 von Java finden
sich generische Versionen der bekannten Sammlungsklassen. Jetzt kann man
angeben, was für einen Typ die Elemente einer Sammlung genau haben sollen.<code class = "ListTest"
              lang = "java">import java.util.*;
import java.util.List;
class ListTest{
  public static void main(String [] _){
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add(&quot;Schimmelpfennig&quot;);
    xs.add(&quot;Shakespeare&quot;);
    xs.add(&quot;Horvath&quot;);
    xs.add(&quot;Brecht&quot;);
    String x2 = xs.get(1);
    System.out.println(xs);
  }
}</code>

Aus Kompatibilitätsgründen mit bestehendem Code können generische Klassen
auch weiterhin ohne konkrete Angabe des Typparameters benutzt werden. Während
der Übersetzung wird in diesen Fällen eine Warnung ausgegeben.<code class = "WarnList"
              lang = "java">import java.util.*;
import java.util.List;
class WarnTest{
  public static void main(String [] _){
    <redv>List xs</redv> = new ArrayList&lt;String&gt;();
    xs.add(&quot;Schimmelpfennig&quot;);
    xs.add(&quot;Shakespeare&quot;);
    xs.add(&quot;Horvath&quot;);
    xs.add(&quot;Brecht&quot;);
    String x2 = <redv>(String)</redv>xs.get(1);
    System.out.println(xs);
  }
}</code>

Obiges Programm übersetzt mit folgender Warnung:<scode>sep@linux:~/fh/java1.5/examples/src&gt; javac WarnList.java
Note: WarnList.java uses unchecked or unsafe operations.
Note: Recompile with -warnunchecked for details.
sep@linux:~/fh/java1.5/examples/src&gt;</scode></subsection><subsection titel = "Generische Methoden">
Bisher haben wir generische Typen für Klassen und Schnittstellen
betrachtet. Generische Typen sind aber nicht an einen objektorientierten
Kontext gebunden, sondern basieren ganz im Gegenteil auf dem
Milner-Typsystem, das funktionale Sprachen, die nicht objektorientiert sind,
benutzen. In Java verläßt man den objektorientierten Kontext  in statischen
Methoden. Statische Methoden sind nicht an ein Objekt gebunden. Auch statische
Methoden lassen sich generisch in Java definieren. Hierzu ist vor der
Methodensignatur in spitzen Klammern eine Liste der für die statische Methode
benutzten Typvariablen anzugeben.<p/>


Eine sehr einfache statische generische Methode ist 
eine <em>trace</em>-Methode, die ein beliebiges Objekt erhält, dieses Objekt
auf der Konsole ausgibt und als Ergebnis genau das erhaltene Objekt
unverändert wieder zurückgibt. Diese Methode <tt>trace</tt> hat für alle Typen
den gleichen Code und kann daher entsprechend generisch geschrieben werden:   <code class = "Trace"
              lang = "java">class Trace {

  static <redv>&lt;elementType&gt;</redv>  elementType trace(elementType x){
    System.out.println(x);
    return x;
  }
  
  public static void main(String [] _){
    String x = trace ((trace (&quot;hallo&quot;)
                      +trace( &quot; welt&quot;)).toUpperCase());

    Integer y = trace (new Integer(40+2));
  }
}</code>
In diesem Beispiel ist zu erkennen, daß der Typchecker eine kleine Typinferenz
  vornimmt. Bei der Anwendung der Methode <tt>trace</tt> ist nicht anzugeben,
  mit welchen Typ die Typvariable <tt>elementType</tt> zu instanziieren
  ist. Diese Information inferriert der Typchecker automatisch aus dem Typ des Arguments.</subsection></section>
    <section titel = "Iteration">
Typischer Weise wird in einem Programm über die Elemente eines Sammlungstyp
iteriert oder über alle Elemente einer Reihung. Hierzu kennt Java verschiedene
Schleifenkonstrukte. Leider kannte Java bisher kein eigenes
Schleifenkonstrukt, das bequem eine Iteration über die Elemente einer Sammlung
ausdrücken konnte. Die Schleifensteuerung mußte bisher immer explizit
ausprogrammiert werden. Hierbei können Programmierfehler auftreten, die
insbesondere dazu führen können, daß eine Schleife nicht terminiert. Ein
Schleifenkonstrukt, das garantiert terminiert, kannte Java bisher nicht.<p/><example>
In diesen Beispiel finden sich die zwei wahrscheinlich am häufigsten
programmierten Schleifentypen. Einmal iterieren wir über alle Elemente einer
Reihung und einmal iterieren wir mittels eines Iteratorobjekts über alle
Elemente eines Sammlungsobjekts:<code class = "OldIteration"
              lang = "java">import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

class OldIteration{

  public static void main(String [] _){
    String [] ar
      = {&quot;Brecht&quot;,&quot;Horvath&quot;,&quot;Shakespeare&quot;,&quot;Schimmelpfennig&quot;};
    List xs = new ArrayList();

    for (<redv>int i= 0</redv>;<redv>i</redv>&lt;ar.length;<redv>i++</redv>){
      final String s = <redv>ar[i]</redv>;
      xs.add(s);
    }  
 
    for (<redv>Iterator it=xs.iterator()</redv>;<redv>it.hasNext()</redv>;){
      final String s = <redv>(String)it.next()</redv>;
      System.out.println(s.toUpperCase());
    }
  }
}</code>
Die Codemenge zur Schleifensteuerung ist gewaltig und übersteigt hier sogar die
eigentliche Anwendungslogik.</example>


Mit Java 1.5 gibt es endlich eine Möglichkeit, zu sagen, mache für alle
Elemente im nachfolgenden Sammlungsobjekt etwas. Eine solche Syntax ist jetzt
in Java integriert. Sie hat die Form:<center>
        <fbox><ttt>for (</ttt><em>Type</em><w/><em>identifier</em> : <em>expr</em><ttt>)<lpar/></ttt><em>body</em><ttt>
            <rpar/>
          </ttt></fbox>
      </center>

Zu lesen ist dieses Kosntrukt als: für jedes <em>identifier</em> des 
Typs <em>Type</em> in <em>expr</em> führe <em>body</em> aus.<footnote>Ein noch sprechenderes Konstrukt wäre gewesen, wenn man statt des
Doppelpunkts das Schlüsselwort <ttt>in</ttt> benutzt hätte. Aus
Aufwärtskompatibilitätsgründen wird  jedoch darauf verzichtet, neue
Schlüsselwörter in Java einzuführen.</footnote><example>
Damit lassen sich jetzt die Iterationen der letzten beiden Schleifen
wesentlich eleganter ausdrücken. <code class = "NewIteration"
              lang = "java">import java.util.List;
import java.util.ArrayList;

class NewIteration{

  public static void main(String [] _){
    String [] ar
     = {&quot;Brecht&quot;,&quot;Horvath&quot;,&quot;Shakespeare&quot;,&quot;Schimmelpfennig&quot;};
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();

    for (<redv>String s:ar</redv>) xs.add(s); 
    for (<redv>String s:xs</redv>) System.out.println(s.toUpperCase());
  }
}</code>
Der gesamte Code zur Schleifensteuerung ist entfallen. Zusätzlich ist
    garantiert, daß für endliche Sammlungsiteratoren auch die Schleife
    terminiert. </example>


Wie man sieht, ergänzen sich generische Typen und die 
neue <tt>for</tt>-Schleife.<subsection titel = "Die neuen Schnittstellen Iterable">
        <example>
          <code class = "ReaderIterator"
                lang = "java">package sep.util.io;

import java.io.Reader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Iterator;


public class ReaderIterator 
              implements Iterable&lt;Character&gt;
                        ,Iterator&lt;Character&gt;{
  private Reader reader;
  private int n;
  public ReaderIterator(Reader r){
    reader=new BufferedReader(r);
    try{n=reader.read();
    }catch(IOException _){n=-1;}
  }
  public Character next(){
    Character result = new Character((char)n);   
    try{n=reader.read();
    }catch(IOException _){n=-1;}
    return result;
  }

  public boolean hasNext(){
    return n!=-1;
  }

  public void remove(){
    throw new UnsupportedOperationException();
  }

  public Iterator&lt;Character&gt; iterator(){return this;}
}</code>
          <code class = "TestReaderIterator"
                lang = "java">import sep.util.io.ReaderIterator;
import java.io.FileReader;

class TestReaderIterator {
  public static void main(String [] args) throws Exception{
      Iterable&lt;Character&gt; it
        =new ReaderIterator(new FileReader(args[0]));
      for (Character c:it){
      System.out.print(c);
    }
  }
}</code>
        </example>
      </subsection><example>
Ein abschließendes kleines Beispiel für generische Sammlungsklassen und die
neue <tt>for</tt>-Schleife. Die folgende Klasse stellt Methoden zur Verfügung,
um einen String in eine Liste von Wörtern zu spalten und umgekehrt aus einer
Liste von Wörtern wieder einen String zu bilden:<code class = "TextUtils"
              lang = "java">import java.util.*;
import java.util.List;

class TextUtils {

  static List&lt;String&gt; words (String s){
    final List&lt;String&gt; result = new ArrayList&lt;String&gt;();

    StringBuffer currentWord = new StringBuffer();

    for (char c:s.toCharArray()){
      if (Character.isWhitespace(c)){
        final String newWord = currentWord.toString().trim();
        if(newWord.length()&gt;0){
          result.add(newWord);
          currentWord=new StringBuffer();
        }
      }else{currentWord.append(c);} 
    }
    return result;
  }

  static String unwords(List&lt;String&gt; xs){
    StringBuffer result=new StringBuffer();
    for (String x:xs) result.append(&quot; &quot;+x);
    return result.toString().trim();
  }

  public static void main(String []_){
    List&lt;String&gt; xs = words(&quot;  the   world  is my Oyster  &quot;);

    for (String x:xs) System.out.println(x);

    System.out.println(unwords(xs));
  }
}</code></example></section>
  </kapitel>
  <kapitel titel = "Datentypen und Algorithmen">

Die bisher kennengelernten Javakonstrukte bilden einen soliden Kern,
der genügend programmiertechnische Mittel zur Verfügung stellt, um die gängigsten Konzepte der Informatik umzusetzen. In diesem Kapitel
werden wir keine neuen Javakonstrukte kennenlernen, sondern mit den bisher bekannten Mitteln die häufigsten in der Informatik gebräuchlichen Datentypen und auf ihnen anzuwendende Algorithmen
erkunden. <section titel = "Listen">

Eine der häufigsten Datenstrukturen in der Programmierung sind
Sammlungstypen. In fast jedem nichttrivialen Programm wird es Punkte
geben, an denen eine Sammlung mehrerer Daten gleichen Typs anzulegen
sind. Eine der einfachsten Strukturen, um Sammlungen anzulegen, sind
Listen. Da Sammlungstypen oft gebraucht werden, stellt Java
entsprechende Klassen als Standardklassen zur Verfügung. Bevor wir uns
aber diesen bereits vorhandenen Klassen zuwenden, wollen wir in 
diesem Kapitel Listen selbst
spezifizieren und programmieren.<subsection titel = "Formale Spezifikation">
Wir werden Listen als abstrakten Datentyp formal spezifizieren. Ein abstrakter
Datentyp (ADT) wird spezifiziert über eine endliche Menge von Methoden. 
Hierzu wird
spezifiziert, auf welche Weise Daten eines ADT konstruiert werden
können. Dazu werden entsprechende Konstruktormethoden spezifiziert. Dann
wird eine Menge von Funktionen definiert, die wieder Teile aus den
konstruierten Daten selektieren können. Schließlich werden noch Testmethoden
spezifiziert, die angeben, mit welchem Konstruktor ein Datum erzeugt
wurde.<p/> Der Zusammenhang zwischen Konstruktoren und Selektoren sowie zwischen den
Konstruktoren und den Testmethoden wird in Form von Gleichungen spezifiziert.<p/>
Der Trick, der angewendet wird, um abstrakte Datentypen wie Listen zu
spezifizieren, ist  die Rekursion. Das Hinzufügen eines weiteren
Elements zu einer Liste wird dabei als das Konstruieren einer neuen Liste aus der Ursprungsliste und einem weiteren Element
betrachtet. Mit dieser Betrachtungsweise haben Listen eine rekursive Struktur: eine Liste besteht aus dem zuletzt vorne angehängten neuen
Element, dem sogenannten Kopf der Liste, und aus der alten Teilliste,
an die dieses Element angehängt wurde, dem sogenannten Schwanz der  Liste. Wie bei jeder rekursiven Struktur bedarf es eines Anfangs der
Definition. Im Falle von Listen wird dieses durch die Konstruktion einer leeren Liste spezifiziert.<footnote>Man vergleiche es mit der Definition der natürlichen Zahlen: die <m>0</m>  entspricht der leeren
Liste, der Schritt von <m>n</m> nach <m>n+1</m> dem Hinzufügen eines neuen
Elements zu einer Liste.</footnote><subsubsection titel = "Konstruktoren"> Abstrakte Datentypen wie Listen lassen sich  durch
ihre Konstruktoren spezifizieren. Die
Konstruktoren geben an, wie Daten des entsprechenden Typs konstruiert
werden können.
In dem Fall von Listen bedarf es nach
den obigen Überlegungen zweier Konstruktoren:<itemize>
            <item> einem Konstruktor für neue Listen, die noch leer sind.</item>
            <item> einem Konstruktor, der aus einem Element und einer bereits
bestehenden Liste eine neue Liste konstruiert, indem an  die
Ursprungsliste das Element angehängt wird.</item>
          </itemize>

Wir benutzen in der Spezifikation eine mathematische Notation der
Typen von Konstruktoren.<footnote>Entgegen der Notation in Java, in der
der Rückgabetyp kurioser Weise vor den Namen der Methode geschrieben
wird.</footnote> Dem Namen des Konstruktors folgt dabei mit einem
Doppelpunkt abgetrennt der Typ. Der Ergebnistyp wird von den
Parametertypen mit einem Pfeil getrennt.

Somit lassen sich die Typen der zwei Konstruktoren für Listen wie
folgt spezifizieren:<itemize>
            <item>Empty: () <rightarrow/><b>List</b></item>
            <item>Cons: (<b>Object</b>,<b>List</b>) <rightarrow/><b>List</b></item>
          </itemize></subsubsection><subsubsection titel = "Selektoren">

Die Selektoren können wieder auf die einzelnen
Bestandteile der Konstruktion zurückgreifen. 
Der Konstruktor <bf>Cons</bf> hat zwei Parameter. Für <bf>Cons</bf>-Listen 
werden zwei
Selektoren spezifiziert, die jeweils einen dieser beiden Parameter
wieder aus der Liste selektieren. Die Namen dieser beiden Selektoren
sind traditioneller Weise <em>head</em> und <em>tail</em>.<itemize>
            <item>head: <b>(List)</b><rightarrow/><b>Object</b></item>
            <item>tail: <b>(List)</b><rightarrow/><b>List</b></item>
          </itemize> Der funktionale Zusammenhang von  Selektoren und Konstruktoren läßt
sich durch folgende Gleichungen spezifizieren:<p/><eqnarray>
head(Cons(x,xs)) <eq/>x<br/>
tail(Cons(x,xs)) <eq/>xs</eqnarray></subsubsection><subsubsection titel = "Testmethoden">
Um für  Listen Algorithmen umzusetzen, ist es notwendig, unterscheiden
zu können, welche Art der beiden Listen vorliegt: die leere Liste oder
eine <bf>Cons</bf>-Liste. Hierzu bedarf es noch einer Testmethode, die
mit einem bool&#39;schen Wert als Ergebnis angibt, ob es sich bei der
Eingabeliste um die leere Liste handelte oder nicht. Wir wollen diese
Testmethode <em>isEmpty</em> nennen. Sie hat folgenden Typ:<itemize>
            <item>isEmpty: <b>List</b><rightarrow/><b>boolean</b></item>
          </itemize>


Das funktionale Verhalten der Testmethode läßt sich durch folgende
zwei Gleichungen spezifizieren:<eqnarray>
isEmpty(Empty()) <eq/> true<br/>
isEmpty(Cons(x,xs)) <eq/> false</eqnarray>

Somit ist alles spezifiziert, was eine Listenstruktur ausmacht. Listen
können konstruiert werden, die Bestandteile einer Liste wieder einzeln selektiert  und Listen können nach der Art ihrer Konstruktion
unterschieden werden. </subsubsection><subsubsection titel = "Listenalgorithmen"> Allein diese fünf Funktionen beschreiben den ADT der
Listen. Wir können aufgrund dieser Spezifikation Algorithmen für Listen
schreiben.<paragraph titel = "Länge">
Und ebenso läßt sich durch zwei Gleichungen spezifizieren, was die Länge einer
Liste ist:<eqnarray>
length(Empty())<eq/>0<br/>
length(Cons(x,xs))<eq/>1+length(xs)</eqnarray>


Mit Hilfe dieser Gleichungen läßt sich jetzt schrittweise die Berechnung einer Listenlänge auf Listen durchführen. Hierzu benutzen wir die Gleichungen als Ersetzungsregeln. Wenn ein Unterausdruck in der Form der linken Seite 
einer Gleichung gefunden wird, so kann diese durch die entsprechende rechte Seite ersetzt werden. Man spricht bei so einem Ersetzungsschritt von einem
Reduktionsschritt.<example> Wir errechnen in diesem Beispiel die Länge einer Liste, indem wir die obigen
Gleichungen zum Reduzieren auf die Liste anwenden:<eqnarray><amp/><amp/><red>length(<mb>Cons</mb>(a,<mb>Cons</mb>(b,<mb>Cons</mb>(c,<mb>Empty</mb>()))))</red><br/><reduce/>1+<red>length(<mb>Cons</mb>(b,<mb>Cons</mb>(c,<mb>Empty</mb>())))</red><br/><reduce/>1+(1+<red>length(<mb>Cons</mb>(c,<mb>Empty</mb>()))</red>)<br/><reduce/>1+(1+(1+<red>length(<mb>Empty</mb>())</red>))<br/><reduce/>1+(1+(<red>1+0</red>))<br/><reduce/>1+(<red>1+1</red>)<br/><reduce/><red>1+2</red><br/><reduce/>3</eqnarray></example></paragraph> <paragraph titel = "Letztes Listenelement">
Wir können mit einfachen Gleichungen spezifizieren, was wir unter dem letzten
Element einer Liste verstehen.<eqnarray>
last(Cons(x,Empty())))<eq/> x<br/>
last(Cons(x,xs)))<eq/>last(xs)</eqnarray>

Auch die Funktion <tt>last</tt> können wir von Hand auf einer Beispielliste einmal per Reduktion ausprobieren:<eqnarray><amp/><amp/><red>last(<mb>Cons</mb>(a,<mb>Cons</mb>(b,<mb>Cons</mb>(c,<mb>Empty</mb>()))))</red><br/><reduce/><red>last(<mb>Cons</mb>(b,<mb>Cons</mb>(c,<mb>Empty</mb>())))</red><br/><reduce/><red>last(<mb>Cons</mb>(c,<mb>Empty</mb>()))</red><br/><reduce/>c</eqnarray></paragraph><paragraph titel = "Listenkonkatenation">
Die folgenden Gleichungen spezifizieren, wie zwei Listen aneinandergehängt
werden: <eqnarray>
concat(Empty(),ys)<eq/>ys<br/>
concat(Cons(x,xs),ys)<eq/>Cons(x,concat(xs,ys))</eqnarray> Auch diese Funktion läßt sich beispielhaft mit der Reduktion einmal
durchrechnen: <eqnarray><amp/><amp/><red>concat(<mb>Cons</mb>(i,<mb>Cons</mb>(j,<mb>Empty</mb>())),<mb>Cons</mb>(a,<mb>Cons</mb>(b,<mb>Cons</mb>(c,<mb>Empty</mb>()))))</red><br/><reduce/><mb>Cons</mb>(i,<red>concat(<mb>Cons</mb>(j,<mb>Empty</mb>()),<mb>Cons</mb>(a,<mb>Cons</mb>(b,<mb>Cons</mb>(c,<mb>Empty</mb>()))))</red>)<br/><reduce/><mb>Cons</mb>(i,<mb>Cons</mb>(j,<red>concat(<mb>Empty</mb>(),<mb>Cons</mb>(a,<mb>Cons</mb>(b,<mb>Cons</mb>(c,<mb>Empty</mb>()))))</red>))<br/><reduce/><mb>Cons</mb>(i,<mb>Cons</mb>(j,<mb>Cons</mb>(a,<mb>Cons</mb>(b,<mb>Cons</mb>(c,<mb>Empty</mb>())))))</eqnarray></paragraph></subsubsection> <subsubsection titel = "Schachtel- und Zeiger-Darstellung">
Listen lassen sich auch sehr schön graphisch visualisieren. Hierzu wird jede
Liste durch eine Schachtel mit zwei Feldern dargestellt. Von diesen beiden
Feldern gehen Pfeile aus. Der erste Pfeil zeigt auf das erste Element der
Liste, dem <tt>head</tt>, der zweite Pfeil zeigt auf die Schachtel, die für
den Restliste steht dem <em>tail</em>. Wenn eine Liste leer ist, so gehen keine Pfeile von der Schachtel aus, die sie repräsentiert. <p/>

Die Liste <em>Cons(a,Cons(b,Cons(c,Empty())))</em> hat somit die Schachtel- und Zeigerr- Darstellung aus Abbildung <ref name = "List1"/>.<bild name = "List1"
                pdfscale = "0.5"
                psscale = "0.6"
                caption = "Schachtel Zeiger Darstellung einer dreielementigen Liste."/>  In der Schachtel- und Zeiger-Darstellung läßt sich sehr gut  verfolgen, wie
bestimmte Algorithmen auf Listen dynamisch arbeiten.
Wir können die schrittweise Reduktion der Methode <tt>concat</tt> in der  Schachtel- und Zeiger-Darstellung gut nachvollziehen:<bild name = "Concat1"
                pdfscale = "0.5"
                psscale = "0.6"
                caption = "Schachtel Zeiger Darstellung der Funktionsanwendung von concat auf
zwei Listen."/> 


Abbildung <ref name = "Concat1"/> zeigt die Ausgangssituation. Zwei Listen sind dargestellt. Von einer Schachtel, die wir als die Schachtel der 
Funktionsanwendung
von <tt>concat</tt> markiert haben, gehen zwei Zeiger aus. Der erste auf das erste Argument, der zweite auf das zweite Argument der Funktionsanwendung. <bild name = "Concat2"
                pdfscale = "0.5"
                psscale = "0.6"
                caption = "Schachtel-Zeiger-Darstellung nach dem zweiten Reduktionsschritt."/> 


Abbildung <ref name = "Concat2"/> zeigt die Situation, nachdem die 
Funktion <tt>concat</tt> einmal reduziert wurde. Ein neuer Listenknoten wurde
erzeugt. Dieser zeigt auf das erste Element der ursprünglich 
ersten Argumentliste. Der zweite zeigt auf den rekursiven Aufruf der  Funktion <tt>concat</tt>, diesmal mit der Schwanzliste des ursprünglich ersten Arguments. <bild name = "Concat3"
                pdfscale = "0.5"
                psscale = "0.6"
                caption = "Schachtel-Zeiger-Darstellung nach dem zweiten Reduktionsschritt."/> 

Abbildung <ref name = "Concat3"/> zeigt die Situation nach dem zweiten
Reduktionsschritt. Ein weiterer neuer Listenknoten ist entstanden und ein
neuer Knoten für den rekursiven Aufruf ist entstanden.<bild name = "Concat4"
                pdfscale = "0.5"
                psscale = "0.5"
                caption = "Schachtel Zeiger Darstellung des Ergebnisses nach der Reduktion."/> 

Abbildung <ref name = "Concat4"/> zeigt die endgültige Situation. Der letzte
rekursive Aufruf von <tt>concat</tt> hatte als erstes Argument eine leere Liste. Deshalb wurde kein neuer Listenknoten erzeugt, sondern lediglich der
Knoten für die Funktionsanwendung gelöscht. Man beachte, daß die beiden
ursprünglichen Listen noch vollständig erhalten sind. Sie wurden nicht
gelöscht. Die erste Argumentliste wurde quasi kopiert. Die zweite
Argumentliste teilen sich gewisser Maßen die neue Ergebnisliste der
Funktionsanwendung und die zweite ursprüngliche Argumentliste.</subsubsection></subsection><subsection titel = "Modellierung">
Java kennt keine direkte Unterstützung für ADTs, die nach obigen Prinzip
spezifiziert werden. Es gibt jedoch eine Javaerweiterung 
namens <em>Pizza</em><cite label = "pizza"/>, die eine solche
Unterstützung eingebaut hat. Da wir aber nicht 
auf <em>Pizza</em> zurückgreifen wollen, bleibt uns nichts anderes, als Listen
in Java zu implementieren.<p/> 
Nachdem wir im letzten Abschnitt formal spezifiziert haben, wie Listen
konstruiert werden, wollen wir in diesem Abschnitt betrachten, wie
diese Spezifikation geeignet mit unseren programmiersprachlichen
Mitteln modelliert werden kann, d.h.<white/>wie viele und was für Klassen
werden benötigt. Wir werden in den folgenden zwei Abschnitten zwei
alternative Modellierungen der Listenstruktur angeben.

  <subsubsection titel = "Modellierung als Klassenhierarchie">
Laut Spezifikation gibt es zwei Arten von Listen: leere Listen und
Listen mit einem Kopfelement und einer Schwanzliste. Es ist naheliegend, für diese zwei Arten von Listen je eine eigene Klasse bereitzustellen, jeweils eine Klasse für leere Listen und eine  für <bf>Cons</bf>-Listen. Da beide Klassen zusammen einen Datentyp Liste
bilden sollen, sehen wir eine gemeinsame Oberklasse dieser zwei
Klassen vor. Wir erhalten die Klassenhierarchie in 
Abbildung:<w/><ref name = "List"/>.<bild name = "List"
                pdfscale = "0.6"
                psscale = "0.6"
                caption = "Modellierung von Listen mit drei Klassen."/> 

Wir haben uns in diesem Klassendiagramm dazu entschieden, daß die
Selektormethoden für alle Listen auch für leere Listen zur Verfügung
stehen. Es ist in der formalen Spezifikation nicht angegeben worden,
was in dem Fall der Methoden <em>head</em> und <em>tail</em> auf leere Listen als Ergebnis erwartet wird. Wir können hier Fehler geben oder
aber bestimmte ausgezeichnete Werte als Ergebnis zurückgeben.</subsubsection><subsubsection titel = "In einer Klasse">
Eine alternative Modellierung der Listenstruktur besteht aus nur genau
einer Klasse. Diese Klasse braucht hierzu aber zwei Konstruktoren. Wie in vielen objektorientierten Sprachen ist es in Java auch möglich, für
eine Klasse mehrere Konstruktoren mit unterschiedlichen Parametertypen
zu schreiben. Wir können also eine Klasse <tt>List</tt> modellieren, die zwei Konstruktoren hat: einen mit keinem Parameter und einen mit
zwei Parametern. </subsubsection></subsection><subsection titel = "Codierung">
Die obigen beiden Modellierungen der Listen lassen sich jetzt direkt
in Javacode umsetzen.<subsubsection titel = "Implementierung als Klassenhierarchie"><paragraph titel = "Die Oberklasse List">
Die zusammenfassende Oberklasse der Listenstruktur <tt>List</tt>
stellt für die 
Listenmethoden <tt>head</tt>, <tt>tail</tt> und <tt>isEmpty</tt> jeweils 
eine prototypische Implementierung zur Verfügung. Die 
Methode <tt>isEmpty</tt> setzen wir in unserer Umsetzung standardmäßig
auf <tt>false</tt>. <code lang = "java"
                  class = "List"
                  package = "name/panitz/data/list">package name.panitz.data.list;
class List&lt;a&gt;{
 boolean isEmpty(){return false;}
 a head(){return null;}
 List&lt;a&gt; tail(){return null;}</code>
Die Methoden <tt>tail</tt> und <tt>head</tt> können nur für nichtleere
Listen Objekte zurückgeben. Daher haben wir uns für die prototypischen
Implementierung in der Klasse <tt>List</tt> dazu entschieden, den 
Wert <tt>null</tt> zurückzugeben. <tt>null</tt> steht in Java für das

Fehlen eines Objektes. Der Versuch, auf Felder und Methoden 
von <tt>null</tt> zuzugreifen, führt in Java zu einem Fehler.<p/>
Für die Klasse <tt>List</tt> schreiben wir keinen Konstruktor. Wir
wollen diese Klasse nie direkt instanziieren, d.h.<white/>nie einen
Konstruktor für die Klasse <tt>List</tt> aufrufen.<footnote>In diesem
Fall generiert Java automatisch einen Konstruktor ohne Argumente, doch
dazu mehr an anderer Stelle.</footnote></paragraph><paragraph titel = "Die Klasse Empty"> Die Klasse, die die leere Liste darstellt, ist relativ leicht
abzuleiten. Wir stellen einen Konstruktor zur Verfügung und
überschreiben die Methode <tt>isEmpty</tt>.<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Empty">package name.panitz.data.list;
class Empty&lt;a&gt; extends List&lt;a&gt; {
  Empty(){}  
  boolean isEmpty(){return true;}
}</code></paragraph><paragraph titel = "Die Klasse Cons">
Schließlich ist noch die Klasse <tt>Cons</tt> zu codieren.  Diese
Klasse benötigt nach unserer Modellierung zwei Felder, in denen Kopf
und Schwanz der Liste abgespeichert werden können. 
Die Methoden <tt>head</tt> und <tt>tail</tt> werden so überschrieben,
daß sie entsprechend den Wert eines dieser Felder zurückgeben. Der
Konstruktor initialisiert diese beiden Felder.<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Cons">package name.panitz.data.list;
class Cons&lt;a&gt; extends List&lt;a&gt;{

  a hd;
  List&lt;a&gt; tl ;

  Cons(a x,List&lt;a&gt; xs){
    hd = x;
    tl = xs;
  }

  a head(){
    return hd;
  }

  List&lt;a&gt; tail(){
    return tl;
  }</code></paragraph>

Damit ist die Listenstruktur gemäß unserer formalen Spezifikation
vollständig implementiert. <paragraph titel = "Einfache Tests">
Für Algorithmen auf Listen werden wir nur
die zwei Konstruktoren, die zwei Selektoren und die 
Testmethode <tt>isEmpty</tt> benutzen. Folgendes kleine Testprogramm
konstruiert eine Liste mit drei Elementen des 
Typs <tt>String</tt>. Anschließend folgen einige Tests für die Selektormethoden: <code package = "name/panitz/data/list"
                  lang = "java"
                  class = "TestFirstList">package name.panitz.data.list;
class TestFirstList {
  public static void main(String [] args){

    //<bluev>Konstruktion einer Testliste</bluev>
    List xs = new Cons&lt;String&gt;(&quot;friends&quot;,
              new Cons&lt;String&gt;(&quot;romans&quot;, 
              new Cons&lt;String&gt;(&quot;countrymen&quot;,
              new Empty&lt;String&gt;())));

    //<bluev>Zugriffe auf einzelne Elemente</bluev>
    System.out.println(&quot;1. Element: &quot;+xs.head());
    System.out.println(&quot;2. Element: &quot;+xs.tail().head());
    System.out.println(&quot;3. Element: &quot;+xs.tail().tail().head());
    
    //<bluev>Test für die Methode isEmpty()</bluev>
    if (xs.tail().tail().tail().isEmpty()){
      System.out.println(&quot;leere Liste nach drittem Element.&quot;);
    }

    //<bluev>Ausgabe eines null Wertes</bluev>
    System.out.println(xs.tail().tail().tail().head());
  } 
}</code>

Tatsächlich bekommen wir für unsere Tests die erwartete Ausgabe:<scode>sep@linux:~/fh/prog1/examples/classes&gt; java name.panitz.data.list.TestFirstList
1. Element: friends
2. Element: romans
3. Element: countrymen
leere Liste nach drittem Element.
null
sep@linux:~/fh/prog1/examples/classes&gt;</scode></paragraph></subsubsection><subsubsection titel = "Implementierung als eine Klasse">
In der zweiten Modellierung haben wir auf eine Klassenhierarchie verzichtet. Was wir in der ersten Modellierung durch die verschiedenen Klassen
mit verschieden überschriebenen Methoden ausgedrückt haben, muß in der
Modellierung in einer Klasse über ein bool&#39;sches Feld vom 
Typ <tt>boolean</tt> ausgedrückt werden. 
Die beiden unterschiedlichen
Konstruktoren setzen ein bool&#39;sches Feld <tt>empty</tt>, um 
für das neu konstruierte 
Objekt zu markieren, mit welchem Konstruktor es konstruiert wurde.
Die Konstruktoren setzen entsprechend die Felder, so daß die
Selektoren diese nur auszugeben brauchen.<code package = "name/panitz/data/list"
                lang = "java"
                class = "Li">package name.panitz.data.list;
class Li&lt;a&gt; implements Iterable&lt;a&gt;{
  boolean empty = true;
  a  hd;
  Li&lt;a&gt; tl;
 
  Li(){}

  Li(a x,Li&lt;a&gt; xs){
   hd = x;
   tl = xs;
   empty = false;
  }

  boolean isEmpty() {return empty;}  
  a  head(){return hd;}
  Li&lt;a&gt;      tail(){return tl;}

  public java.util.Iterator&lt;a&gt; iterator(){
    final Li&lt;a&gt;  itout = this;
    return new java.util.Iterator&lt;a&gt;(){
      Li&lt;a&gt;  it = itout;
      public boolean hasNext(){return !it.isEmpty();}
      public a next(){a result=it.head();it=it.tail();return result;}
      public void remove(){throw new UnsupportedOperationException();}
    };
  }  </code>
Zum Testen dieser Listenimplementierung sind nur die
  Konstruktoraufrufe bei der Listenkonstruktion zu ändern. Da wir nur
  noch eine Klasse haben, gibt es keine zwei Konstruktoren mit
  unterschiedlichen Namen, sondern beide haben denselben Namen:<code package = "name/panitz/data/list"
                lang = "java"
                class = "TestFirstLi">
package name.panitz.data.list;
class TestFirstLi {
  public static void main(String [] args){

    //<bluev>Konstruktion einer Testliste</bluev>
    Li&lt;String&gt; xs = new Li&lt;String&gt;(&quot;friends&quot;,
                    new Li&lt;String&gt;(&quot;romans&quot;, 
                    new Li&lt;String&gt;(&quot;countrymen&quot;,
                    new Li&lt;String&gt;())));

    //<bluev>Zugriffe auf einzelne Elemente</bluev>
    System.out.println(&quot;1. Element: &quot;+xs.head());
    System.out.println(&quot;2. Element: &quot;+xs.tail().head());
    System.out.println(&quot;3. Element: &quot;+xs.tail().tail().head());
    
    //<bluev>Test für die Methode isEmpty()</bluev>
    if (xs.tail().tail().tail().isEmpty()){
      System.out.println(&quot;leere Liste nach drittem Element.&quot;);
    }

    //<bluev>Ausgabe eines null Wertes</bluev>
    System.out.println(xs.tail().tail().tail().head());
  }
 
}</code>
Wie man aber sieht, ändert sich an der Benutzung von Listen nichts im
Vergleich zu der Modellierung mittels einer Klassenhierarchie.
Die Ausgabe ist ein und dieselbe für beide Implementierungen:<scode>sep@linux:~/fh/prog1/examples/classes&gt; java TestFirstLi
1. Element: friends
2. Element: romans
3. Element: countrymen
leere Liste nach drittem Element.
null
sep@linux:~/fh/prog1/examples/classes&gt;</scode><paragraph titel = "Konstruktion langer Listen">
Die Konstruktion der dreielementigen Liste oben war schon recht
umständlich. Jede Teilliste mußte explizit durch einen Konstruktoraufruf
generiert werden. Die variable Argumentanzahl für Methoden erlaubt es, einen
Konstruktor zu definieren, der die einzelnen Elemente der zu erzeugenen Liste
als Argumente erhält. <code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Li"
                  sequel = "true">  public Li(a... xs){
    this(0,xs);
  }

  private Li(int i,a... xs){
    if (i&lt;xs.length) {
      empty=false;
      hd=xs[i];
      tl = new Li&lt;a&gt;(i+1,xs);
    }
  }</code>

Jetzt lassen sich bequem auch längere Listen durch einen einzigen
Konstruktoraufruf erzeugen:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "TestFirstLi2">
package name.panitz.data.list;
class TestFirstLi2 {
  public static void main(String [] args){

    //<bluev>Konstruktion einer Testliste</bluev>
    Li&lt;String&gt; xs 
     = new Li&lt;String&gt;
          (&quot;Friends&quot;, &quot;Romans&quot;, &quot;countrymen&quot;, &quot;lend&quot;, &quot;me&quot;,&quot;your&quot;, &quot;ears&quot; 
          ,&quot;I&quot;,&quot;come&quot;,&quot;to&quot;,&quot;bury&quot;,&quot;Caesar&quot;,&quot;not&quot;,&quot;to&quot;,&quot;praise&quot;,&quot;him&quot;);

    //<bluev>Zugriffe auf einzelne Elemente</bluev>
    System.out.println(&quot;1. Element: &quot;+xs.head());
    System.out.println(&quot;2. Element: &quot;+xs.tail().head());
    System.out.println(&quot;3. Element: &quot;+xs.tail().tail().head());
    
    //<bluev>Test für die Methode isEmpty()</bluev>
    if (!xs.tail().tail().tail().isEmpty()){
      System.out.println(&quot;keine leere Liste nach drittem Element.&quot;);
    }

    //<bluev>Ausgabe 4. Wertes</bluev>
    System.out.println(xs.tail().tail().tail().head());
  }
 
}</code></paragraph></subsubsection></subsection><subsection titel = "Methoden für Listen">
Mit der formalen Spezifikation und schließlich Implementierung von
Listen haben wir eine Abstraktionsebene eingeführt. Listen sind für
uns Objekte, für die wir genau die zwei Konstruktormethoden, zwei
Selektormethoden und eine Testmethode zur Verfügung haben. Unter Benutzung dieser fünf Eigenschaften der Listenklasse können wir jetzt
beliebige Algorithmen auf Listen definieren und umsetzen.<subsubsection titel = "Länge">
Eine interessante Frage bezüglich Listen ist die nach ihrer Länge. Wir
können die Länge einer Liste berechnen, indem wir durchzählen, aus wievielen <bf>Cons</bf>-Listen eine Liste besteht. Wir haben bereits die
Funktion <em>length</em> durch folgende zwei Gleichungen spezifiziert.<eqnarray>
length(Empty()) <eq/> 0<br/>
length(Cons(x,xs)) <eq/> 1 + length(xs)</eqnarray>

Diese beiden Gleichungen lassen sich direkt in Javacode umsetzen. 
Die zwei Gleichungen ergeben genau zwei durch eine <tt>if</tt>-Bedingung zu unterscheidende Fälle in der Implementierung. Wir
können die Klassen <tt>List</tt> und <tt>Li</tt> um folgende 
Methode <tt>length</tt> ergänzen:<code package = "name/panitz/data/list"
                lang = "java"
                class = "Li">  int length(){
    if (isEmpty())return 0;
    return 1+tail().length();
  }</code>

In den beiden Testklassen läßt sich ausprobieren, ob die 
Methode <tt>length</tt> entsprechend der Spezifikation
funktioniert. Wir können in der <tt>main</tt>-Methode einen Befehl
einfügen, der die Methode <tt>length</tt> aufruft:<code package = "name/panitz/data/list"
                lang = "java"
                class = "TestLength">package name.panitz.data.list;
class TestLength {
  static  Li&lt;String&gt; XS 
   =  new Li&lt;String&gt;(&quot;friends&quot;
     ,new Li&lt;String&gt;(&quot;romans&quot;
     ,new Li&lt;String&gt;(&quot;countrymen&quot;
     ,new Li&lt;String&gt;())));

  public static void main(String [] args){
    System.out.println(XS.length());
  }
}</code> Und wie wir bereits schon durch Reduktion dieser Methode von Hand ausgerechnet
haben, errechnet die Methode <tt>length</tt> tatsächlich die Elementanzahl der Liste: <scode>sep@linux:~/fh/prog1/examples/classes&gt; java TestLength
3
sep@linux:~/fh/prog1/examples/classes&gt;</scode><paragraph titel = "Alternative Implementierung im Fall der Klassenhierarchie">
Im Fall der Klassenhierarchie können wir auch 
die <tt>if</tt>-Bedingung der Methode <tt>length</tt> dadurch
ausdrücken, daß die beiden Fälle sich in den unterschiedlichen Klassen
für die beiden unterschiedlichen Listenarten befinden. In der 
Klasse <tt>List</tt> kann folgende prototypische Implementierung
eingefügt werden:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "List">  int length(){return 0;} 
}</code>
In der Klasse <tt>Cons</tt>, die ja Listen mit einer Länge größer 0
darstellt, ist dann die Methode entsprechend zu überschreiben:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Cons">  int length(){return 1+tail().length();}
}</code>


Auch diese Längenimplementierung können wir testen:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "TestListLength">package name.panitz.data.list;
class TestListLength {
  static  List&lt;String&gt; XS 
    = new Cons&lt;String&gt;(&quot;friends&quot;
     ,new Cons&lt;String&gt;(&quot;romans&quot;
     ,new Cons&lt;String&gt;(&quot;countrymen&quot;
     ,new Empty&lt;String&gt;())));

  public static void main(String [] args){
    System.out.println(XS.length());
  }
}</code>

An diesem Beispiel ist gut zu sehen, wie durch die Aufsplittung in
verschiedene Unterklassen beim Schreiben von 
Methoden <tt>if</tt>-Abfragen verhindert werden können. Die verschiedenen
Fälle einer <tt>if</tt>-Abfrage  finden sich dann in den
unterschiedlichen Klassen realisiert. Der Algorithmus ist in diesem
Fall auf verschiedene Klassen aufgeteilt. </paragraph><paragraph titel = "Iterative Lösung">
Die beiden obigen Implementierungen der 
Methode <tt>length</tt> sind rekursiv. Im Rumpf der Methode wurde sie
selbst gerade wieder aufgerufen. Natürlich kann die Methode mit den
entsprechenden zusammengesetzten Schleifenbefehlen in Java auch
iterativ gelöst werden. <p/> Wir wollen zunächst versuchen, die Methode mit Hilfe 
einer <tt>while</tt>-Schleife zu realisieren. Der Gedanke ist
naheliegend. Solange es sich noch nicht um die leere Liste handelt,
wird ein Zähler, der die Elemente zählt, hochgezählt:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Li">  int lengthWhile(){
    int erg=0;
    <redv>Li&lt;a&gt; xs = this</redv>;
    while (<redv>!xs.isEmpty()</redv>){
      erg= erg +1;
      <redv>xs = xs.tail();</redv>
    }
    return erg;
  }</code>
Schaut man sich diese Lösung genauer an, so sieht man, daß sie die
  klassischen drei Bestandteile einer <tt>for</tt>-Schleife enthält:<itemize>
              <item>die Initialisierung einer 
Laufvariablen: <tt>List xs = this;</tt></item>
              <item>eine bool&#39;sche Bedingung zur 
Schleifensteuerung: <tt>!xs.isEmpty()</tt></item>
              <item>eine Weiterschaltung der 
Schleifenvariablen: <tt>xs = xs.tail();</tt></item>
            </itemize> Damit ist die Schleife, die über die Elemente einer Liste iteriert, ein
guter Kandidat für eine <tt>for</tt>-Schleife. Wir können das Programm
entsprechend umschreiben:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Li">  int lengthFor(){
    int erg=0;
    for (<redv>Li&lt;a&gt; xs=this;!xs.isEmpty();xs=xs.tail()</redv>){
      erg = erg +1;
    }
    return erg;
  }</code>
Eine Schleifenvariable ist also nicht unbedingt eine Zahl, die hoch
  oder herunter gezählt wird, sondern kann auch ein Objekt sein, von
  dessen Eigenschaften abhängt, ob die Schleife ein weiteres Mal zu
  durchlaufen ist.<p/>
In solchen Fällen ist die Variante mit der <tt>for</tt>-Schleife der
Variante mit der <tt>while</tt>-Schleife vorzuziehen, weil somit die
Befehle, die die Schleife steuern, gebündelt zu Beginn der Schleife
stehen. </paragraph></subsubsection><subsubsection titel = "toString">
Eine sinnvolle Methode <tt>toString</tt> für Listen erzeugt einen
String, in dem die Listenelemente durch Kommas getrennt sind.<code package = "name/panitz/data/list"
                lang = "java"
                class = "Li">  public String toString(){
    return &quot;(&quot;+toStringAux()+&quot;)&quot;;
  }

  private String toStringAux(){
    if (isEmpty()) return &quot;&quot;;
    else if (tail().isEmpty()) return head().toString();
    else return head().toString()+&quot;,&quot;+tail().toStringAux();
  }</code></subsubsection><aufgabe>Nehmen Sie beide der in diesem Kapitel entwickelten
Umsetzungen von Listen und fügen Sie ihrer Listenklassen folgende Methoden
hinzu. Führen  Sie Tests für diese Methoden durch.<unteraufgaben>
            <teil><tt>a last()</tt>: gibt das letzte Element der Liste aus.</teil>
            <teil><tt>List&lt;a&gt; concat(List&lt;a&gt; other)</tt> bzw.: <tt>Li&lt;a&gt; concat(Li&lt;a&gt; other)</tt>: erzeugt eine neue Liste, die
erst die Elemente der <tt>this</tt>-Liste und dann 
der <tt>other</tt>-Liste hat, es sollen also zwei Listen aneinander
gehängt werden. </teil>
            <teil><tt>a elementAt(int i)</tt>: gibt das Element an einer
bestimmten Indexstelle der Liste zurück. Spezifikation:<eqnarray>
elementAt(Cons(x,xs),1)<eq/>x<br/>
elementAt(Cons(x,xs),n+1)<eq/>elementAt(xs,n)</eqnarray></teil>
          </unteraufgaben></aufgabe></subsection><subsection titel = "Sortierung">
Eine sehr häufig benötigte Eigenschaft von Listen ist, sie nach einer
bestimmten Größenrelation  sortieren zu können. Wir wollen in diesem
Kapitel Objekte des Typs <tt>String</tt> sortieren. Über die 
Methode <tt>compareTo</tt> der Klasse <tt>String</tt> läßt sich eine
kleiner-gleich-Relation auf Zeichenketten definieren:<code package = "name/panitz/data/list"
              lang = "java"
              class = "StringOrdering">package name.panitz.data.list;
class StringOrdering{
  static boolean lessEqual(String x,String y){
    return x.compareTo(y)&lt;=0;
  }
}</code>
Diese statische Methode werden wir zum Sortieren benutzen.<p/>
In den folgenden Abschnitte werden wir drei verschiedene Verfahren der
Sortierung kennenlernen.<subsubsection titel = "Sortieren durch Einfügen">
Die einfachste Methode einer Sortierung ist, neue Elemente in einer
Liste immer so einzufügen, daß nach dem Einfügen eine sortierte Liste
entsteht. Wir definieren also zunächst eine Klasse, die es erlaubt,
Elemente so einzufügen, daß alle vorhergehenden Elemente kleiner und
alle nachfolgenden Elemente größer sind. Diese Klasse braucht unsere 
entsprechenden Konstruktoren und einen neuen Selektor, der den
spezialisierteren Rückgabetyp hat: <code package = "name/panitz/data/list"
                lang = "java"
                class = "SortStringLi">package name.panitz.data.list;
class SortStringLi extends Li&lt;String&gt; { 

  SortStringLi(){super();}
  SortStringLi(String x,SortStringLi xs){super(x,xs);}

  SortStringLi sortTail(){return (SortStringLi)tail();}</code>

Die entscheidende neue Methode für diese Klasse ist die 
Einfügemethode <tt>insertSorted</tt>. Sie erzeugt eine neue Liste, in
die das neue Element eingefügt wird:<code package = "name/panitz/data/list"
                lang = "java"
                class = "SortStringLi"
                sequel = "true">  SortStringLi insertSorted(String x){</code>
Im Falle einer leeren Liste wird die einelementige Liste zurückgegeben:<code package = "name/panitz/data/list"
                lang = "java"
                class = "SortStringLi"
                sequel = "true">    if (isEmpty()) {return new SortStringLi(x,this);}</code> Andernfalls wird unterschieden, ob das einzufügende Element kleiner als
das erste Listenelement ist. Ist das der Fall, so wird das neue
Element in die Schwanzliste sortiert eingefügt:<code package = "name/panitz/data/list"
                lang = "java"
                class = "SortStringLi"
                sequel = "true">    else if (StringOrdering.lessEqual((String)head(),x)){
      return new SortStringLi
                  ((String)head()
                  ,((SortStringLi)tail()).insertSorted(x));</code>
Anderfalls wird das neue Element mit dem Konstruktor vorne eingefügt:<code package = "name/panitz/data/list"
                lang = "java"
                class = "SortStringLi"
                sequel = "true">    } else return new SortStringLi(x,this);
  }//<bluev>method insertSorted</bluev></code>

Die eigentliche Sortiermethode erzeugt eine leere Ergebnisliste, in
  die nacheinander die Listenelemente sortiert eingefügt werden:<code package = "name/panitz/data/list"
                lang = "java"
                class = "SortStringLi"
                sequel = "true">  SortStringLi getSorted(){
    SortStringLi result = new SortStringLi();

    for (Li&lt;String&gt; xs= this;!xs.isEmpty();xs = xs.tail()){
      result = result.insertSorted(xs.head());
    }

    return result;
  }//<bluev>method sort</bluev></code>
Somit hat die Klasse <tt>SortStringLi</tt> eine Sortiermethode, die
  wir in einer Hauptmethode testen können:<code package = "name/panitz/data/list"
                lang = "java"
                class = "SortStringLi"
                sequel = "true">  public static void main(String [] args){
    SortStringLi xs
      = new SortStringLi(&quot;zz&quot;
       ,new SortStringLi(&quot;ab&quot;
       ,new SortStringLi(&quot;aaa&quot;
       ,new SortStringLi(&quot;aaa&quot;
       ,new SortStringLi(&quot;aaz&quot;
       ,new SortStringLi(&quot;aya&quot;
       ,new SortStringLi()))))));


    System.out.println(&quot;Die unsortierte Liste:&quot;);
    System.out.println(xs);

    Li&lt;String&gt; ys = xs.getSorted();
    System.out.println(&quot;Die sortierte Liste:&quot;);
    System.out.println(ys);
  }
}//<bluev>class SortStringLi</bluev></code>
Die Ausgabe unseres Testprogramms zeigt, daß tatsächlich die Liste
sortiert wird:<scode>sep@swe10:~/fh/prog1/Listen&gt; java SortStringLi
Die unsortierte Liste:
(zz,ab,aaa,aaa,aaz,aya)
Die sortierte Liste:
(aaa,aaa,aaz,ab,aya,zz)
sep@swe10:~/fh/prog1/Listen&gt;</scode></subsubsection><subsubsection titel = "Quick Sort">
Der Namen <em>quick sort</em> hat sich für eine Sortiermethode
durchgesetzt, die sich das Prinzip des Teilens des Problems zu eigen
macht, bis die durch Teilen erhaltenen Subprobleme trivial zu lösen
sind.<footnote>Der Name <em>quick sort</em> ist insofern nicht immer
berechtigt, weil in
bestimmten Fällen  das  Verfahren nicht sehr
schnell im Vergleich zu anderen Verfahren ist.</footnote><paragraph titel = "formale Spezifikation">
Mathematisch
läßt sich das Verfahren wie durch folgende Gleichungen beschreiben:<eqnarray>
quicksort(Empty()) <eq/>Empty()<br/>
quicksort(Cons(x,xs))<eq/>quicksort(<lpar/>y|y\in xs, y&lt;=x<rpar/>)<br/><amp/><amp/><mbox>
                <ttt>++</ttt>
              </mbox> Cons(x,quicksort(<lpar/>y|y\in xs, y&gt;x<rpar/>)) </eqnarray>

Die erste Gleichung spezifiziert, daß das Ergebnis der Sortierung
einer leeren Liste eine leere Liste zum Ergebnis hat.<p/>
Die zweite Gleichung spezifiziert den Algorithmus für nichtleere
Listen. Der in der Gleichung benutzte Operator <tt>++</tt> steht für
die Konkatenation zweier Listen mit der in der letzten Aufgabe
geschriebenen Methode <tt>concat</tt>. <p/>
Die Gleichung ist zu lesen als:<quote>
Um eine nichtleere Liste zu sortieren, filtere alle Elemente aus der
Schwanzliste, die kleiner sind als der Kopf der Liste. Sortiere diese
Teilliste. Mache dasselbe mit der Teilliste aus den Elementen des
Schwanzes, die größer als das Kopfelement sind. Hänge schließlich
diese beiden sortierten Teillisten aneinander und das Kopfelement 
dazwischen.</quote></paragraph><paragraph titel = "Modellierung">
Anders als in unserer obigen Sortierung durch Einfügen in eine neue Liste, für
die wir eine Unterklasse der Klasse <tt>Li</tt> geschrieben haben,
wollen wir die Methode <tt>quicksort</tt> in der 
Klasse <tt>Li</tt> direkt implementieren, 
d.h.<white/>allgemein für alle Listen zur
Verfügung stellen.<p/>
Aus der Spezifikation geht hervor, daß wir als zentrales Hilfsmittel
eine Methode brauchen, die nach einer bestimmten Bedingung Elemente
aus einer Liste filtert. Wenn wir diesen Mechanismus haben, so ist der
Rest des Algorithmus mit Hilfe der Methode <tt>concat</tt> trivial
direkt aus der Spezifikation ableitbar. Um die 
Methode <tt>filter</tt> möglichst allgemein zu halten, können wir sie
so schreiben, daß sie ein Objekt bekommt, in dem eine Methode die
Bedingung, nach der zu filtern ist, angibt. Eine solche Klasse sieht
allgemein wie folgt aus:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "FilterCondition">package name.panitz.data.list;
class FilterCondition&lt;a&gt; {
  boolean condition(a testMe){
    return true;
  }
}</code><deleted>
              <code package = "name/panitz/data/list"
                    lang = "java"
                    class = "Li">Li&lt;a&gt; append(Li&lt;a&gt; ys){
  if (isEmpty())return ys;
  return new Li&lt;a&gt;(head(),tail().append(ys));
}</code>
            </deleted>

Für bestimmte Bedingungen können für eine solche Klasse Unterklassen
definiert werden, die die Methode <tt>condition</tt> entsprechend
überschreiben. Für unsere Sortierung brauchen wir zwei
Bedingungen: einmal wird ein Objekt getestet, ob es größer ist als
ein vorgegebenes Objekt, ein anderes Mal, ob es kleiner ist. Wir
erhalten also folgende kleine Klassenhierarchie aus 
Abbildung<w/><ref name = "Condition"/>:<p/><bild name = "Condition"
                  pdfscale = "0.8"
                  psscale = "0.8"
                  caption = "Modellierung der Filterbedingungen."/><p/>
Die beiden Unterklassen brauchen jeweils ein Feld, in dem das Objekt gespeichert ist, mit dem das Element im Größenvergleich getestet wird.<p/>
Die für den Sortieralgorithmus benötigte Methode <tt>filter</tt> kann
entsprechend ein solches Objekt also Argument bekommen:<code>Li&lt;a&gt; filter(Condition&lt;a&gt; cond);</code></paragraph><paragraph titel = "Codierung">
Die entscheidende Methode für den Sortieralgorithmus ist <tt>filter</tt>. Mit
dieser Methode werden entsprechend einer Filterbedingung bestimmte Elemente
aus einer Liste selektiert. 

In der Klasse <tt>Li</tt> kann nun die 
Methode <tt>filter</tt> eingefügt werden:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Li">  Li&lt;a&gt; filter(FilterCondition&lt;a&gt; cond){
    Li&lt;a&gt; result = new Li&lt;a&gt;(); 

    //<bluev>test all elements of this list</bluev>
    for (Li&lt;a&gt; xs=this;!xs.isEmpty();xs=xs.tail()){

      //<bluev>in case that the condition is true for the element</bluev>
      if (cond.condition(xs.head())) {
        //<bluev>then add it to the result</bluev>
        result = new Li&lt;a&gt;(xs.head(),result);
      }
    }
    return result;
  }</code>
Hiermit ist die Hauptarbeit für den <em>quick sort</em>-Algorithmus
      getan. <example>
Bevor wir die Methode <tt>quicksort</tt> implementieren, wollen wir ein
paar Tests für unsere Methode <tt>filter</tt> schreiben. Hierzu schreiben wir
Klassen für die Bedingungen, nach denen wir Elemente aus einer Liste filtern
wollen:


Zunächst eine Bedingung, die Stringobjekte mit einer Länge größer als 10
selektiert:<code package = "name/panitz/data/list"
                    lang = "java"
                    class = "LongString">package name.panitz.data.list;
class LongString extends FilterCondition&lt;String&gt;{
  boolean condition(String testMe){
    return testMe.length()&gt;10;
  }
}</code>

Eine weitere Bedingung soll testen, ob ein Stringobjekt mit einem
Großbuchstaben &#39;A&#39; beginnt:<code package = "name/panitz/data/list"
                    lang = "java"
                    class = "StringStartsWithA">package name.panitz.data.list;
class StringStartsWithA extends FilterCondition&lt;String&gt;{
  boolean condition(String testMe){
    return testMe.charAt(0)==&#39;A&#39;;
  }
}</code>

Und eine dritte Bedingung, die wahr wird für Stringobjekte, die kein großes
&#39;A&#39; enthalten:<code package = "name/panitz/data/list"
                    lang = "java"
                    class = "ContainsNoA">package name.panitz.data.list;
class ContainsNoA extends FilterCondition&lt;String&gt;{
  boolean condition(String testMe){
    for (int i= 0;i&lt;testMe.length();i=i+1){
      final char c = testMe.charAt(i);

      if (c==&#39;A&#39; || c==&#39;a&#39;) return false;
    }
    return true;
  }
}</code>

Probeweise filtern wir jetzt einmal eine Liste nach diesen drei Bedingungen:<code package = "name/panitz/data/list"
                    lang = "java"
                    class = "TestFilter">package name.panitz.data.list;
class TestFilter {

  static
     Li&lt;String&gt; XS = new Li&lt;String&gt;(&quot;Shakespeare&quot;,
             new Li&lt;String&gt;(&quot;Brecht&quot;,
             new Li&lt;String&gt;(&quot;Achternbusch&quot;,
             new Li&lt;String&gt;(&quot;Calderon&quot;,
             new Li&lt;String&gt;(&quot;Moliere&quot;,
             new Li&lt;String&gt;(&quot;Sorokin&quot;,
             new Li&lt;String&gt;(&quot;Schimmelpfennig&quot;,
             new Li&lt;String&gt;(&quot;Kane&quot;,
             new Li&lt;String&gt;(&quot;Wilde&quot;,
             new Li&lt;String&gt;())))))))));

  public static void main(String [] _){
     System.out.println(XS);
     System.out.println(XS.filter(new ContainsNoA()));
     System.out.println(XS.filter(new StringStartsWithA()));
     System.out.println(XS.filter(new LongString()));
  }
}</code>

In der Ausgabe können wir uns vom korrekten Lauf der 
Methode <tt>filter</tt> überzeugen:<scode>sep@linux:~/fh/prog1/examples/classes&gt; java TestFilter
(Shakespeare,Brecht,Achternbusch,Calderon,Moliere,Sorokin,Schimmelpfennig,Kane,Wilde)
(Wilde,Schimmelpfennig,Sorokin,Moliere,Brecht)
(Achternbusch)
(Schimmelpfennig,Achternbusch,Shakespeare)
sep@linux:~/fh/prog1/examples/classes&gt;</scode>
Interessant zu beobachten mag sein, daß unsere Methode <tt>filter</tt> die
Reihenfolge der Elemente der Liste umdreht.</example>




Zurück zu unserer eigentlichen Aufgabe, dem <em>quick sort</em>-Verfahren.
Hier wollen wir die Eingabeliste einmal nach allen
Elementen, die kleiner als das erste Element sind, filtern; und einmal nach
allen Elementen, die größer als dieses sind. Hierzu brauchen wir zwei
Filterbedingungen. Diese hängen beide von einem bestimmten Element, nämlich
dem ersten Element der Liste, ab.
Die beiden Klassen für die Bedingung lassen sich relativ einfach aus
der Modellierung ableiten: <code package = "name/panitz/data/list"
                  lang = "java"
                  class = "LessEqualX">package name.panitz.data.list;
class LessEqualX&lt;a&gt; extends FilterCondition&lt;a&gt;{
  Comparable&lt;a&gt; x;

  LessEqualX(Comparable&lt;a&gt; x){
    this.x=x;
  }
    
  boolean condition(a testMe){
    return x.compareTo(testMe)&gt;0;
  }
}</code>
Entsprechend für die größer-Relation: <code package = "name/panitz/data/list"
                  lang = "java"
                  class = "GreaterX">package name.panitz.data.list;
class GreaterX&lt;a&gt; extends FilterCondition&lt;a&gt; {
  Comparable&lt;a&gt; x;

  GreaterX(Comparable&lt;a&gt; x){
    this.x=x;
  }
    
  boolean condition(a testMe){
    return x.compareTo(testMe)&lt;=0;
  }
}</code>


Die Methode <tt>quicksort</tt> läßt sich direkt aus der
      formalen Spezifikation ableiten:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Li">  static public &lt;a extends Comparable&lt;a&gt;&gt; Li&lt;a&gt; quicksort(Li&lt;a&gt; xs){
    Li&lt;a&gt; result = new Li&lt;a&gt;();
    if (!xs.isEmpty()){ 
      result 
       = //<bluev>filter the smaller elements out of the tail</bluev>
         //<bluev>and sort these</bluev>
         quicksort(xs.tail().filter(new LessEqualX&lt;a&gt;(xs.head())))
          //<bluev>concatenate it with the sorted</bluev> 
          //<bluev>sublist of greater elements</bluev>
          .append(new Li&lt;a&gt;(xs.head()
                 ,quicksort(xs.tail().filter(new GreaterX&lt;a&gt;(xs.head())))
            ));
    }
    return result;
  }</code>

Obige Umsetzung des <em>quick sort</em>-Algorithmus ist allgemeiner
als der zuvor entwickelte Algorithmus zur Sortierung durch
Einfügen. Die entscheidende Methode <tt>filter</tt> ist parameterisiert
über die Bedingung, nach der gefiltert werden soll. Damit läßt sich
schnell eine <em>quick sort</em>-Methode schreiben, deren Filter nicht
auf der größer-Relation von <tt>String</tt> Objekten basiert. Hierzu
sind nur entsprechende Unterklassen der 
Klasse <tt>FilterCondition</tt> zu schreiben und in der Sortiermethode
zu benutzen. Wieder einmal haben wir unsere strenge Trennung aus der
anfänglichen Arbeitshypothese durchbrochen: Die Objekte der 
Klasse <tt>FilterCondition</tt> stellen nicht primär Daten dar,
sondern eine Methode, die wir als Argument einer anderen 
Methode (der Methode <tt>filter</tt>) übergeben.</paragraph><paragraph titel = "Sortieren für beliebige Relationen">
Es ist naheliegend, die Parameterisierung über die eigentliche
Ordnungsrelation der Sortiermethode mitzugeben, also eine
Sortiermethode zu schreiben, die einen Parameter hat, der angibt, nach
welchem Kriterium zu sortieren ist:<code>Li&lt;a&gt; sortBy(Relation rel)</code>
Hierzu brauchen wir eine Klasse <tt>Relation</tt>, die eine Methode
hat, in der entschieden wird, ob zwei Objekte in einer Relation stehen:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Relation">package name.panitz.data.list;
class Relation&lt;a,b&gt;{
  boolean lessEqual(a x,b y){
    return true;
  }
}</code>

Je nachdem, was wir sortieren wollen, können wir eine Subklasse der
Klasse <tt>Relation</tt> definieren, die uns sagt, wann zwei Objekte
in der kleiner-Relation stehen. Für Objekte des 
Typs <tt>String</tt> bietet folgende Klasse eine adäquate Umsetzung:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "StringLessEqual">package name.panitz.data.list;
class StringLessEqual extends Relation&lt;String,String&gt; {
  boolean lessEqual(String x,String y){
    return x.compareTo(y)&lt;=0;
  }
}</code>


Um den <em>quick sort</em>-Algorithmus anzuwenden, benötigen wir nun
noch eine Möglichkeit, aus einer Relation die beiden Bedingungen für
die Methode <tt>filter</tt> generieren. Wir schreiben zwei neue
Subklassen der Klasse <tt>FilterCondition</tt>, die für eine Relation
jeweils kleinere bzw.<white/>größere Objekte als ein vorgegebenes Objekt
filtern.<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "OrderingCondition">package name.panitz.data.list;
class OrderingCondition&lt;a&gt; extends FilterCondition&lt;a&gt;{
  a x;
  Relation&lt;a,a&gt; rel;

  OrderingCondition(a x,Relation&lt;a,a&gt; rel){
    this.x=x;
    this.rel = rel;
  }
    
  boolean condition(a y){
    return rel.lessEqual(y,x);
  }
}</code>
Entsprechend für die negierte Relation:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "NegativeOrderingCondition">package name.panitz.data.list;
class NegativeOrderingCondition&lt;a&gt;  extends FilterCondition&lt;a&gt;{
  a x;
  Relation&lt;a,a&gt; rel;

  NegativeOrderingCondition(a x,Relation&lt;a,a&gt; rel){
    this.x=x;
    this.rel = rel;
  }
    
  boolean condition(a y){
    return !rel.lessEqual(y,x);
  }
}</code>

Damit haben wir alle Bausteine zur Hand, mit denen ein über die
Ordungsrelation parameterisierte Sortiermethode geschrieben werden
kann:<code package = "name/panitz/data/list"
                  lang = "java"
                  class = "Li">  Li&lt;a&gt; sortBy(Relation&lt;a,a&gt;  rel){
    Li&lt;a&gt; result = new Li&lt;a&gt;();
    if (!isEmpty()){ 
      FilterCondition&lt;a&gt; le
       = new OrderingCondition&lt;a&gt;(head(),rel);
      FilterCondition &lt;a&gt; gr
       = new NegativeOrderingCondition&lt;a&gt;(head(),rel);
      result = tail()
                .filter(le)
                .sortBy(rel)
                .append(new Li&lt;a&gt;(head()
                                 ,tail()
                                 .filter(gr)
                                 .sortBy(rel)));
    }
    return result;
  }
}</code>

Beim Aufruf der Methode <tt>sortBy</tt> ist ein Objekt mitzugeben,
das die Relation angibt, nach der sortiert werden soll. <example>
Im folgenden
Beispiel werden Strings einmal nach ihrer lexikographischen Ordnung,
einmal nach ihrer Länge sortiert: <code package = "name/panitz/data/list"
                    lang = "java"
                    class = "StringLengthLessEqual">package name.panitz.data.list;
class StringLengthLessEqual extends Relation&lt;String,String&gt; {
  boolean lessEqual(String x,String y){
    return x.length()&lt;= y.length();
  }
}</code>

In der Testmethode können wir die Methode <tt>sortBy</tt> jeweils mit einer
der Bedingungen aufrufen:<code package = "name/panitz/data/list"
                    lang = "java"
                    class = "TestSortBy">package name.panitz.data.list;
class TestSortBy{
  public static void main(String [] args){
    Li&lt;String&gt; xs = TestFilter.XS;

    System.out.println(&quot;Die unsortierte Liste:&quot;);
    System.out.println(xs);
    System.out.println(&quot;Die alphabetisch sortierte Liste:&quot;);
    System.out.println(xs.sortBy(new StringLessEqual()));
    System.out.println(&quot;Die nach der Länge sortierte Liste:&quot;);
    System.out.println(xs.sortBy(new StringLengthLessEqual()));
  }
}</code> Und tatsächlich können wir jetzt die Sortiermethode benutzen, um nach
unterschiedlichen Kriterien zu sortieren:<scode>sep@linux:~/fh/prog1/examples/classes&gt; java TestSortBy
Die unsortierte Liste:
(Shakespeare,Brecht,Achternbusch,Calderon,Moliere,Sorokin,Schimmelpfennig,Kane,Wilde)
Die alphabetisch sortierte Liste:
(Achternbusch,Brecht,Calderon,Kane,Moliere,Schimmelpfennig,Shakespeare,Sorokin,Wilde)
Die nach der Länge sortierte Liste:
(Kane,Wilde,Brecht,Moliere,Sorokin,Calderon,Shakespeare,Achternbusch,Schimmelpfennig)
sep@linux:~/fh/prog1/examples/classes&gt;</scode></example><aufgabe>
Verfolgen Sie schrittweise mit Papier und Beistift, wie 
der <em>quicksort</em> Algorithmus die folgenden zwei Listen sortiert:<itemize>
                <item>
                  <tt>(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</tt>
                </item>
                <item>
                  <tt>(&quot;c&quot;,&quot;a&quot;,&quot;b&quot;,&quot;d&quot;,&quot;e&quot;)</tt>
                </item>
              </itemize></aufgabe><aufgabe>
Diese Aufgabe soll mir helfen, Listen für Ihre Leistungsbewertung zu
erzeugen. <unteraufgaben>
                <teil>Implementieren Sie für Ihre Listenklasse eine 
Methode <tt>String toHtmlTable()</tt>, die für Listen Html-Code für
eine Tabelle erzeugt, z.B:<code>&lt;table&gt;
  &lt;tr&gt;erstes Listenelement&lt;/tr&gt;
  &lt;tr&gt;zweites Listenelement&lt;/tr&gt;
  &lt;tr&gt;drittes Listenelement&lt;/tr&gt;
&lt;/table&gt;</code></teil>
                <teil>Nehmen Sie die Klasse <tt>Student</tt>, die
Felder für Namen, Vornamen und Matrikelnummer hat. Implementieren
Sie für diese Klasse  eine Methode <tt>String toTableRow()</tt>, die
für Studenten eine Zeile einer Html-Tabelle erzeugt:<code>Student s1 = new Student(&quot;Müller&quot;,&quot;Hans&quot;,167857);
System.out.println(s1.toTableRow());</code> 
soll folgende Ausgabe ergeben:<code>&lt;td&gt;Müller&lt;/td&gt;&lt;td&gt;Hans&lt;/td&gt;&lt;td&gt;167857&lt;/td&gt;</code>
Ändern Sie die Methode <tt>toString</tt> so, daß sie dasselbe Ergebnis wie die
neue Methode <tt>toTableRow</tt> hat.</teil>
                <teil>Legen Sie eine Liste von Studenten an, sortieren Sie diese 
mit Hilfe der Methode <tt>sortBy</tt>nach
Nachnamen und Vornamen und erzeugen Sie eine Html-Seite, die die
sortierte Liste anzeigt.<p/>
Sie können zum Testen die folgende Klasse benutzen:<br/><code package = "name/panitz/data/list"
                        lang = "java"
                        class = "HtmlView">package name.panitz.data.list;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.plaf.basic.*; 
import javax.swing.text.*; 
import javax.swing.text.html.*; 

public class HtmlView extends JPanel {

  //example invocation
  public static void main(String s[]) {
    HtmlView view = new HtmlView();
    view.run();
    view.setText(&quot;&lt;h1&gt;hallo&lt;/h1&gt;&quot;);
  }

  JFrame frame;
  JTextPane ausgabe = new JTextPane();

  public HtmlView() {
    ausgabe.setEditorKit(new HTMLEditorKit());
    add(ausgabe);	
  }

  void setText(String htmlString){
    ausgabe.setText(htmlString);
    frame.pack();
    ausgabe.repaint();
  }

  void run(){
    frame = new JFrame(&quot;HtmlView&quot;);
    frame.getContentPane().add(this);
    frame.pack();
    frame.setVisible(true);
  }
}</code></teil>
              </unteraufgaben></aufgabe></paragraph></subsubsection></subsection><subsection titel = "Formale Beweise über Listenalgorithmen">
Im ersten Kapitel haben wir unter den Disziplinen der Programmierung auch die formale Verifikation aufgezählt. Die formale Verifikation erlaubt es,
Eigenschaften von Programmen allgemein mathematisch zu beweisen. Anders als durch Testfälle, die nur Aussagen über ein Programm für ausgewählte Fälle machen können, können über die Verifikation allgemeine Aussagen bewiesen werden, die
sich auf alle möglichen Argumente für ein Programm beziehen können. Formale
Verifikation ist seit Jahrzehnten ein weites Feld der Forschung, die zumeist
im Gebiet der KI (künstlichen Intelligenz) angesiedelt ist.<p/>

Voraussetzung für eine formale Verifikation ist, daß sowohl die Datentypen als
auch die programmierten Algorithmen in einer formalen Weise spezifiziert und
notiert wurden. Für unsere Listentypen haben wir das bisher getan. Unsere Listen sind daher bestens geeignet, um formale Beweise zu führen.<subsubsection titel = "Vollständige Induktion">
Das aus der Mathematik bekannte Verfahren der vollständigen Induktion über die natürlichen Zahlen ist ein gängiges Verfahren zur Verifikation von
Algorithmen. Ein Induktionsbeweis geht dabei in zwei Schritten. Zunächst wird
im sogenannten Induktionsanfang die Aussage für das kleinste Datum geführt,
bei natürlichen Zahlen also für die Zahl 0. Im zweiten Schritt, dem sogenannten Induktionsschritt, wird angenommen, daß die Aussage bereits für
alle Werte kleiner eines bestimmten Wertes <m>n</m> bewiesen wurde. Dann wird versucht, unter dieser Annahme die Aussage auch für <m>n</m> zu beweisen. Sind
beide Beweisschritte gelungen, so ist die Aussage für alle endlichen Werte
bewiesen.  </subsubsection><subsubsection titel = "Induktion über Listen">
Das Beweisverfahren der Induktion läßt sich auf rekursiv definierte
Datentypen, so wie unsere Listen, anwenden. Der Basisfall, also entsprechend
der <m>0</m> bei den natürlichen Zahlen, sind die Daten, die durch einen nicht
rekursiven Konstruktor erzeugt werden. Für Listen entsprechend sind dieses die
Listen, die mit dem Konstruktor für leere Listen erzeugt wurden. Im
Induktionsschritt wird angenommen, die zu beweisende Aussage sei bereits für Daten, die mit weniger Konstruktoren erzeugt wurden, bewiesen. Unter dieser
Annahme wird versucht zu zeigen, daß die Aussage auch für mit einem weiteren Konstruktor erzeugte Daten gilt. Für Listen bedeutet das, man versucht, die Annahme für die Liste der Form <em>Cons(x,xs)</em> zu beweisen unter der
Annahme, daß die Aussage für die Liste <em>xs</em> bereits bewiesen wurde.<example>
Als Beispiel wollen wir eine Eigenschaft über Listen im Zusammenhang mit den
Funktionen <em>concat</em> und <em>length</em> beweisen. Wir wollen beweisen,
daß die Länge der Konkatenation zweier Listen gleich der Summe der Längen der beiden Listen ist, also daß für alle Listen <em>xs</em> und <em>ys</em> gilt:<eqnarray>length(concat(xs,ys)) <eq/> length(xs) + length(ys)</eqnarray>

Dabei seien die beiden Funktionen wieder spezifiziert als:<eqnarray>
length(Empty())<eq/>0<br/>
length(Cons(x,xs))<eq/>1+length(xs)</eqnarray>

und<eqnarray>
concat(Empty(),ys)<eq/>ys<br/>
concat(Cons(x,xs),ys)<eq/>Cons(x,concat(xs,ys))</eqnarray>


Wir werden die Aussage beweisen mit einer Induktion über das erste Argument der Funktion <em>concat</em>, also dem <em>xs</em>:<itemize>
              <item><b>Induktionsanfang:</b> Wir versuchen, die Aussage zu beweisen mit <em>xs=Empty()</em>. Wir erhalten
die folgende Aussage:<eqnarray>length(concat(Empty(),ys)) <eq/> length(Empty()) + length(ys)</eqnarray>
Wir können jetzt auf beiden Seiten der Gleichung durch Reduktion mit den Gleichungen aus der Spezifikation die Gleichung vereinfachen:<eqnarray>
length(concat(Empty(),ys)) <eq/> length(Empty()) + length(ys)<br/>
length(ys) <eq/> length(Empty()) + length(ys)<br/>
length(ys) <eq/> 0 + length(ys)<br/>
length(ys) <eq/> length(ys)</eqnarray>

Wir haben die Aussage auf eine Tautologie reduziert. Für <em>xs</em> als leere
Liste ist damit unsere Aussage bereits bewiesen.</item>
              <item><b>Induktionsschritt:</b> Jetzt wollen wir die Aussage  für <em>xs=Cons(x&#39;,xs&#39;)</em> beweisen, wobei wir als
Induktionsvoraussetzung annehmen, daß sie für <em>xs&#39;</em> bereits wahr ist, daß also
gilt:<eqnarray>length(concat(xs&#39;,ys)) <eq/> length(xs&#39;) + length(ys)</eqnarray>

Hierzu stellen wir die zu beweisende Gleichug auf und reduzieren sie auf
beiden Seiten:<eqnarray>
length(concat(Cons(x&#39;,xs&#39;),ys)) <eq/> length(Cons(x&#39;,xs&#39;)) + length(ys)<br/>
length(Cons(x&#39;,concat(xs&#39;,ys))) <eq/> length(Cons(x&#39;,xs&#39;)) + length(ys)<br/>
1+length(concat(xs&#39;,ys)) <eq/> 1+length(xs&#39;) + length(ys)<br/>
length(concat(xs&#39;,ys)) <eq/>length(xs&#39;) + length(ys)</eqnarray>

Die letzte Gleichung ist gerade die Induktionsvoraussetzung, von der wir
angenommen haben, daß diese bereits wahr ist. Wir haben unsere Aussage für
alle endlichen Listen bewiesen.</item>
            </itemize></example></subsubsection></subsection></section><section titel = "Bäume">

Bäume sind ein gängiges Konzept um hierarchische Strukturen zu
modellieren. Sie sind bekannt aus jeder Art von Baumdiagramme, wie
Stammbäumen oder Firmenhierarchien. 
In der Informatik 
sind Bäume allgegenwärtig. Fast alle komplexen Daten
stellen auf die eine oder andere Art einen Baum dar. Beispiele für
Bäume sind mannigfach:<itemize>
        <item><b>Dateisystem</b>: Ein gängiges Dateisystem, wie es aus Unix,
MacOS und Windows bekannt ist, stellt eine Baumstruktur dar. Es gibt
einen ausgezeichneten Wurzelordner, von dem aus zu jeder Datei einen
Pfad existiert.</item>
        <item><b>Klassenhierarchie</b>: Die Klassen in Java stellen mit ihrer
Ableitungsrelation eine Baumstruktur dar. Die 
Klasse <tt>Object</tt> ist die Wurzel dieses Baumes, von der aus alle
anderen Klassen über einen Pfad entlang der Ableitungsrelation
erreicht werden können. </item>
        <item><b>XML</b>: Die logische Struktur eines XML-Dokuments ist ein
Baum. Die Kinder eines Elements sind jeweils die Elemente, die durch
das Element eigeschlossen sind.</item>
        <item><b>Parserergebnisse</b>: Ein Parser, der gemäß einer Grammatik
prüft, ob ein bestimmter Satz zu einer Sprache gehört, erzeugt im
Erfolgsfall eine Baumstruktur. Im nächsten Kapitel werden wir dieses
im Detail kennenlernen.</item>
        <item><b>Listen</b>: Auch Listen sind Bäume, allerdings eine besondere
Art, in denen jeder Knoten nur maximal ein Kind hat.</item>
        <item><b>Berechnungsbäume</b>: Zur statischen Analyse von Programmen,
stellt man Bäume auf, in denen die Alternativen eines bedingten
Ausdrucks  Verzweigungen im
Baum darstellen.</item>
        <item><b>Tableaukalkül</b>: Der Tableaukalkül ist ein Verfahren zum
Beweis logischer Formeln. Die dabei verwendeten Tableaux sind
Bäume.</item>
        <item><b>Spielbäume</b>: Alle möglichen Spielverläufe eines Spiels
können als Baum dargestellt werden. Die Kanten entsprechen dabei einem
Spielzug.</item>
        <item><b>Prozesse</b>: Auch die Prozesse eines Betriebssystems stellen eine
Baumstruktur dar. Die Kinder eines Prozesses sind genau die Prozesse, die von
ihm gestartet wurden.</item>
      </itemize>

Wie man sieht, lohnt es sich, sich intensiv mit Bäumen vertraut zu
machen, und man kann davon ausgehen, was immer in der Zukunft neues in
der Informatik entwickelt werden wird, Bäume werden darin in
irgendeiner Weise eine Rolle spielen. <p/>
Ein Baum besteht aus einer Menge von Knoten die durch gerichtete
Kanten verbunden sind. Die Kanten sind eine Relation auf den Knoten
des Baumes. Die Kanten verbinden jeweils einen Elternknoten
mit einem Kinderknoten. Ein Baum hat einen eindeutigen
Wurzelknoten. Dieses ist der einzige Knoten, der keinen Elternknoten
hat, d.h.<white/>es gibt keine Kante, die zu diesen Knoten
führt.  Knoten, die keinen Kinderknoten haben, d.h.<white/>von 
denen keine Kante ausgeht, heißen Blätter.<p/>
Die Kinder eines Knotens sind geordnet, d.h.<white/>sie stehen
in einer definierten Reihenfolge.<p/>
Eine Folge von Kanten, in der der Endknoten einer Vorgängerkante der
Ausgangsknoten der nächsten Kanten ist, heißt Pfad. <p/>
In einem Baum darf es keine Zyklus geben, das heißt, es darf keinen
Pfad geben, auf dem ein Knoten zweimal liegt.<p/>
Knoten können in Bäumen markiert sein, z.B.<white/>einen Namen
haben. Mitunter können auch Kanten eine Markierung tragen.<p/>
Bäume, in denen Jeder Knoten maximal zwei Kinderknoten hat, nennt man
Binärbäume. Bäume, in denen jeder Knoten maximal einen Kinderknoten
hat, heißen Listen. <subsection titel = "Formale Spezifikation">
        <subsubsection titel = "Allgemeine Bäume">
Wir wollen in diesem Abschnitt Bäume als einen abstrakten Datentypen
spezifizieren. <paragraph titel = "Konstruktoren">
Abstrakte Datentypen lassen sich  durch
ihre Konstruktoren spezifizieren. Die
Konstruktoren geben an, wie Daten des entsprechenden Typs konstruiert
werden können. 

In dem Fall von Bäumen bedarf es nach
den obigen Überlegungen nur eines Konstruktors, den für Knoten. Er
konstruiert aus der Liste der Kinderbäume einen neuen Baumknoten.
Als zusätzliches Argument bekommt er ein Objekt, das eine Markierung
für den Baumknoten darstellt. Den Typ dieses Markierungsobjektes können wir
erst einmal offen lassen. Hier darf ein beliebiger Typ gewählt werden. <p/>
Wir benutzen in der Spezifikation eine mathematische Notation der
Typen von Konstruktoren.<footnote>Entgegen der Notation in Java, in der
der Rückgabetyp kurioser Weise vor den Namen der Methode geschrieben
wird.</footnote> Dem Namen des Konstruktors folgt dabei mit einem
Doppelpunkt abgetrennt der Typ. Der Ergebnistyp wird von den
Parametertypen mit einem Pfeil getrennt.<p/>
Somit läßt sich der Typ des Konstruktors für Bäume wie
folgt spezifizieren:<itemize>
              <item>Node: (<m>
                  <alpha/>
                </m>,<b>List</b><tt>&lt;</tt><b>Tree</b><tt>&lt;</tt><m>
                  <alpha/>
                </m><tt>&gt;&gt;</tt>) <rightarrow/><b>Tree</b><tt>&lt;</tt><m>
                  <alpha/>
                </m><tt>&gt;</tt></item>
            </itemize></paragraph><paragraph titel = "Selektoren">

Die Selektoren können wieder auf die einzelnen
Bestandteile der Konstruktion zurückgreifen. 
Der Konstruktor <bf>Node</bf> hat zwei Parameter. 
Für Bäume
werden zwei
Selektoren spezifiziert, die jeweils einen dieser beiden Parameter
wieder aus dem Baum selektieren. <itemize>
              <item>theChildren: <b>Tree</b><tt>&lt;</tt><m>
                  <alpha/>
                </m><tt>&gt;</tt><rightarrow/><b>List</b><tt>&lt;</tt><b>Tree</b><tt>&lt;</tt><m>
                  <alpha/>
                </m><tt>&gt;&gt;</tt></item>
              <item>mark: <b>Tree</b><tt>&lt;</tt><m>
                  <alpha/>
                </m><tt>&gt;</tt><rightarrow/><m>
                  <alpha/>
                </m></item>
            </itemize>

Der funktionale Zusammenhang von den Selektoren und Konstruktoren läßt
sich durch folgende Gleichungen spezifizieren:<quote><em>mark(Node(x,xs))</em> = <em>x</em><br/><em>theChildren(Node(x,xs))</em> = <em>xs</em></quote></paragraph><paragraph titel = "Testmethoden">
Da wir nur einen Konstruktor vorgesehen haben, brauchen wir keine
Testmethode, die unterscheidet, mit welchem Konstruktor ein Baum
konstruiert wurde. <p/>
Die Unterscheidung, ob es sich um ein Blatt oder um
einen Knoten mit Kindern handelt, läßt sich über die Abfrage, ob die
Liste der Kinderknoten leer ist, erfahren. Wir können eine
entsprechende Funktion spezifizieren:<quote><em>isLeaf(Node(x,xs))</em> = <em>isEmpty(xs)</em></quote></paragraph></subsubsection>
      </subsection><subsection titel = "Modellierung">
Wir haben wieder verschiedene Möglichkeiten eine Baumstruktur mit
Klassen zu modellieren. <subsubsection titel = "mit einer Klasse">
Die einfachste Modellierung ist mit einer
Klasse. Diese Klasse stellt einen Knoten dar. Sie enthält ein Feld 
für die Knotenmarkierung und ein Feld für die Kinder des Knotens. Nach
unserer Spezifikation sind die Kinder eine Liste weiterer Knoten.
Ein entsprechendes UML Diagramm befindet sich in 
Abbildung<white/><ref name = "Tree"/><bild name = "Tree"
                pdfscale = "0.9"
                psscale = "0.5"
                caption = "Modellierung von Bäumen mit einer Klasse."/></subsubsection><subsubsection titel = "Mit einer Klassenhierarchie">
Ebenso, wie wir es bei Listen vorgeschlagen haben, können wir auch
wieder eine Modellierung mit mehreren Klassen vornehmen. Hierzu
beschreibt eine Schnittstelle die allgemeine Funktionalität von
Bäumen. Zwei Unterklassen, jeweils eine für innere Knoten und eine für
Blätter implementieren diese Schnittstelle.
Ein entsprechendes UML Diagramm befindet sich in
Abbildung<white/><ref name = "TreeHierarch"/><bild name = "TreeHierarch"
                pdfscale = "0.8"
                psscale = "0.8"
                caption = "Modellierung von Bäumen mittels einer Klassenhierarchie."/>

Welche dieser beiden Modellierungen jeweils vorzuziehen ist, hängt
sehr davon ab, für was die Bäume in der Gesammtanwendung benutzt
werden sollen. Eine grobe Faustregel für abstrakte Datentypen ist:<itemize>
            <item>Wenn zu erwarten ist, daß im Laufe der Softwareentwicklung
  noch weitere Konstruktoren zum abstrakten Datentyp hinzudefiniert
  werden, dann ist eine Modellierung als Hierarchie vorteilhaft. Der
  neue Konstruktor führt zu einer neuen Klasse, in der lokale Version
  der für die implementierte Schnittstelle benötigten Methoden
  implementiert werden.</item>
            <item>
    Wenn zu erwarten ist, daß spezialisierte Versionen des abstrakten
    Datentyps benötigt werden, so ist eine Modellierung als eine
    Klasse vorteilhaft, weil dann für dieser einen Klassen eine
    Unterklasse implementiert werden kann.
  </item>
          </itemize>

Wir werden im Folgenden für unsere Bäume die Modellierung mit einer
Klasse bevorzugen und anschließend spezialisierte Baumtypen von dieser
einen Klasse ableiten.</subsubsection></subsection><subsection titel = "Implementierung">
Für unsere Umsetzung von Bäumen benutzen wir die Modellierung in einer
Klasse. Wir schreiben die Klasse <tt>Tree</tt> entsprechend unserer
Spezifikation. Zusätzlich sehen wir zwei weitere Konstruktoren vor,
die jeweils einen Standardwert für die beiden Felder setzen:<itemize>
          <item><tt>Tree(List children)</tt>: als Knotenmarkierung 
wird  <tt>null</tt> genommen.</item>
          <item><tt>Tree(a mark)</tt>: für die Kinder wird eine leere Liste
erzeugt.</item>
        </itemize>
Wir erhalten folgende einfache Klasse:<code lang = "java"
              class = "Tree"
              package = "name/panitz/data/tree">package name.panitz.data.tree;

import java.util.List;
import java.util.Iterator;
import java.util.Enumeration;
import java.util.ArrayList;
import javax.swing.tree.TreeNode; 

public class Tree&lt;a&gt; implements TreeNode{

  private a mrk;  
  private List&lt;Tree&lt;a&gt;&gt; chldrn;</code>

Die beiden Felder werden durch den Konstruktor gesetzt:<code>  public Tree(a mark,List&lt;Tree&lt;a&gt;&gt; children){
    this.mrk=mark;
    this.chldrn=children;
  }</code>

Zwei weitere Konstruktoren setzen beziehen sich auf diesen Konstruktor:<code class = "Tree"
              lang = "java"
              sequel = "true"
              package = "name/panitz/data/tree">  public Tree(List&lt;Tree&lt;a&gt;&gt; children){
    this(null,children);
  }

  public Tree(a mark){
    this(mark,new ArrayList&lt;Tree&lt;a&gt;&gt;());
  }


  public List&lt;Tree&lt;a&gt;&gt; theChildren(){return chldrn;}
  public a mark(){return mrk;}

  public boolean isLeaf(){return theChildren().isEmpty();}
</code></subsection><aufgabe>Erzeugen Sie ein Baumobjekt, das einen Stammbaum Ihrer
Familie darstellt. Die Knoten und Blätter sind mit Namen markiert. Die
Wurzel ist mit Ihren Namen markiert. 
Kinderknoten sind mit den leiblichen Eltern der 
Person eines Knotens markiert.</aufgabe></section><section titel = "Algorithmen auf Bäumen">
Die Selektormethoden für Bäume und Listen können wir jetzt gemeinsam
nutzen, um einfache Algorithmen auf Bäumen umzusetzen.<subsection titel = "Knotenanzahl">
Entsprechend der Methode <tt>length</tt>, wie wir sie für Listen
geschrieben haben, lassen sich die Knoten eines Baumes zählen.<p/><code class = "Tree"
              lang = "java"
              sequel = "true"
              package = "name/panitz/data/tree">public int count(){
  int result = 1; // Startwert 1 für diesen Knoten

  //für jedes Kind
  for (Tree&lt;a&gt; child: theChildren())
    //addiere die Knotenanzahl des Kindes zum Ergebnis 
    result=result+child.count();

  return result;
}</code>
Diese Methode ist rekursiv geschrieben. Der terminierende Fall
  versteckt sich dieses mal in der <tt>for-Schleife</tt>. Wenn die
  Liste der Kinder leer ist, so wird die <tt>for</tt>-Schleife nicht
  durchlaufen. Nur im Rumpf der Schleife steht ein rekursiver
  Aufruf. Daher gibt es keine Anweisung der Form:<br/><tt>if (theChildren().isEmpty()) return 1</tt></subsection><subsection titel = "toString">
Unter Benutzung der Methode <tt>toString</tt> aus der
Listenimplementierung, läßt sich relativ einfach 
eine <tt>toString</tt>-Methode für unsere Baumimplementierung
umsetzen. <code>public String toString(){
  //Nimm erst die Markierung an diesem Knoten
  String result = mark().toString();
  
  //Gibt es keine Kinder, dann bist du fertig
  if (isLeaf()) return result;

  //ansonsten nimm implizit durch Operator + das 
  //toString() der Kinder
  return result+theChildren();
}</code>
Auch wenn wir es nicht sehen, ist diese Methode rekursiv. Der 
Ausdruck <tt>result+theChildren()</tt> führt dazu, daß auf einer Liste
  von Bäumen die Methode <tt>toString()</tt> ausgeführt wird. Dieses
  führt wiederum zur Ausführung der <tt>toString</tt>-Methode auf
  jedes Element und dieses sind wiederum Bäume. Der Aufruf 
  von <tt>toString</tt> der Klasse <tt>Tree</tt> führt über den Umweg
  der Methode <tt>toString</tt> der 
Schnittstelle <tt>List</tt> abermals zur Ausführung 
der <tt>ToString</tt>-Methode aus <tt>Tree</tt>. Man spricht dabei
  auch von <em>verschränkter</em> Rekursion.</subsection><subsection titel = "Linearisieren">
Die Methode <tt>flatten</tt> erzeugt eine Liste, die die Markierung
jedes Baumknotens genau einmal enthält. Aus einem Baum wird also eine
Liste erzeugt. Die logische Struktur des Baumes wird flachgeklopft. <code class = "Tree"
              lang = "java"
              sequel = "true"
              package = "name/panitz/data/tree">public List&lt;a&gt; flatten(){
  //leere Liste für das Ergebnis
  List&lt;a&gt; result = new ArrayList&lt;a&gt;();

  //füge die Markierung dieses Knotens zur 
  //Ergebnisliste hinzu
  result.add(mark());

  //für jedes Kind
  for (Tree&lt;a&gt; child : theChildren())
    //erzeuge dessen Knotenliste und füge alle deren 
    //Elemente zum Ergebnis hinzu
    result.addAll(child.flatten());

  return result;
}</code>
Als Ergebnisliste wird ein Objekt der 
Klasse <tt>ArrayList</tt> angelegt. Diesem Objekt wird die Markierung
  des aktuellen Knotens zugefügt und dann die Linearisierung jedes der
  Kinder. Die Methode <tt>addAll</tt> aus der 
Schnittstelle <tt>List</tt> sorgt dafür, daß alle Elemente der
  Parameterliste hinzugefügt werden.</subsection><aufgabe>Testen Sie die in diesem Abschnitt entwickelten Methoden auf
Bäumen mit dem in der letzten Aufgabe erzeugten Baumobjekt. </aufgabe><aufgabe>
Schreiben Sie die folgenden weiteren Methoden für die 
Klasse <tt>Tree</tt>. Schreiben Sie Tests für diese Methoden.<unteraufgaben>
          <teil><tt>List leaves()</tt>: erzeugt eine Liste der Markierungen an den
Blättern des Baumes.</teil>
          <teil><tt>String show()</tt>: erzeugt eine textuelle Darstellung des
Baumes. Jeder Knoten soll eine eigene Zeile haben. Kinderknoten sollen
gegenüber einem Elternknoten eingerückt sein.<p/>
Beispiel:<verb>william
  charles
    elizabeth
    phillip
  diana
    spencer</verb><b>Tipp:</b> Benutzen Sie eine Hilfsmethode<br/><tt>String showAux(String prefix)</tt>,<br/>
die den String <tt>prefix</tt> vor den erzeugten Zeichenketten anhängt.</teil>
          <teil><tt>boolean contains(a o)</tt>: ist wahr, wenn eine
Knotenmarkierung gleich dem Objekt <tt>o</tt> ist.</teil>
          <teil><tt>int maxDepth()</tt>: gibt die Länge des längsten Pfades von
der Wurzel zu einem Blatt an.</teil>
          <teil><tt>List&lt;a&gt; getPath(a o)</tt>: gibt die Markierungen auf dem
Pfad von der Wurzel zu dem Knoten, der mit dem Objekt <tt>o</tt>
markiert ist, zurück. Ergebnis ist eine leere Liste, wenn ein 
Objekt gleich <tt>o</tt> nicht existiert.</teil>
          <teil><tt>java.util.Iterator&lt;a&gt; iterator()</tt>: erzeugt ein Iterator
über alle Knotenmarkierungen des Baumes.<br/><b>Tipp:</b> Benutzen Sie bei der Umsetzung die Methode <tt>flatten</tt>.</teil>
          <teil><tt>public boolean equals(Object other)</tt>: soll genau dann
wahr sein, wenn <tt>other</tt> ein Baum ist, der die gleiche Struktur und
die gleichen Markierungen hat.</teil>
          <teil><tt>&lt;b&gt;boolean sameStructure(Tree&lt;a&gt; other)</tt>: soll genau dann wahr
sein, wenn der Baum <tt>other</tt> die gleiche Struktur hat. Die
Markierungen der Knoten können hingegen unterschiedlich sein.</teil>
        </unteraufgaben></aufgabe><subsection titel = "Lösung">
        <subsubsection titel = "leaves"><tt>List leaves()</tt>: erzeugt eine Liste der Markierungen an den
Blättern des Baumes.<p/>
Wir können die Methode <tt>leaves</tt> aus der 
Methode <tt>flatten</tt> ableiten. Beide Methoden nehmen Elemente
eines Baumes und fügen diese in eine Ergebnisliste ein.  <code class = "Tree"
                lang = "java"
                sequel = "true"
                package = "name/panitz/data/tree">public List&lt;a&gt; leaves(){
  //leere Liste für das Ergebnis
  List&lt;a&gt; result = new ArrayList&lt;a&gt;();

  //füge die Markierung dieses Knotens zur Ergebnisliste 
  //nur hinzu, wenn es ein Blatt ist
  <redv>if (isLeaf())</redv> result.add(mark());

  //für jedes Kind
  for (Tree&lt;a&gt; child:theChildren())
    //erzeuge dessen Knotenliste und füge alle deren Blätter 
    //zum Ergebnis hinzu
    result.addAll(child.leaves());

  return result;
}</code>
Alles, was zu ändern ist, ist eine Bedingung aufzustellen, wann ein
Knoten der Ergebnisliste hinzugefügt werden soll. 
Bei <tt>flatten</tt> war das immer der Fall, bei <tt>leaves</tt> nur, 
wenn es sich bei dem Baumknoten um ein Blatt
handelt. <paragraph titel = "Akkumulative Lösung">
Wir haben uns bisher noch keine Gedanken um die Performanz unserer
Methoden gemacht. Wenn wir die die 
Methoden <tt>flatten</tt> und <tt>leaves</tt> einmal genau betrachten, 
so stellen
wir fest, daß jeder Aufruf der Methode eine neue Ergebnisliste
erzeugt. Das bedeutet, daß die 
Methoden <tt>flatten</tt> und <tt>leaves</tt> durch die
rekursiven Aufrufe, soviel Listen erzeugt, wie Knoten im Baum sind. Mit dem
Aufruf der Methode <tt>addAll</tt> auf Listen, werden die Elemente
einer Liste in eine neue Liste eingetragen. Wir sind aber nur an einer
einzigen Liste interessiert, der endgültigen Ergebnisliste. <p/>

Es wäre also schön, wenn wir eine Methode <tt>flatten</tt> hätten, 
die nicht eine neue Liste erzeugt, sondern eine bestehende Liste
benutzt, um dort weitere Elemente einzufügen. Wir können hierzu der
Methode einen Listenparameter geben, in dem die Ergebnisse zu sammeln
sind. <code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List&lt;a&gt; flatten(List&lt;a&gt; result){
  result.add(mark());

  for (Tree&lt;a&gt; child:theChildren())
    child.flatten(result);

  return result;
}</code>
Die eigentliche Methode <tt>flatten</tt> kann jetzt einmal das Objekt
für die Ergebnisliste erzeugen, und dann diese jeweils weitereichen,
um das Erzeugen neuer Listen und das umkopieren der Elemente von einer
Liste in eine andere zu verhindern.<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List&lt;a&gt; flattenAkk(){
  return flatten(new ArrayList&lt;a&gt;());
}</code>

Und entsprechend können wir die Methode <tt>leaves</tt> auch
umschreiben, so daß sie nicht für jeden rekursiven Aufruf ein neues
Listenobjekt erzeugt:<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List&lt;a&gt; leaves(List&lt;a&gt; result){
  if (isLeaf()) result.add(mark());

  for (Tree&lt;a&gt; child:theChildren())
    child.leaves(result);

  return result;
}

public List&lt;a&gt; leavesAkk(){
  return leaves(new ArrayList&lt;a&gt;());
}</code>

Dieses Prinzip, ein Ergebnis in einem Parameter nach und nach
zusammenzusammeln nennt man <em>Akkumulation</em>. Der Parameter, in
dem das Ergebnis jeweils hinzugefügt wird, ist der Akkumulator. Mit
Hilfe des Befehls <tt>time</tt> auf der Unix-Shell, läßt sich sogar 
ungefähr messen,
daß die akkumulierende Methode schneller abgearbeitet wird.<p/></paragraph><paragraph titel = "Programmierung höherer Ordnung">
Wir haben im letztem Abschnitt bereits beobachten können, daß die
Methoden <tt>flatten</tt> und <tt>leaves</tt> fast identischen Code
haben. Beide selektieren aus einem Baum bestimmte Baummarkierungen
heraus. Das einzige was sie unterscheidet, ist die Bedingung, die
steuert, ob eine Knotenmarkierung zu selektieren ist oder
nicht. Ansonsten haben wir Code verdoppelt. <p/>

Unser Bestreben ist stets eine Codeverdoppelung zu vermeiden, denn
verdoppelter Code ist auch doppelt zu pflegen und zu warten. 
Das haben wir sogar schon festgestellt, als wir auf die akkumulative
Lösung der beiden Methoden gekommen sind. Da haben wir beide Methoden
geändert, um für sie die akkumulative Lösung einzuführen.<p/>

Wir
können eine Methode schreiben, die den gemeinsamen Code der beiden
Methoden enthält. Das
einzige, was die beiden Methoden unterscheidet ist eine
Bedingung. Diese Bedingung ist eine Prüfung auf die Baumknoten. Die
gemeinsame Methode muß diese Bedingung als Parameter übergeben
bekommen. Eine Prüfung ist eine Methode. Wir können in Java keine
Methoden direkt als Parameter übergeben, sondern nur Objekte. Wir
definieren daher eine Schnittstelle, die beschreibt, daß ein Objekt
eine Prüfmethoden enthält.<code class = "TreeCondition"
                  package = "name/panitz/data/tree"
                  lang = "java">package name.panitz.data.tree;

public interface TreeCondition&lt;a&gt;{
  boolean takeThis(Tree&lt;a&gt; o);
}</code>  

Mit dieser Schnittstelle sind wir jetzt in der Lage eine Bedingung auf
Baumknoten auszudrücken. Wir können damit eine allgemeine
Filtermethode schreiben, die Knoten mit einer bestimmten Bedingung aus
einem Baum selektiert. Die Methode <tt>filter</tt> ist die
Verallgemeinerung die Methoden <tt>leaves</tt> und <tt>flatten</tt>.
Wir verallgemeinern die akkumulative Lösung.<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List&lt;a&gt; filter(List&lt;a&gt; result,TreeCondition&lt;a&gt; c){
  //wenn die Bedingung für den Knoten wahr ist, füge
  //ihm dem Ergebnis hinzu
  <redv>if (c.takeThis(this))</redv> result.add(mark());

  //für alle Kinder
  for (Tree&lt;a&gt; child:theChildren())
    //rufe den Filter mit gleicher Bedingung auf
    child.filter(result,c);
  
  return result;
}</code>

Die akkumulative Methode kann noch wie gewohnt gekapselt werden:<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List&lt;a&gt; filter(TreeCondition&lt;a&gt; c){
  return filter(new ArrayList&lt;a&gt;(),c);
}</code>


Jetzt haben wir eine Methode geschrieben, die einmal durch einen Baum
läuft und Knoten aufgrund einer Bedingung in einer Ergebnisliste
sammelt. Wir können jetzt die 
Methoden <tt>leaves</tt> und <tt>flatten</tt> über diese Methode ausdrücken:<tt>leaves</tt> ist ein Filter mit der Bedingung, daß die Baumknoten
ein Blatt ist. Wir erzeugen das Bedingungsobjekt als anonyme innere Klasse:<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List leavesFilter(){
  return filter(
     new TreeCondition&lt;a&gt;(){
        public boolean takeThis(Tree&lt;a&gt; t){
          <bv>return t.isLeaf();</bv>
        }
     });
}</code><p/><tt>flatten</tt> ist ein Filter mit der Bedingung die immer wahr
ist. Also erzeugen wir eine Baumbedingung, die 
konstant <tt>true</tt> als Ergebnis liefert:<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List&lt;a&gt; flattenFilter(){
  return filter(new TreeCondition&lt;a&gt;(){
                  public boolean takeThis(Tree&lt;a&gt; _){<bv>return true;</bv>}
                });
}</code>


Entsprechend können wir jetzt beliebige Bedingungen benutzen, um
Knoten aus dem Baum zu selektieren; z.B.<white/> alle Knoten
mit genau zwei Kindern:<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List&lt;a&gt; nodesWithTwoChildren(){
  return filter(new TreeCondition&lt;a&gt;(){
                  public boolean takeThis(Tree&lt;a&gt; t){
                    <bv>return t.theChildren().size()==2;</bv>
                  }
                });
}</code>

Oder Knoten, die mit einem bestimmten Objekt markiert sind:<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List&lt;a&gt; nodesMarkedWith(final a o){
  return filter(new TreeCondition&lt;a&gt;(){
                  public boolean takeThis(Tree&lt;a&gt; t){
                    <bv>return t.mark().equals(o);</bv>
                  }
                });
}</code>


Letztere Methode kann sogar genutzt werden, um zu entscheiden, ob ein
Objekt in einem Baum enthalten ist.<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public boolean containsFilter(a o){
  return !nodesMarkedWith(o).isEmpty();
}</code>


Das in dieser Lösung vorgestellte Prinzip, daß quasi eine Methode als
Parameter an eine andere Methode übergeben wird, 
heißt <em>Programmierung höherer Ordnung</em>. Java unterstützt dieses
Konzept nur rudimentär, weil zum Übergeben einer Methode als Parameter
erst ein Objekt erzeugt werden muß. In Sprachen wie C kann dieses
Programmierprinzip über Funktionszeiger realisiert werden. In Sprachen
der <tt>Lisp</tt>-Tradition ist die Übergabe von Methoden als
Parameter ein fundamentaler Bestandteil. Mit Hilfe der Programmierung
höherer Ordnung hat man ein sehr mächtiges Ausdrucksmittel.</paragraph></subsubsection>
        <subsubsection titel = "show"><tt>String show()</tt>: erzeugt eine 
textuelle Darstellung des
Baumes. Jeder Knoten soll eine eigene Zeile haben. Kinderknoten sollen
gegenüber einem Elternknoten eingerückt sein.<p/>


Wir schreiben als erstes eine Methode, die einen Baum mit einer als
Parameter übergebenen Einrückung zeigt. Diese Einrückung wird für die
Kinder um zwei Zeichen verlängert:  <code class = "Tree"
                lang = "java"
                sequel = "true"
                package = "name/panitz/data/tree">  public String show(String indent){
    //zeige diesen Knoten mit Einrückung
    String result = indent+mark();

    //erhöhe die Einrückung
    indent=indent+&quot;  &quot;;

    //für jedes Kind
    for (Tree&lt;a&gt; child:theChildren())
     //erzeuge neue Zeile und zeige Kind mit neuer Einrückung
      result=result+&quot;\n&quot;+child.show(indent);
    
    return result;
  }</code>


Die Wurzel eines Baumes zeigen wir ohne Einrückung. Wir kapseln die
obige Methode entsprechend:<code class = "Tree"
                lang = "java"
                sequel = "true"
                package = "name/panitz/data/tree">  public String show(){
      return show(&quot;&quot;);
  }</code><paragraph titel = "Akkumulative Lösung">
Auch für die Methode <tt>show</tt> können wir eine akkumulative Lösung
schreiben. Der Grund, weshalb dieses sinnvoll ist, ist in der Technik
von der Stringumsetzung in Java versteckt. Der Übeltäter ist hierbei
der Operator <ttt>+</ttt> auf <tt>String</tt>. Dieser Operator hängt
nicht einen <tt>String</tt> an einen anderen <tt>String</tt> an,
sondern kopiert beide in einen neuen <tt>String</tt>. Jede Anwendung
des Operators <tt>+</tt> kopiert also <tt>String</tt>-Objekte; und wir
wenden den Operator oft an, um unser Ergebnis zu berechnen.<p/>

Java stellt eine Klasse zur Verfügung mit der <tt>String</tt>-Objekte
akkumuliert werden können, und Kopiervorgänge weitgehendst vermieden
werden: die Klasse <tt>StringBuffer</tt>.<p/>

Objekte der Klasse <tt>StringBuffer</tt> können mit der 
Methode <tt>append</tt> weitere <tt>String</tt>-Objekte angehängt
werden. Sie wird benutzt, wenn ein <tt>String</tt> erst nach und nach 
zusammengebaut wird.<p/>

Ähnlich wie bei der Akkumulation eines Listenergebnisses können wir
mit <tt>StringBuffer</tt> eine Zeichenkette akkumulieren. Hierzu geben
wir in einem Parameter einen <tt>StringBuffer</tt> als Akkumulator
mit. Wie im Listenfall mit der Methode <tt>add</tt> benutzen wir die
Methode <tt>append</tt> zum Aufsammeln der Ergebnisteile:<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">  public StringBuffer show(String indent,StringBuffer result){
    //zeige diesen Knoten mit Einrückung
    result.append(indent);
    result.append(mark().toString());

    //erhöhe die Einrückung
    indent=indent+&quot;  &quot;;

    //für jedes Kind
    for (Tree&lt;a&gt; child:theChildren()){
     //erzeuge neue Zeile und zeige Kind mit neuer Einrückung
      result.append(&quot;\n&quot;);
      child.show(indent,result);
    }
    return result;
  }</code>

Die kapselnde Methode, erzeugt einen 
neuen <tt>StringBuffer</tt>, läßt diesen akkumulieren und gibt
schließlich den in ihm enthaltenen <tt>String</tt> als Ergebnis aus. <code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">  public String showAkk(){
      return show(&quot;&quot;,new StringBuffer()).toString();
  }</code></paragraph></subsubsection>
        <subsubsection titel = "contains"><tt>boolean contains(a o)</tt>: ist wahr, wenn eine
Knotenmarkierung gleich dem Objekt <tt>o</tt> ist.<p/>


Wir haben im Zuge der Methode <tt>filter</tt> schon eine Lösung für
die Methode <tt>contains</tt> quasi umsonst bekommen. Diese Lösung hat
alle Knoten die das fragliche Objekt enthalten in einer Liste
gesammelt und gekuckt, ob die Liste leer ist oder nicht. 
Dieses Prinzip wird manchmal auch unter dem Motto: <em>representing
failure by a list of successes</em> vorgestellt. Die Ergebnisliste
zeigt die Treffer an. <tt>contains</tt> falliert, wenn diese Liste
leer ist.<p/>

Der Nachteil
an dieser Lösung war, daß der gesammte Baum durchlaufen wurde, auch
wenn z.B.<white/>die Wurzel bereits der fragliche Knoten war.
Wir entwickeln nun eine Lösung, die einen Baum nur bis zum ersten 
Auftreten des fraglichen Objektes durchläuft. Nur wenn das Objekt
nicht im Baum enthalten ist, wird der komplette Baum durchlaufen.<p/><code commandchars = "|~^"
                class = "Tree"
                lang = "java"
                sequel = "true"
                package = "name/panitz/data/tree">  public boolean contains(a o){
    //bin ich schon der gesuchte Knoten? Wenn ja ende mit erfolg
    if (mark().equals(o)) return true;

    //für jedes Kind
   for (Tree&lt;a&gt; child:theChildren()){
      //wenn es den Knoten enthält, beende mit erfolg
      if (child.contains(o)) return true;
    }
    //keiner der Knoten enthielt das Objekt
    return false;
  }</code></subsubsection>
        <subsubsection titel = "maxDepth"><tt>int maxDepth()</tt>: gibt die Länge des längsten Pfades von
der Wurzel zu einem Blatt an.<p/>

Die maximale Tiefe läßt sich relativ einfach finden. Jedes Kind wird
nach seiner maximalen Tiefe befragt und aus diesen die maximale Zahl
genommen. Schließlich wird diese um eins erhöht, für die Wurzel selbst.<code class = "Tree"
                lang = "java"
                sequel = "true"
                package = "name/panitz/data/tree">  public int maxDepth(){
    //anfangstiefe
    int result = 0;

    //für jedes Kind
   for (Tree&lt;a&gt; child:theChildren()){
      //berechne seine maximale Tiefe
      int n = child.maxDepth();

      //ist sie höher als die bisher gefundene, dann nimm diese
      if (n&gt;result) result=n;
    } 

    //erhöhe Ergebnis um eins für die Wurzel
    return result+1;
  }</code></subsubsection>
        <subsubsection titel = "getPath"><tt>List getPath(Object o)</tt>: gibt die Markierungen auf dem
Pfad von der Wurzel zu dem Knoten, der mit dem Objekt <tt>o</tt>
markiert ist, zurück. Ergebnis ist eine leere Liste, wenn ein 
Objekt gleich <tt>o</tt> nicht existiert.<p/><paragraph titel = "naive Lösung">
Fast alle Studenten haben eine Lösung entwickelt, in der die Aufgabe mit
Hilfe der Mehode <tt>contains</tt> realisiert wird. Jeder Knoten, der auf
dem Pfad zu dem fraglichen Objekt liegt, enthält diesen Knoten. Es
wird eine Ergebnisliste aufgebaut, die genau die Knoten enthält, deren
Bäume den fraglichen Knoten enthalten:<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">  public List&lt;a&gt; getPathBad(a o){
    List&lt;a&gt; result = new ArrayList&lt;a&gt;();

  //wenn Du irgendwo das Objekt enthältst, liegst Du auf den Pfad
    if (contains(o)) { result.add(mark());}

    //für jedes Kind
   for (Tree&lt;a&gt; child:theChildren()){
      //füge den Pfad zum fraglichen Objekt hinzu
      result.addAll(child.getPathBad(o));
    }
    return result;
  }</code></paragraph><paragraph titel = "Lösung höherer Ordnung mit Hilfe von filter">
Die obige Lösung ist wieder von der Art: selektiere alle Knoten mit
einer bestimmten Eigenschaft aus den Baum. Die Eigenschaft ist keine
lokal den Knoten betreffende Eigenschaft, sondern die Tatsache, daß
der Teilbaum das Objekt enthält. Wir können also auch für diese
Aufgabe die Methode <tt>filter</tt> anwenden.<code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">public List&lt;a&gt; getPathFilter(final a o){
   return filter(
      new TreeCondition&lt;a&gt;(){
        public boolean takeThis(Tree&lt;a&gt; e){
          return e.contains(o);
        }  
      }
   );
}</code>


Spätestens jetzt merkt man, was für eine ausdrucksstarke Methode die
Methode <tt>filter</tt> durch ihren Parameter höherer Ordnung ist. </paragraph><paragraph titel = "performantere Lösung">
Beide obigen Lösungen waren schlecht, wenn wir ihr Laufzeitverhalten
betrachten. Stellen wir uns der Einfachheit halber einen zur Liste
entartetetn Baum mit <math>n</math> Knoten vor. Das einzige Blatt ist
der Knoten, zu dem der Pfad gesucht wird. Für jeden Knoten des Baumes
fragen wir, ob er das fragliche Objekt in seinem Teilbaum enthält, und
jedesmal durchlaufen wir dabei den Baum bis zu seinem Blatt, weil wir
die Methode <tt>contains</tt> aufrufen. Wir rufen 
also <math>n</math>-Mal die Methode <tt>contains</tt> auf, die
jedesmal den Baum bis zum Blatt durchläuft. Wir durchlaufen 
also <math>n+(n-1)+(n-2)+</math><dots/><math>+(n-n)</math><br/>Baumknoten, was nach der 
Summenformel <math>\frac{n * (n+1)}{2}</math> ist.<p/>

Damit haben wir einen quadratischen Aufwand in Abhängigkeit von der
Tiefe des gesuchten Pfades. Quadratische Aufwände sind unbedingt zu
vermeiden, weil mit zunehmender Datengröße die Laufzeit eines
Algorithmus enorm schnell zunimmt.<p/>


Wir können mit einem kleinen Trick, auf die Benutzung der 
Methode <tt>contains</tt> verzichten. Hierzu erinnern wir uns an das
Prinzip, einen Fehlschlag durch eine leere Liste zu
charakterisieren. Wir fragen einfach jedes Kind nach seinem Pfad zu
dem bewußten Objekt. Wenn diese Pfad leer ist, so enthält das Kind
diesen Knoten nicht. Sobald ein Kind uns einen nichtleeren Pfad gibt,
benutzen wir die überladene Methode <tt>add</tt> der
Listenschnittstelle, die uns erlaubt, ein Element an eine beliebige
Stelle einer Liste einzufügen. 
 <code class = "Tree"
                  lang = "java"
                  sequel = "true"
                  package = "name/panitz/data/tree">  public List&lt;a&gt; getPath(a o,List&lt;a&gt; result){
    //bist Du selbst der Knoten, 
    //dann ende mit der einelementigen Liste
    if (mark().equals(o)) { result.add(mark()); return result;}

   for (Tree&lt;a&gt; child:theChildren()){
      //berechne Pfad vom Kind zum Objekt 
      final List&lt;a&gt; path = child.getPath(o,result);

      //Kind hat einen solchen Pfad
      if (!path.isEmpty()){
        //hänge Dich vorne dran
        result.add(0,mark());
        //und fertig
        return result;
      }
    }
    return result;
  }</code>

Da wir oben die akkumulative Methode geschrieben haben, benötigen wir
noch eine kapselnde Methode, in der die Ergebnisliste erzeugt wird:<code>  public List&lt;a&gt; getPath(a o){
      return getPath(o,new ArrayList&lt;a&gt;());
  }</code></paragraph></subsubsection>
        <subsubsection titel = "iterator"><tt>java.util.Iterator iterator()</tt>: 
erzeugt ein Iterator
über alle Knotenmarkierungen des Baumes.<p/>

Wir brauchen einen Iterator, der alle Markierungen des Baumes
durchläuft. Wir können es und hier sehr einfach machen. Anstatt eine
eigene Iteratorklasse zu implementieren, die über die Knoten eines
Baumes läuft, können wir einfach unsere schon bestehende 
Methode <tt>flatten</tt> benutzen, die die Elemente eines Baumes in
eine Liste steckt, um dann einfach den Iterator dieser Liste zu
benutzen: <code class = "Tree"
                lang = "java"
                sequel = "true"
                package = "name/panitz/data/tree">  public Iterator&lt;a&gt; iterator(){
      return flatten().iterator();  
  }</code></subsubsection>
        <subsubsection titel = "sameStructure"><tt>boolean sameStructure(Tree other)</tt>: 
soll genau dann wahr
sein, wenn der Baum <tt>other</tt> die gleiche Struktur hat. <p/>

Zur Lösung durchlaufen wir die Struktur beider Bäume in gleicher
Weise, so lange bis, wir einen Unterschied in ihrer Struktur gefunden
haben. Falls wir, ohne auf eine Widerlegung der Strukturgleichheit zu
stoßen, beide Bäume komplett durchlaufen haben, dann haben beide Bäume
die gleiche Struktur.<code class = "Tree"
                lang = "java"
                sequel = "true"
                package = "name/panitz/data/tree">  public &lt;b&gt; boolean sameStructure(Tree&lt;b&gt; other){
    //haben beide Bäume gleich viel Kinder. 
    if(this.theChildren().size()!=other.theChildren().size())
        //wenn nein, dann sind sie nicht strukturgleich
        return false;

    //Iteriere über die Kinder beider Bäume
    Iterator&lt;Tree&lt;a&gt;&gt; it1=this.theChildren().iterator();
    Iterator&lt;Tree&lt;b&gt;&gt; it2=other.theChildren().iterator();

    //solange es noch Kinder gibt
    while (it1.hasNext()){
      //hohle das nächste Kind beider Bäume
      final Tree&lt;a&gt; thisChild = it1.next();
      final Tree&lt;b&gt; otherChild =it2.next();

      //sind diese nicht strukturgleich, dann breche ab
      if (!thisChild.sameStructure(otherChild)) return false;
    }
    
    //die Strukturgleichheit wurde nie verletzt
    return true;
  }</code>

Die einzige Schwierigkeit, die viele Studenten bei dieser Aufgabe
hatten, war gleichzeitig durch zwei Kinderlisten zu iterieren. Hierzu
bedarf es zweier Iteratoren, die aber in nur einer Schleife
gleichzeitig immer um eins weitergeschaltet werden.</subsubsection>
        <subsubsection titel = "equals"><tt>public boolean equals(Object other)</tt>: 
soll genau dann
wahr sein, wenn <tt>other</tt> ein Baum ist, der die gleiche Struktur und
die gleichen Markierungen hat.<p/>

Wir können mit der obigen Lösung sehr schnell zu einer Lösung
kommen. Entweder wir kopieren die Methode der Strukturgleichheit und
fügen noch einen zusätzlichen Test ein, ob die Knotenmarkierungen
gleich sind:<code>if (!this.mark().equals(other.mark())) return false;</code>

Oder aber, wir prüfen erst auf Strukturgleichheit und vergleichen dann
die Listen der Knoten beider Bäume auf Gleichheit.<code class = "Tree"
                lang = "java"
                sequel = "true"
                package = "name/panitz/data/tree">  public &lt;b&gt; boolean equals(Tree&lt;b&gt; other){
      if (!this.sameStructure(other)) return false;
      return this.flatten().equals(other.flatten());
  }</code>
Diese Lösung ist zwar schön kurz, aber durchläuft den Baum zweimal:
      einmal, um die Struktur zu testen und ein zweites Mal um die
      Markierungen auf Gleichheit zu testen. <p/>

In der Aufgabe war die Gleichheitsmethode mit dem Parameter des 
Typs <tt>Object</tt> verlangt. Hierzu wird erst der Parameter
untersucht, ob er überhaupt ein Baum ist, und dann erst mit den
eigentlichen Vergleich begonnen:<code commandchars = "|~^"
                lang = "java"
                class = "Tree"
                sequel = "true"
                package = "name/panitz/data/tree">  public boolean equals(Object other){
      if (! (other instanceof Tree)) return false;
      Tree&lt;?&gt; o = (Tree&lt;?&gt;) other;
      return this.equals(o);
  }</code>

Dies ist eine typische Implementierung für die Gleichheit. Es soll in
den meisten Fällen nur Gleiches mit Gleichen verglichen werden.</subsubsection>
      </subsection><subsection titel = "Eltern und Geschwister">
Wir können in unserer Implementierung von einem Knoten nicht mehr 
 seinen Eltern- und seine Geschwisterknoten
angeben. Wir können nur einen Baum von der Wurzel an zu den Blätter
durchlaufen, aber nicht umgekehrt, von einem beliebiegen Knoten zurück
zur Wurzel laufen. Dieses liegt daran, daß wir keinerlei  Verbindung
von einem Kind zu seinem Elternknoten haben. Wenn wir eine solche
haben wollen, müssen wir hierfür ein Feld vorsehen. Wir ergänzen 
die Klasse <tt>Tree</tt> somit um ein weiteres Feld.<code class = "Tree"
              lang = "java"
              package = "name/panitz/data/tree"
              sequel = "true">
  public Tree&lt;a&gt; parent=null;
</code><p/>
Für einen neuen Baumknoten, der neu erzeugt wird, ist das Feld auf den
Elternknoten zunächst auf <tt>null</tt> gesetzt. Erst wenn ein
Baumknoten als Kind in einen Baum eingehängt wird, ist sein Feld für
den Elternknoten auf den entsprechenden Baum zu setzen:<code class = "Tree"
              lang = "java"
              package = "name/panitz/data/tree"
              sequel = "true">  public Tree(a mark,List&lt;Tree&lt;a&gt;&gt; children){
    //setze die entsprechenden Felder des Knotens
    this.mrk=mark;
    this.chldrn=children;

    //es gibt noch keinen Elternknoten
    this.parent=null;

    //setze den neuen Knoten als Elternknoten der Kinder
    respectParents();  
  }

 public void respectParents(){
   //für jedes Kind
   for (Tree&lt;a&gt; child:theChildren()){
    // ist dieser Knoten jetzt der Elternknoten
    child.parent=this;
   }
 }</code>
Jetzt haben wir allerdings eine neue Situation. Bisher konnten wir Baumknoten
   mehrfach in einen Baum einhängen oder einen Knoten in mehrere Bäume
   einhängen. Das geht jetzt nicht mehr. Zwei Bäume können sich nicht mehr
   einen Knoten teilen, denn der Knoten kann ja nur einen Elternknoten
   speichern. Wir modifizieren jedesmal das Feld <tt>parent</tt>, wenn wir
   einen Knoten als Kinderknoten einen neuen Baumknoten übergeben.<aufgabe>Schreiben Sie eine Methode <tt>List&lt;Tree&lt;a&gt;&gt; siblings()</tt>, 
die die Geschwister eines Knotens
als Liste ausgibt. In dieser Liste der Geschwister soll der Knoten
selbst nicht auftauchen.</aufgabe></subsection><subsection titel = "Modifizierende Methoden">
Bisher haben wir eine rein funktionale Umsetzung von
Bäumen erarbeitet. Einmal erzeugte Bäume sind unveränderbar.
Die einzige Ausnahme war hierbei das Feld <tt>parent</tt>, das geändert wurde,
sobald ein Knoten in einen Baum eingehängt wurde.<p/>

 Die
Felder der Klasse <tt>Tree</tt> sind privat. Es gibt keine Methoden,
die sie verändern. Ebenso war auch unsere Listenimplementierung
gehalten. Die Java Standardsammlumgsklassen haben im Gegensatz dazu
Methoden, die ein Listenobjekt verändern.<p/>

Wir können für unsere Klasse <tt>Tree</tt> auch solche modifizierenden
Methoden implementieren. Solche Methoden fügen typischer Weise einen
neuen Knoten in einen Baum ein oder löschen Knoten. Da es
modifizierende Methoden sind, empfiehlt es sich, sie 
als <tt>void</tt>-Methoden zu schreiben.<subsubsection titel = "addChild">
Wir schreiben eine Methode, die an einen Knoten als letztes Kind einen
neuen Knoten einfügt:<code class = "Tree"
                lang = "java"
                package = "name/panitz/data/tree"
                sequel = "true">public void addChild(Tree&lt;a&gt; newChild){
  List&lt;Tree&lt;a&gt;&gt; chs = theChildren();
  newChild.parent=this;
  chs.add(newChild);
}</code>
Es wird direkt auf dem Feld mit der Liste der Kinder operiert und die
  modifizierende methode <tt>add</tt> aus der 
Schnitstelle <tt>List</tt> benutzt.</subsubsection><subsubsection titel = "addLeaf">
Eine weitere Methode fügt dem Baum ein neues Blatt ein:<code class = "Tree"
                lang = "java"
                package = "name/panitz/data/tree"
                sequel = "true">public void addLeaf(a o){addChild(new Tree&lt;a&gt;(o));}</code></subsubsection><subsubsection titel = "deleteChild">
Folgende Methode löscht das <m>n</m>-te Kind aus einem Knoten:<code class = "Tree"
                lang = "java"
                package = "name/panitz/data/tree"
                sequel = "true">public void deleteChild(int n){
   theChildren().remove(n);    
}</code>
In dieser Implementierung wird die modifizierte Liste durch die
   Methode <tt>theChildren()</tt> ermittelt, anstatt auf das 
Feld <tt>chldrn</tt> direkt zuzugreifen.</subsubsection><subsubsection titel = "setMark">
Das Feld <tt>mrk</tt> hat das Attribut <tt>private</tt>. Wollen wir
seinen Wert aus einem anderen Kontext ändern, so brauchen wir eine
Methode, die dieses macht. Wir können eine 
typische <tt>Set</tt>-Methode schreiben:<code class = "Tree"
                lang = "java"
                package = "name/panitz/data/tree"
                sequel = "true">public void setMark(a mark){mrk=mark;}</code></subsubsection><subsubsection titel = "Beispiel: Baumerzeugung mit modifizierenden Methoden">
          <code class = "SkriptTree"
                package = "name/panitz/data/tree/example"
                lang = "java">package name.panitz.data.tree.example;

import  name.panitz.data.tree.Tree;
public class SkriptTree{
  public static Tree&lt;String&gt; getSkript(){
    Tree&lt;String&gt; skript = new Tree&lt;String&gt;(&quot;Programmieren 2&quot;);

    Tree&lt;String&gt; kap1=new Tree&lt;String&gt;(&quot;Frühe und späte Bindung&quot;);
    Tree&lt;String&gt; kap2   
     = new Tree&lt;String&gt;
        (&quot;Graphische Benutzeroberflächen und Graphiken&quot;);
    Tree&lt;String&gt; kap3   
     = new Tree&lt;String&gt;(&quot;Abstrakte Datentypen&quot;);

    skript.addChild(kap1);
    skript.addChild(kap2);
    skript.addChild(kap3);

    kap1.addLeaf(&quot;Wiederholung: Das Prinzip der späten Bindung&quot;);
    kap1.addLeaf(&quot;Keine späte Bindung für Felder&quot;);
    kap1.addLeaf(&quot;Keine Späte Bindung für überladene Methoden&quot;);

    Tree&lt;String&gt; sec2_1   
     = new Tree&lt;String&gt;(&quot;Graphische Benutzeroberflächen&quot;);
    Tree&lt;String&gt; sec2_2   
     = new Tree&lt;String&gt;(&quot;Exkurs: verschachtelte Klassen&quot;);
    Tree&lt;String&gt; sec2_3   
     =new Tree&lt;String&gt;(&quot;Selbstdefinierte graphische Komponenten&quot;);
    Tree&lt;String&gt; sec2_4   
     = new Tree&lt;String&gt;(&quot;Weitere Komponente und Ereignisse&quot;);
    Tree&lt;String&gt; sec2_5   
     = new Tree&lt;String&gt;(&quot;Swing und Steuerfäden&quot;);

    kap2.addChild(sec2_1);kap2.addChild(sec2_2);
    kap2.addChild(sec2_3);kap2.addChild(sec2_4);
    kap2.addChild(sec2_5);

    Tree&lt;String&gt; sec3_1   
     = new Tree&lt;String&gt;(&quot;Bäume&quot;);
    Tree&lt;String&gt; sec3_2   
     = new Tree&lt;String&gt;(&quot;Algorithmen auf Bäumen&quot;);
    Tree&lt;String&gt; sec3_3
     = new Tree&lt;String&gt;(&quot;Binärbäume&quot;);
    Tree&lt;String&gt; sec3_4
     = new Tree&lt;String&gt;(&quot;Binäre Suchbäume&quot;);
    Tree&lt;String&gt; sec3_5
     = new Tree&lt;String&gt;(&quot;XML-Dokumente als Bäume&quot;);
    Tree&lt;String&gt; sec3_6
     = new Tree&lt;String&gt;(&quot;Keller&quot;);

    kap3.addChild(sec3_1);kap3.addChild(sec3_2);
    kap3.addChild(sec3_3);kap3.addChild(sec3_4);
    kap3.addChild(sec3_5);kap3.addChild(sec3_6);

    sec2_1.addLeaf(&quot;Graphische Komponenten&quot;);
    sec2_1.addLeaf(&quot;Ereignisbehandlung&quot;);
    sec2_1.addLeaf(&quot;Setzen des Layouts&quot;);

    sec2_2.addLeaf(&quot;Innere Klassen&quot;);
    sec2_2.addLeaf(&quot;Anonyme Klassen&quot;);
    sec2_2.addLeaf(&quot;Statisch verschachtelte Klassen&quot;);

    sec2_3.addLeaf(&quot;Graphics Objekte&quot;);
    sec2_3.addLeaf(&quot;Dimensionen&quot;);
    sec2_3.addLeaf(&quot;Farben&quot;);
    sec2_3.addLeaf(&quot;Fonts und ihre Metrik&quot;);
    sec2_3.addLeaf(&quot;Erzeugen graphischer Dateien&quot;);
    sec2_3.addLeaf(&quot;Graphics2D&quot;);

    sec2_4.addLeaf(&quot;Mausereignisse&quot;);
    sec2_4.addLeaf(&quot;Fensterereignisse&quot;);
    sec2_4.addLeaf(&quot;Weitere Komponenten&quot;);

    sec2_5.addLeaf(&quot;Timer in Swing&quot;);
    sec2_5.addLeaf
     (&quot;SwingWorker für Steuerfäden in der Ereignisbehandlung&quot;);
    return skript;
  }
}</code>
        </subsubsection><aufgabe>
Schreiben Sie eine modifizierende 
Methode<br/><tt>void deleteChildNode(int n)</tt>,<br/>die den <m>n</m>-ten 
Kindknoten löscht, und stattdessen die Kinder des <m>n</m>-ten Kindknotens
als neue Kinder mit einhängt. <br/><b>Beispiel:</b><br/><minipage dimension = "0.35\textwidth">
            <verb>          a
         / \
        /   \
       b     c
      / \   / \
     d   e  f  g
           /|\ 
          h i j</verb>
          </minipage><minipage dimension = "0.3\textwidth">wird durch<br/><tt>deleteChildNode(1)</tt><br/>zu:</minipage><minipage dimension = "0.35\textwidth">
            <verb>          a
         /|\
        / | \
       /  |  \
      /   |   \
     b    f    g
    /|   /|\
   d e  h i j</verb>
          </minipage></aufgabe></subsection></section><section titel = "Binärbäume">
Listen sind Bäume, in denen jeder Knoten maximal ein Kind
hat. Binärbäume sind Bäume, in denen jeder Knoten maximal zwei Kinder
hat. Wir können eine Unterklasse von <tt>Tree</tt> schreiben, in der
ein Konstruktor sicherstellt, daß ein Knoten maximal zwei Kinder hat.<p/>
Wir wollen zusätzlich zulassen, daß es ein rechtes aber kein linkes
Kind gibt. Dafür stellen wir  zwei Felder zur Verfügung, die die
entsprechenden Kinder enthalten. Existiert ein Kind nicht, so sei das
entsprechende Feld mit <tt>null</tt> belegt.<p/>
Damit wir die geerbten Methoden fehlerfrei benutzen können, müssen wir
sicherstellen, daß die Methode <tt>children</tt> auch für diese
Unterklasse gemäß der Spezifikation funktioniert.<code lang = "java"
            class = "BinTree"
            package = "name/panitz/data/tree">package name.panitz.data.tree; 

import java.util.List;
import java.util.ArrayList;

public class BinTree&lt;a&gt; extends Tree&lt;a&gt;{

  //private Felder für rechtes und linkes Kind
  private BinTree&lt;a&gt; rght;
  private BinTree&lt;a&gt; lft;</code>
Wir sehen zwei naheliegende Konstuktoren vor:<code lang = "java"
            class = "BinTree"
            sequel = "true"
            package = "name/panitz/data/tree">  public BinTree(BinTree&lt;a&gt; left,a mark,BinTree&lt;a&gt; right){
    super(mark);lft=left; rght=right;} 

  public BinTree(a mark){this(null,mark,null);}</code>
Zwei Selektormethoden greifen auf das linken bzw.<white/>
    rechte Kind zu:<code lang = "java"
            class = "BinTree"
            sequel = "true"
            package = "name/panitz/data/tree">  public BinTree&lt;a&gt; left(){return lft;}
  public BinTree&lt;a&gt; right(){return rght;}</code>
Wir müssen die Methode <tt>theChildren</tt> überschreiben. Die Kinder
befinden sich nicht mehr in einer Liste gespeichert sondern in den
zwei speziellen hierfür angelegten Feldern:<code lang = "java"
            class = "BinTree"
            sequel = "true"
            package = "name/panitz/data/tree">  public List&lt;Tree&lt;a&gt;&gt; theChildren(){
    List&lt;Tree&lt;a&gt;&gt; result = new ArrayList&lt;Tree&lt;a&gt;&gt;();
    if (left()!=null)  result.add(left());
    if (right()!=null) result.add(right());
    return result;
  }</code><subsection titel = "Probleme der Klasse BinTree">
Als Unterklasse der Klasse <tt>Tree</tt> erben wir sämtliche Methoden
der Klasse <tt>Tree</tt>. Das ist zunächst einmal positiv, weil wir
automatisch Methoden wie <tt>count</tt> oder <tt>flatten</tt> erben
und nicht
neu zu implementieren brauchen.<p/>

Leider spielen uns die modifizierenden Methoden der 
Klasse <tt>Tree</tt> dabei einen Streich. Kurz gesagt: sie
funktionieren nicht für die Klasse <tt>BinTree</tt>. Sie modifizieren
die Liste der Kinder, wie wir sie von der 
Methode <tt>theChildren()</tt> erhalten. Diese Liste ist in der 
Klasse <tt>BinTree</tt> transient, d.h.<white/>sie wird nicht
im Objekt direkt gespeichert, sondern jeweils neu aus den beiden
Feldern <tt>rght</tt> und <tt>lft</tt> erzeugt. Eine Modifikation an
dieser Liste hat also keinen bleibenden (persistenten) Effekt.<p/>

Andererseits ist dieses eine gute Eigenschaft, denn damit wird
verhindet, daß eine modifizierende Methode die Binäreigenschaft
zerstört. Die Methode <tt>addChild</tt> könnte sonst einen binären
Baum an einem Knoten ein drittes Kind einfügen.<p/>

Es empfiehlt sich trotzdem, dieses Problem nicht stillschweigend
hinzunehmen, und eine entsprechende Ausnahme zu werfen. Daher fügen
wir der Klasse <tt>BinTree</tt> folgende Variante der 
Methode <tt>addLeaf</tt> hinzu:<code lang = "java"
              class = "BinTree"
              sequel = "true"
              package = "name/panitz/data/tree">public void addLeaf(a o){
    throw new UnsupportedOperationException();
}</code><p/>
Für die Methode <tt>deleteChild</tt> können wir eine Variante
    anbieten, die auf binären Bäumen funktioniert.<code lang = "java"
              class = "BinTree"
              sequel = "true"
              package = "name/panitz/data/tree">public void deleteChild(int n){
  if (n==0) lft=null;
  else if (n==1) rght=null;
  else throw new IndexOutOfBoundsException ();
}</code>

Modifizierende Methoden, die ungefährlich für die Binärstrukrur der
Bäume sind, setzen die beiden Kinder eines Baumes neu:<code lang = "java"
              class = "BinTree"
              sequel = "true"
              package = "name/panitz/data/tree">  void setLeft(BinTree&lt;a&gt; l){ lft=l;}
  void setRight(BinTree&lt;a&gt; r){ rght=r;}</code><aufgabe>Überschreiben Sie die 
Methoden <tt>addLeaf</tt> und <tt>deleteChildNode</tt> in
der Klasse <tt>BinTree</tt>, so daß sie nur eine Ausnahme werfen,
wenn die Durchführung der Modifikation dazu führen würde, daß das
Objekt, auf dem die Methode angewendet wird, anschließend kein
Binärbaum mehr wäre.</aufgabe></subsection><subsection titel = "Linearisieren binärer Bäume">
In der Klasse <tt>Tree</tt> haben wir eine Methode definiert, die die
Knoten eines Baumes in einer linearisierten Form in eine Liste
speichert. Wir haben uns bisher keine Gedanken gemacht, in welcher
Reihenfolge die Baumknoten in der Ergebnisliste stehen. Hierbei sind
mehrere fundamentale Ordnungen der Knoten des Baumes vorstellbar:<subsubsection titel = "Preordnung">
Unsere bisherige 
Implementierung der Methode <tt>flatten</tt> benutzt die 
Reihenfolge, in der ein Knoten in der
Ergebnisliste immer vor seinen Kindern steht und Geschwisterknoten
stets erst nach den Knoten folgen. Diese Ordnung nennt man Preordnung.
In der Preordnung kommt die Wurzel eines Baumes als erstes Element der
Ergebnisliste. </subsubsection><subsubsection titel = "Postordnung">
Wie der Name vermuten läßt, ist die Postordnung gerade der umgekehrte
Weg zur Preordnung.  Jeder Knoten steht in der Liste nach allen
Kinderknoten. Die Wurzel wird damit das letzte Element der
Ergebnisliste. <aufgabe>
Schreiben Sie analog zur Methode <tt>flatten</tt> in der 
Klasse <tt>Tree</tt> eine Methode<br/><tt>List&lt;a&gt; postorder()</tt>, die die Knoten eines Baumes in 
Postordnung linearisiert.</aufgabe></subsubsection><subsubsection titel = "Inordnung">
Pre- und Postordnung kann man nicht nur auf Binärbäumen definieren,
sondern allgemein für alle Bäume. Die dritte Variante hingegen, die
Inordnung, kann nur für Binärbäume sinnvoll definiert werden. Hier
steht jeder Knoten nach allen Knoten seines linken Kindes und vor
allen Knoten seines rechten Kindes.<code lang = "java"
                class = "BinTree"
                sequel = "true"
                package = "name/panitz/data/tree">public List&lt;a&gt; inorder(){
  //Ergebnisliste
  List&lt;a&gt; result = new ArrayList&lt;a&gt;();
 
  //gibt es ein linkes Kind, füge dessen 
  //Linearisierung hinzu
  if (left()!=null) result.addAll(left().inorder());

  //dann den Knoten selbst
  result.add(mark());

  //und gegebenenfalls dann das recte Kind
  if (right()!=null) result.addAll(right().inorder());

  return result;
}</code>

Pre-, Post- und Inordnung entsprechen der Pre-, Post- und
Infixschreibweise von Operatorausdrücken. Betrachtet man einen
Operatorausdruck als Baum mit dem Operator als Wurzel und den beiden
Operanden als Kindern, dann ergibt sich die Analogie sofort. </subsubsection><subsubsection titel = "Militärordnung">
Eine Ordnung, die der Baumstruktur sehr entgegen steht, ist die
sogenannte Militärordnung. Diese Ordnung geht ebenenweise
vor. Geschwisterknoten stehen in der Liste direkt
nebeneinander. 
Abbildung<white/><ref name = "military"/> veranschaulicht diese
 Ordnung:<bild name = "military"
                pdfscale = "0.5"
                psscale = "0.8"
                caption = "Schematische Darstellung der Militärordnung."/>  

Zunächst wird die Wurzel genommen, dann der Reihe nach alle Kinder der
Wurzel, dann die Kinder der Kinder usw.  Es werden also alle Knoten
einer Generation hintereinander geschrieben. Diese Ordnung entspricht
nicht der rekursiven Definition einer Baumstruktur. Daher ist ihre
Implementierung auch nicht sehr elegant. Hierfür sind ein paar
Hilfslisten zu verwalten. Eine  Liste für die aktuelle Generation und
eine in der die Knoten der nächsten Generation gesammelt werden.<code lang = "java"
                class = "BinTree"
                sequel = "true"
                package = "name/panitz/data/tree">public List military(){
  //Ergebnisliste enthält erst diesen Knoten
  List&lt;a&gt; result=new ArrayList&lt;a&gt;();
  result.add(mark());

  //Wir speichern uns die Knoten einer 
  //aktuellen Generation
  List&lt;Tree&lt;a&gt;&gt; currentGeneration = theChildren();

  //Solange es in der aktuellen Generation Knoten gibt
  while (!currentGeneration.isEmpty()){
    //erzeuge die nächste Generation
    List&lt;Tree&lt;a&gt;&gt; nextGeneration=new ArrayList&lt;Tree&lt;a&gt;&gt;();

    for (Tree&lt;a&gt; nextChild:currentGeneration){
      nextGeneration.addAll(nextChild.theChildren());

      //Füge das Elemente der aktuellen Generation 
      //zum Ergebnis
      result.add(nextChild.mark());
    }
    //schalte eine Generation tiefer
    currentGeneration=nextGeneration;
  } 
  return result;
}}</code><aufgabe>Rechnen Sie auf dem Papier ein Beispiel für die Arbeitsweise
der Methode <tt>military()</tt>.</aufgabe></subsubsection></subsection></section><section titel = "Binäre Suchbäume">
Binärbäume können dazu genutzt werden, um Objekte effizient gemäß
einer Ordnung zu speichern und effizient nach ihnen unter Benutzung
dieser Ordnung wieder zu suchen. Die Knotenmarkierungen sollen hierzu
nicht mehr beliebige Objekte sein, sondern Objekte, die die
Schnittstelle <tt>Comparable</tt> implementieren. Solche Objekte
können mit beliebigen Objekten verglichen werden, so daß sie eine
Ordnungsrelation haben.<p/>
Binäre Bäume sollen diese Eigenschaft so ausnutzen, daß für einen
Knoten gilt:<itemize>
        <item>jede Knotenmarkierung eines linken Teilbaums ist kleiner oder
gleich als die Knotenmarkierung.</item>
        <item>jede Knotenmarkierung eines rechten Teilbaums ist größer als die
Knotenmarkierung.</item>
      </itemize>

Man erkennt, daß die Konstruktion solcher Bäume  nicht mehr lokal
geschehen kann, indem der linke und der rechte Teilbaum in einem neuen
Knoten zusammengefasst werden. Bei der Baumkonstruktion ist ein neuer
Knoten entsprechend der Ordnung an der richtige Stelle als Blatt
einzuhängen. <p/>

Wir schreiben eine 
Unterklasse <tt>SearchTree</tt> der Klasse <tt>BinTree</tt>. Diese hat
nur einen Konstruktor, um einen Baum mit nur einem Wurzelknoten zu
konstruieren. Weitere Knoten können mit der Methode <tt>insert</tt> in
den Baum eingefügt werden. Die Methode <tt>insert</tt>  stellt sicher,
daß der Baum die größer Relation der Elemente berücksichtigt. Die
Elemente des Baumes müssen die 
Schnittstelle <tt>Comparable</tt> implementieren. <code lang = "java"
            class = "SearchTree"
            package = "name/panitz/data/tree">package name.panitz.data.tree;

public class SearchTree&lt;a extends Comparable&lt;a&gt;&gt; 
                                  extends BinTree&lt;a&gt;{</code>
Wir sehen nur einen Konstruktor vor, der ein Blatt erzeugt<code lang = "java"
            class = "SearchTree"
            sequel = "true"
            package = "name/panitz/data/tree">  SearchTree(a o){super(o);}</code>
Suchbäume wachsen durch eine modifizierende Einfügeoperation:<code lang = "java"
            class = "SearchTree"
            sequel = "true"
            package = "name/panitz/data/tree">  public void insert(a o){
    if (o.compareTo(mark())&lt;=0){
      //neuer Knoten ist kneiner, also in den 
      //linken Teilbaum
      if (left()==null){
        setLeft(new SearchTree&lt;a&gt;(o));
      }else 
        ((SearchTree&lt;a&gt;)left()).insert(o);
    }else{
      //wenn der neue Knoten also größer, dann dasselbe
      //im rechten Teilbaum
      if (right()==null){
         setRight(new SearchTree&lt;a&gt;(o));
      }else 
        ((SearchTree&lt;a&gt;)right()).insert(o);
    }
  }
</code>

Wir können für interne Zwecke einen Konstruktor vorsehen, der einen
Suchbaum direkt aus den Kindern konstruiert. Hierbei wollen wir uns
aber nicht darauf verlassen, daß dem Konstruktor solche Teilbäume und
eine solche Knotenmarkierung übergeben werden, daß der resultierende
Baum ein korrekter Suchbaum ist.<code lang = "java"
            class = "SearchTree"
            sequel = "true"
            package = "name/panitz/data/tree">private SearchTree
           (SearchTree&lt;a&gt; l,a o,SearchTree&lt;a&gt; r){
  super(l,o,r);
  try {
   if (!(   o.compareTo(l.mark())&gt;=0
         &amp;&amp; o.compareTo(r.mark())&lt;=0))
     throw new IllegalArgumentException
     (&quot;ordering violation in search tree construction&quot;);
  }catch(NullPointerException _){
  }
}</code>

Die <tt>if</tt>-Bedingung mit der Prüfung auf eine Eigenschaft der
Parameter ist ein typischer Fall für eine Zusicherung, wie sie seit
Javas Version 1.4 ein fester Bestandteil von Java ist.<p/>


Die Linearisierung eines binären Suchbaums in Inordnung ergibt eine
sortierte Liste der Baumknoten, wie man sich mit folgenden Test
vergegenwärtigen kann:<code lang = "java"
            class = "TestSearchTree"
            package = "name/panitz/data/tree">package name.panitz.data.tree;
import javax.swing.*;

public class TestSearchTree {
  public static void main(String [] args){
    SearchTree&lt;String&gt; t = new SearchTree&lt;String&gt;(&quot;otto&quot;);
    t.insert(&quot;sven&quot;);
    t.insert(&quot;eric&quot;);
    t.insert(&quot;lars&quot;);
    t.insert(&quot;uwe&quot;);
    t.insert(&quot;theo&quot;);
    t.insert(&quot;otto&quot;);
    t.insert(&quot;kai&quot;);
    t.insert(&quot;henrik&quot;);
    t.insert(&quot;august&quot;);
    t.insert(&quot;berthold&quot;);
    t.insert(&quot;arthur&quot;);
    t.insert(&quot;arno&quot;);
    t.insert(&quot;william&quot;);
    t.insert(&quot;tibor&quot;);
    t.insert(&quot;hassan&quot;);
    t.insert(&quot;erwin&quot;);
    t.insert(&quot;anna&quot;);
    System.out.println(t.inorder());

/*    JFrame frame = new JFrame(&quot;Baum Fenster&quot;);
    frame.getContentPane().add(new DisplayTree(t));
    frame.pack();
    frame.setVisible(true);*/
  }
}</code>
Das Programm führt zu folgender Ausgabe auf der Kommandozeile.<scode>sep@swe10:~/fh/prog2/beispiele/Tree&gt; java TestSearchTree
[anna, arno, arthur, august, berthold, eric, erwin, hassan, henrik,
kai, lars, otto, otto, sven, theo, tibor, uwe, william]
sep@swe10:~/fh/prog2/beispiele/Tree&gt;</scode><aufgabe>Zeichnen Sie schrittweise die Baumstruktur, die im 
Programm <tt>TestSearchTree</tt> aufgebaut wird.</aufgabe><subsubsection titel = "Beweis der Sortiereigenschaft">
Wir haben oben behauptet und experiementell an einem Beispiel
ausprobiert, daß die Inordnung eines binären Suchbaums eine
sortierte Liste als Ergebnis hat. Wir wollen jetzt versuchen diese
Aussage zu beweisen.<p/>

Zum Beweis einer Aussage über eine rekursiv definierten Datenstruktur
(wie Listen und Bäume) bedient man sich der vollständigen 
Induktion.<footnote>Die im  philosophischen Sinne keine
Induktion sondern eine Deduktion ist.</footnote>  Hierbei geht die
Induktion meist über die Größe der Datenobjekte.
Als Induktionsanfang dient  das kleinste denkbare Datenobjekt, bei
Listen also leere Listen, bei Bäumen Blätter. Der Induktionsschluß
setzt dabei voraus, daß die Aussage für alle kleineren Objekte bereits
bewiesen ist, also für alle Teilobjekte (Teilbäume und Teillisten)
bereits gilt.<p/>

Beweisen wir entsprechend die Aussage, daß die Liste der Elemente eines
binären Suchbaums in Inordnung  sortiert ist:<itemize>
          <item><b>Anfang:</b> Der Induktionsanfang behauptet, die Inordung
eines Blattes ist sortiert. Für ein 
Blatt <em>k</em> gilt: <m><mT>left</mT>(<mT>k</mT>) =<mT>null</mT></m><white/>  und <m><mT>right</mT>(<mT>k</mT>) =<mT>null</mT></m>. Es folgt, daß die Inordung nur 
ein Element, nämlich <m><mT>mark</mT>(<mT>k</mT>)</m>, enthält.
Einelementige Listen sind immer sortiert.</item>
          <item><b>Schritt:</b> Wir wollen die Aussage beweisen für alle 
Bäume <m>
              <mT>k</mT>
            </m><white/> mit: <m><mT>count</mT>(<mT>k</mT>)=<mT>n</mT></m>.<p/>

Annahme: die Aussage ist wahr für alle 
Bäume <m><mT>k</mT>&#39;</m>
mit <m><mT>count</mT>(<mT>k</mT>&#39;)&lt;<mT>n</mT></m>.<p/>

Die Definition der Inordnung ist:<br/><m><mT>inorder</mT>(<mT>k</mT>) =
(<mT>inorder</mT>(<mT>left</mT>(<mT>k</mT>))
,<mT>mark</mT>(<mT>k</mT>),<mT>inorder</mT>(<mT>right</mT>(<mT>k</mT>)))</m>.<p/>

Für endliche Bäume gilt:<br/><m><mT>count</mT>(<mT>left</mT>(<mT>k</mT>)) &lt;<mT>n</mT></m> und <m><mT>count</mT>(<mT>right</mT>(<mT>k</mT>)) &lt;<mT>n</mT></m><br/>
Nach der Induktionsvoraussetzung gilt damit, 
daß<br/><mT>inorder</mT>(<mT>left</mT>(<mT>k</mT>)) und<white/><mT>inorder</mT>(<mT>right</mT>(<mT>k</mT>))<br/>
 sortierte Listen
sind.<p/>

Über die Definition der binären Suchbäume gilt:<br/>
für alle <em>x</em><m>\in<mT>inorder</mT>(<mT>left</mT>(<mT>k</mT>))</m> gilt <m><mt>x</mt>\le<mT>mark</mT>(<mT>k</mT>)</m><br/>
und für alle <em>x</em><m>\in<mT>inorder</mT>(<mT>right</mT>(<mT>k</mT>))</m> gilt <m><mt>x</mt>&gt;<mT>mark</mT>(<mT>k</mT>)</m><p/>
Damit ist insbesondere die Liste <m><mT>inorder</mT>(<mT>k</mT>)</m> sortiert.</item>
        </itemize></subsubsection><subsection titel = "Suchen in Binärbäumen">
Die Sortiereigenschaft der Suchbäume erlaubt es jetzt, die 
Methode <tt>contains</tt> so zu schreiben, daß sie maximal einen Pfad
durchlaufen muß. Es muß nicht mehr der ganze Baum betrachtet werden.<code lang = "java"
              class = "SearchTree"
              package = "name/panitz/data/tree"
              sequel = "true">public boolean contains(a o){
  //bist du es schon selbst
  if (mark().equals(o)) return true;
 
  //links oder rechts suchen:
  final int compRes = mark().compareTo(o);

  if (compRes&gt;0){
    //keine Knoten mehr. Dann ist er nicht enthalten
    if (left()==null) return false;
    //Sonst such weiter unten im Baum
    else return ((SearchTree&lt;a&gt;)left()).contains(o);
  }    

  if (compRes&lt;0){
    if (right()==null) return false;
    else return ((SearchTree&lt;a&gt;)right()).contains(o);
  }    
  return false;
}</code> 
Wie man sieht, ist die Methode in ihrer Struktur analog zur 
Methode <tt>insert</tt>.</subsection><subsection titel = "Entartete Bäume">
Bäume, die keine eigentliche Baumstruktur mehr haben, sondern nur noch
Listen sind, werden manchmal auch als entartete Bäume
bezeichnet. Insbesondere bei binären Suchbäumen verlieren wir  die
schönen Eigenschaften, nämlich daß wir maximal in der maximalen
Pfadlänge im Baum zu suchen brauchen.<aufgabe>Erzeugen Sie ein Objekt des typs <tt>SearchTree</tt> und
fügen Sie nacheinander die folgenden Elemente ein:<br/><tt>&quot;anna&quot;,&quot;berta&quot;,&quot;carla&quot;,&quot;dieter&quot;,&quot;erwin&quot;,&quot;florian&quot;,&quot;gustav&quot;</tt><br/>
Lassen Sie anschließend die maximale Tiefe des Baumes ausgeben.</aufgabe><subsubsection titel = "Balanzieren von Bäumen">
Wie wir in der letzten Aufgabe sehen konnnten, liegt es an der
Reihenfolge, in der die Elemente in einem binären Suchbaum eingefügt
werden, wie  gut ein Baum ausbalanziert ist. Wir sprechen von
einem ausbalanzierten Baum, wenn sein linker und rechter Teilbaum die
gleiche Tiefe haben. <p/>
Man kann einen Baum, der nicht ausbalanziert ist, so verändern, daß er
weiterhin ein korrekter  binärer Suchbaum in Bezug auf die Ordnung
ist, aber die Tiefen der linken und rechten Kinder ausgewogen sind, 
d.h.<white/>sich nicht um mehr als eins unterscheiden.<example>
Betrachten Sie den Baum aus Abbildung<white/><ref name = "balance"/><bild name = "balance"
                  pdfscale = "0.9"
                  psscale = "0.4"
                  caption = "Nicht balanzierter Baum."/>


Der linke Teilbaum hat eine Tiefe von 4, der rechte eine Tiefe von
2. Wir können den Baum so verändern, daß beide Kinder eine Tiefe von 3
haben. Wir bekommen den Baum aus 
Abbildung<white/><ref name = "balance2"/><bild name = "balance2"
                  pdfscale = "0.9"
                  psscale = "0.4"
                  caption = "Baum nach Rotierungsschritt."/>

Das linke Kind dieses Baumes ist auch nicht ausbalanziert, wir können
den Baum noch einmal verändern und erhalten den Baum 
in Abbildung<white/><ref name = "balance3"/>:<bild name = "balance3"
                  pdfscale = "0.9"
                  psscale = "0.35"
                  caption = "Baum nach weiteren Rotierungsschritt."/><p/></example><paragraph titel = "Spezifikation">
Zum Ausbalanzieren wird ein Baum gedreht. Einer seiner Kinderknoten
wird die neue Wurzel und die alte Wurzel dessen Kind. Es gibt zwei
Richtungen, in die gedreht werden kann: mit und gegen den
Urhzeigersinn. Schematisch lassen sich diese beiden Operationen mit
folgenden Gleichungen spezifizieren:<itemize>
              <item>rotateRight(Node(Node(l2,x2,r2),x1,r1)) = Node(l2,x2,Node(r2,x1,r1))</item>
              <item>rotateLeft(Node(l1,x1,Node(l2,x2,r2))) = Node(Node(l1,x1,l2),x2,r2)</item>
            </itemize>
In graphischer Darstellung wird die erste Gleichung zu:<p/><minipage dimension = "0.2\textwidth">
              <verb>      x1
     / \
    /   \
   x2   r1
  / \
 l2 r2</verb>
            </minipage><minipage dimension = "0.35\textwidth"><vfill/>wird mit <tt>rotateRight</tt> zu:</minipage><minipage dimension = "0.35\textwidth">
              <verb>     x2
    / \
   /   \
  l2   x1
       / \
      r2 r1</verb>
            </minipage><p/>

Die Operationen erhalten die Eigenschaft eines Suchbaumes: linke
Kinder sind kleiner, rechte Kinder größer als die Wurzel. Die
Linearisierung in der Inordnung bleibt gleich. Die maximale Tiefe der
Kinder verändert sich um 1. Die Anzahl der Knoten im Baum ändert sich
nicht. </paragraph><paragraph titel = "Implementierung">
Wir können generell zwei Umsetzungen des oben spezifizierten
Algorithmus wählen: eine die einen neues Baumobjekt erzeugt und keinde
der bestehenden Bäume modifiziert und eine, die die Felder der
bestehenden Baumknoten so umändert, daß das Objekt, auf dem die
Methode aufgerufen wird, modifiziert wird.</paragraph><paragraph titel = "Funktionale Umsetzung">
Für die funktionale Umsetzung können wir eine statische Methode
schreiben. Sie bekommt einen Baum und soll einen neuen Baum, der durch
Rotation aus den Eingabebaum entstanden ist, als Ergebnis liefern.<p/>

Die Umsetzung leitet sich direkt aus der Spezifikation über eine
Gleichung ab. Wir benutzen dieselben Bezeichner wie in der
Spezifikation. <code lang = "java"
                  class = "SearchTree"
                  package = "name/panitz/data/tree"
                  sequel = "true">public static &lt;a extends Comparable&lt;a&gt;&gt; SearchTree&lt;a&gt; 
                         rotateRight(SearchTree&lt;a&gt; t){
  try{
    //speichere die einzelnen Teile in die Bezeichner,
    //die wir in der Spezifikation benutzt haben
    final SearchTree&lt;a&gt; l2 = (SearchTree&lt;a&gt;)t.left().left();
    final SearchTree&lt;a&gt; r2 = (SearchTree&lt;a&gt;)t.left().right();
    final SearchTree&lt;a&gt; r1 = (SearchTree&lt;a&gt;)t.right();
    final a x1 = t.mark();
    final a x2 = t.left().mark();

    return new SearchTree&lt;a&gt;
                 (l2,x2,new SearchTree&lt;a&gt;(r2,x1,r1));
  }catch (NullPointerException _){
      return t;
  }
}</code>
Die Ausnahme tritt auf, wenn das linke Kind nicht existiert, also hier
der Wert <tt>null</tt> steht. Dann kann nicht nach rechts rotiert
werden (da links nichts zum Rotieren steht). In dem Fall, das nicht
  rotiert werden kann, wird der Eingabebaum unverändert ausgegeben.</paragraph><paragraph titel = "Modifizierende Umsetzung">
Wir können die modifizierende Methode zum Rotieren eines Baumes in der 
Klasse <tt>BinTree</tt> implementieren. 
Wir benutzen wieder die Bezeichner
aus unserer Spezifikation. Anstatt aber wie eben neue Knoten zu
erzeugen,  setzen die entsprechenden Referenzen um.<code lang = "java"
                  class = "SearchTree"
                  package = "name/panitz/data/tree"
                  sequel = "true">void rotateRight(){
  try{
    BinTree&lt;a&gt; l1 = left();
    BinTree&lt;a&gt; l2 = l1.left();
    BinTree&lt;a&gt; r2 = l1.right();
    BinTree&lt;a&gt; r1 = right();
    a  x1 = mark();
    a  x2 = l1.mark();

    setMark(x2);
    setLeft(l2);
    setRight(l1);
    l1.setMark(x1);
    l1.setLeft(r2);
    l1.setRight(r1);
  }catch (NullPointerException _){
  }
}}</code>
Die Ausnahme wird
schon in der zweiten Zeile geworfen, bevor Referenzen verändert
wurden. Das Objekt bleibt unverändert. Ansonsten werden die Knoten
entsprechend der Spezifikation umgehängt. <aufgabe>
              <unteraufgaben>
                <teil>Schreiben sie entsprechend die Methode:<br/>
static public SearchTree rotateLeft(SearchTree t)</teil>
                <teil>
Schreiben Sie in der Klasse <tt>BinTree</tt> die
entsprechende modifizierende Methode <tt>rotateLeft()</tt></teil>
                <teil>Testen Sie die beiden Rotierungsmethoden. Testen Sie, ob die
Tiefe der Kinder sich verändert und ob die Inordnung gleich
bleibt. Testen Sie insbesondere auch einen Fall, in dem 
die <tt>NullPointerException</tt> abgefangen wird.</teil>
              </unteraufgaben>
            </aufgabe></paragraph></subsubsection></subsection></section></kapitel>
  <kapitel titel = "Java Standardklassen">
Java kommt mit einer sehr großen und von Version zu Version wachsenden
Bibliothek von Standardklassen daher. In diesem Kapitel soll ein
Überblick über die wichtigsten Standardklassen gegeben
werden. Naturgemäß können nicht alle Standardklassen vorgestellt
werden. Man informiere sich gegebenenfalls durch die entsprechenden
Dokumentationen. Das
Hauptpaket für Javastandardklassen ist das Paket <tt>java</tt>. Es hat
folgende wichtigen Unterpakete:<itemize>
      <item><tt>java.lang</tt>: das automatisch importierte
Standardpaket. Hier finden sich die allerwichtigsten und permanent
gebrauchten Klassen, wie z.B. <tt>String</tt>, <tt>System</tt> und vor
allem auch <tt>Object</tt>. Auch die wichtigsten Ausnahmeklassen
liegen in diesem Paket.</item>
      <item><tt>java.util</tt>: hier befinden sich primär die
Sammlungsklassen und Schnittstellen für die
Sammlungsklassen. Desweiteren finden sich hier Klassen zum Umgang mit
Kalenderdaten, Zeiten oder Währungen.</item>
      <item><tt>java.io</tt>: Klassen für dateibasierte
Ein-/Ausgabe-Operationen. </item>
      <item><tt>java.applet</tt>: Klassen zum Schreiben von Applets.</item>
      <item><tt>java.awt</tt>: Klassen für graphische Komponenten.</item>
      <item><tt>javax.swing</tt>: weitere Klassen für graphische
Komponenten. Neuere Implementierung zu <tt>java.awt</tt>, die versucht,
noch generischer und plattformunabhängiger zu sein.</item>
    </itemize>

In Java gibt es noch eine Vielzahl weiterer Standardpakete mit
unterschiedlichster spezieller Funktionalität, z.B.<white/>Klassen für den
Umgang mit XML-Daten oder für die Anbindung an Datenbanken. Hier
empfiehlt es sich im entsprechenden Fall, die Dokumentation zu lesen
und nach einem Tutorial auf den Sun-Webseiten zu suchen.<section titel = "Die Klasse Objekt">
Die Klasse <tt>java.lang.Object</tt> ist die Wurzel der
Klassenhierarchie in Java. Alle Objekte erben die Methoden, die in
dieser Klasse definiert sind. Trotzdem ist bei fast allen Methoden
nötig, daß sie durch spezialisierte Versionen in den entsprechenden
Unterklassen überschrieben werden. Dieses haben wir im Laufe des
Skripts schon an der Methode <tt>toString</tt> nachverfolgen können.<subsection titel = "Die Methoden der Klasse Object">
        <subsubsection titel = "equals"><tt>public boolean equals(Object obj)</tt> ist die Methode zum Testen
auf die Gleichheit von zwei Objekten. Dabei ist die Gleichheit nicht
zu verwechseln mit der Identität, die mit dem 
Operator <tt>==</tt> getestet wird. Der Unterschied zwischen Identität
und Gleichheit läßt sich sehr schön an Strings demonstrieren:<code class = "EqualVsIdentical"
                lang = "java">class EqualVsIdentical {

  public static void main(String [] args){
    String x = &quot;hallo&quot;.toUpperCase();
    String y = &quot;hallo&quot;.toUpperCase();

    System.out.println(&quot;x: &quot;+x);
    System.out.println(&quot;y: &quot;+y);

    System.out.println(&quot;x==x        -&gt; &quot;+(x==x));
    System.out.println(&quot;x==y        -&gt; &quot;+(x==y));
    System.out.println(&quot;x.equals(x) -&gt; &quot;+(x.equals(x)));
    System.out.println(&quot;x.equals(y) -&gt; &quot;+(x.equals(y)));
  }

}</code>

Die Ausgabe dieses Tests ist:<scode>sep@swe10:~/fh/beispiele&gt; java EqualVsIdentical
x: HALLO
y: HALLO
x==x        -&gt; true
x==y        -&gt;false
x.equals(x) -&gt;true
x.equals(y) -&gt;true
sep@swe10:~/fh/beispiele&gt;</scode>

Obwohl die beiden Objekte <tt>x</tt> und <tt>y</tt> die gleichen Texte
darstellen, sind es zwei unabhängige Objekte; sie sind nicht
identisch, aber gleich.

Sofern die Methode <tt>equals</tt> für eine Klasse nicht überschrieben
wird, wird die entsprechende Methode aus der 
Klasse <tt>Object</tt> benutzt. Diese überprüft aber keine inhaltliche
Gleichheit. Es ist also zu empfehlen, die Methode <tt>equals</tt> für
alle eigenen Klassen, die zur Datenhaltung geschrieben wurden, zu
überschreiben. Dabei sollte die Methode immer folgender Spezifikation
genügen:<itemize>
            <item><b>Reflexivität</b>: es sollte immer gelten: <tt>x.equals(x)</tt></item>
            <item><b>Symmetrie</b>: wenn <tt>x.equals(y)</tt> dann auch <tt>y.equals(x)</tt></item>
            <item><b>Transitivität</b>: wenn <tt>x.equals(y)</tt> und <tt>y.equals(z)</tt> dann gilt auch <tt>x.equals(z)</tt></item>
            <item><b>Konsistenz</b>: wiederholte Aufrufe von <tt>equals</tt> auf dieselben Objekte liefern dasselbe Ergebnis, sofern die Objekte nicht
verändert wurden.</item>
            <item> nichts gleicht <tt>null</tt>: <tt>x.equals(null)</tt> ist immer falsch.</item>
          </itemize></subsubsection>
        <subsubsection titel = "hashCode"><tt>public int hashCode()</tt> ist eine Methode, die für das Objekt
eine beliebige ganze Zahl, seinen <em>hashcode</em>,
angibt<footnote>Hierbei handelt es sich in keinster Weise um
irgendwelche unerlaubten Substanzen. Mit <em>hash</em> wird im Englischen das
Nummersymbol <ttt>\#</ttt> des Gatters bezeichnet.</footnote>. Eine solche Zahl wird von vielen Algorithmen verwendet, so daß die Javaentwickler sie für so wichtig
hielten, daß sie eine Methode in der Klasse <tt>Object</tt> hierfür
vorgesehen haben.<p/>
Ein <em>Hash</em>-Verfahren funktioniert wie folgt. Stellen Sie sich vor, Sie haben ein großes Warenlager mit 1000 durchnummerierten
Regalen. Wann immer Sie ein Objekt in diesem Lager lagern wollen,
fragen Sie das Objekt nach seinem <em>Hashcode</em>. Diese Zahl nehmen Sie modulo 1000. Das Ergebnis dieser Rechnung ist eine Zahl zwischen 0
und 999. Jetzt legen Sie das Objekt in das Regal mit der
entsprechenden Nummer. Suchen Sie jetzt ein bestimmtes Objekt in ihrem
Warenlager, so können  Sie wiederum den <em>Hashcode</em> des Objektes nehmen und wissen, es kann nur in genau einem der 1000 Regale liegen. Sie brauchen also nur in einem und nicht in 1000 Regalen nach Ihrem Objekt zu suchen.<p/>
Damit ein solches Verfahren funktioniert, muß folgende Spezifikation
für die Methode <tt>hashCode</tt> erfüllt sein:<itemize>
            <item>wenn <tt>x.equals(y)</tt> dann folgt <tt>x.hashCode()==y.hashCode()</tt></item>
            <item>bleibt ein Objekt unverändert, so ändert sich auch nicht sein <em>Hashcode</em></item>
          </itemize>

Beachten Sie, daß ungleiche Objekte nicht unbedingt 
ungleiche <em>Hashwerte</em> haben.</subsubsection>
        <subsubsection titel = "clone"><tt>protected Object clone() throws CloneNotSupportedException</tt> ist 
eine Methode, die dazu dient, ein neues Objekt zu erzeugen, daß inhaltlich gleich, aber nicht identisch 
zum <tt>this</tt>-Objekt ist.
Dieses läßt sich formaler durch folgende Gleichungen
ausdrücken<footnote>Diese Gleichungen verdeutlichen noch einmal sehr den Unterschied, auf den auch Pedanten der deutschen Sprache gerne hinweisen: Das geclonete Objekt gleicht dem Original, ist aber nicht
dasselbe Objekt.</footnote>:<itemize>
            <item>
              <tt>x.clone() != x</tt>
            </item>
            <item>
              <tt>x.clone().equals(x)</tt>
            </item>
          </itemize>

Die Methode <tt>clone</tt> in der Klasse Objekt hat in der Regel schon
eine Funktionalität, die wir erwarten. Sie nimmt das Objekt und
erstellt eine Kopie von diesem Objekt. Leider gibt es in Java einen
verwirrenden Effekt. Die Methode <tt>clone</tt> verhält sich unterschiedlich, abhängig davon, ob die Klasse des gecloneten Objektes die Schnittstelle <tt>Cloneable</tt> implementiert:<code class = "NoClone"
                lang = "java">class NoClone {
  String x = &quot;hallo&quot;;
  public static void main(String [] args)
    throws CloneNotSupportedException{
    NoClone nc = new NoClone();
    NoClone cc = (NoClone)nc.clone();
    System.out.println(cc.x);
  }
}</code> Dieses Programm wirft eine Ausnahme:<scode>
sep@swe10:~/fh/beispiele&gt; java NoClone
Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: NoClone
        at java.lang.Object.clone(Native Method)
        at NoClone.main(NoClone.java:5)
sep@swe10:~/fh/beispiele&gt;</scode>

Wenn wir hingegen das Programm so ändern, daß es die 
Schnittstelle <tt>Cloneable</tt> implementiert, dann wird diese
Ausnahme nicht geworfen:<code class = "Clone"
                lang = "java">class Clone implements Cloneable {
  String x = &quot;hallo&quot;;

  public static void main(String [] args) 
      throws CloneNotSupportedException{
    Clone nc = new Clone();
    Clone cc = (Clone)nc.clone();
    System.out.println(cc.x);
  }
}</code>
Dieses Programm führt  zu einem Programmdurchlauf ohne Ausnahme:<scode>sep@swe10:~/fh/beispiele&gt; java Clone
hallo
sep@swe10:~/fh/beispiele&gt;</scode>

Besonders verwirrend scheint dieses Verhalten zu sein, weil die
Schnittstelle <tt>Cloneable</tt> überhaupt gar keine Methoden enthält,
die zu implementieren sind.</subsubsection>
        <subsubsection titel = "finalize"><tt>protected void finalize() throws Throwable</tt> ist eine Methode,
die ein ähnliches Anwendungsgebiet wie die <tt>finally</tt>-Klausel in
einer Ausnahmebehandlung hat. Wenn Java ein Objekt in seinem Speicher 
findet, von dem Java zeigen kann, daß es von keinem laufenden
Programmteil mehr genutzt wird, dann löscht Java dieses Objekt aus dem
Speicher. Bevor das Objekt vollkommen gelöscht wird, hat das Objekt
noch einen letzten Wunsch frei, indem nämlich seine 
Methode <tt>finalize</tt> aufgerufen wird. Die meisten Objekte sind
genügsam und lassen sich ohne weitere Aktion aus dem Speicher
löschen. Sobald ein Objekt aber eine externe Komponente darstellt, sei es ein Datenbankeintrag oder ein externes Programm, so ist es vielleicht notwendig, für diese externe Komponente noch Aktionen durchzuführen: die externe Komponente ist zu schließen oder z.B.<white/>ein
Datenbankeintrag zu verändern. Wenn Objekte solcherlei Aktionen benötigen, bevor sie endgültig aus dem Speicher gelöscht werden, so
ist für ihre Klasse die Methode <tt>finalize</tt> zu
überschreiben. Java gibt keinerlei Garantie darüber, wann die 
Methode <tt>finalize</tt> ausgeführt wird. Es kann relativ zufällig
sein, wie lange sich ein Objekt im Speicher befindet.<example>
Wir können einmal testen, wie Java die Objekte willkürlich aus dem Speicher
löscht. Hierzu schreiben wir eine Klasse, die in der 
Methode <tt>finalize</tt> eine Aufgabe über das Objekt auf der Kommandozeile ausgibt.<code class = "Finalize"
                  lang = "java">class Finalize {
   int i;
   Finalize(int i){this.i=i;}
   protected void finalize(){
     System.out.print(i+&quot;,&quot;);
   }</code>
In einer Hauptmethode erzeugen wir einmal nacheinander viele Objekte dieser Klasse, ohne daß wir sie irgendwie weiter benutzen wollen:<code class = "Finalize"
                  lang = "java"
                  sequel = "true">   public static void main(String [] _){
     for (int i=0;i&lt;100000;i=i+1){
       new Finalize(i);
       System.out.print(&quot;*&quot;);
     }
   }
}</code><aufgabe>Übersetzen und starten Sie die Klasse <tt>Finalize</tt> und
beobachten Sie, wie und wann Java Objekte aus dem Speicher löscht.</aufgabe></example></subsubsection>
        <subsubsection titel = "toString"><tt>public String toString()</tt> ist eine Methode, die wir schon oft benutzt oder überschrieben haben. Wenn wir sie nicht überschreiben, sondern
aus der Klasse <tt>Object</tt> erben, so bekommen wir eine textuelle
Darstellung, die sich wie folgt berechnet:<br/><tt>getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())</tt></subsubsection>
        <subsubsection titel = "weitere Methoden">
Es gibt noch einige weitere Methoden in der Klasse Objekt. Diese
beschäftigen sich allerdings alle mit Steuerfäden oder der Reflektion,
zwei Konzepten, die wir noch nicht kennengelernt haben.</subsubsection>
      </subsection></section><section titel = "String und Stringbuffer">
Die Klasse <tt>String</tt> mit einer Reihe von Methoden haben wir des öfteren
bereits kennengelernt. Zusätzlich gibt es noch die 
Klasse <tt>StringBuffer</tt>. Sie unterscheidet sich primär 
von <tt>String</tt> darin, daß ihre Objekte veränderbar sind. Der
Operator <tt>+</tt> für <tt>String</tt>-Objekte erzeugt ein neues
Objekt. In der Klasse <tt>StringBuffer</tt> existiert die 
Methode <tt>append</tt>, die ein Objekt verändert, indem es weitere
Zeichen an die Zeichenkette anhängt.<p/>
Der Unterschied ist leicht durch das folgende Programm zu
verdeutlichen:<code class = "StringVsStringBuffer"
            lang = "java">class StringVsStringBuffer {

  public static void main(String [] args){
    String a = &quot;hello&quot;;
    String b = a+&quot; world&quot;;
    System.out.println(a);

    StringBuffer ab = new StringBuffer(&quot;hello&quot;);
    StringBuffer bb = ab.append(&quot; world&quot;);
    System.out.println(ab);
  }
}</code> Programme, die nach und nach einen Ergebnisstring berechnen, werden in
der Regel ein Objekt des Typs <tt>StringBuffer</tt> erzeugen, auf das
mehrmals die Methode <tt>append</tt> ausgeführt wird. Schließlich wird
von diesem Objekt die <tt>toString</tt> Methode benutzt, um den
Ergebnisstring zu erhalten:<code class = "ReturnString"
            lang = "java">class ReturnString {

  static public String toRoman(int i){
    StringBuffer result = new StringBuffer();
    while (i&gt;=1000) {i=i-1000;result.append(&quot;M&quot;);}
    while (i&gt;=900)  {i=i-900 ;result.append(&quot;CM&quot;);}
    while (i&gt;=500)  {i=i-500 ;result.append(&quot;D&quot;);}
    while (i&gt;=400)  {i=i-400 ;result.append(&quot;CD&quot;);}
    while (i&gt;=100)  {i=i-100 ;result.append(&quot;C&quot;);}
    while (i&gt;=90)   {i=i-90  ;result.append(&quot;XC&quot;);}
    while (i&gt;=50)   {i=i-50  ;result.append(&quot;L&quot;);}
    while (i&gt;=40)   {i=i-40  ;result.append(&quot;XL&quot;);}
    while (i&gt;=10)   {i=i-10  ;result.append(&quot;X&quot;);}
    while (i&gt;=9)    {i=i-9   ;result.append(&quot;IX&quot;);}
    while (i&gt;=5)    {i=i-5   ;result.append(&quot;V&quot;);}
    while (i&gt;=4)    {i=i-4   ;result.append(&quot;IV&quot;);}
    while (i&gt;=1)    {i=i-1   ;result.append(&quot;I&quot;);}
    return result.toString();
  }
    
  public static void main(String [] args){
    System.out.println(toRoman(1999));
    System.out.println(toRoman(494));
  }

}</code></section><section titel = "Sammlungsklassen">
Wir haben in diesem Skript ausführlich eigene Listenklassen auf
unterschiedliche Weisen spezifiziert, modelliert und
implementiert. Java stellt im Paket <tt>java.util</tt>
Implementierungen von Sammlungsklassen zur Verfügung. <p/>
Die Sammlungsklassen sind über verschiedene Schnittstellen
definiert. Die Oberschnittstelle für Sammlungsklassen 
ist: <tt>java.util.Collection</tt>. Ihre Hauptunterschnittstellen sind: <tt>List</tt> und <tt>Set</tt> für die Darstellung von Listen
bzw.<white/>Mengen.<subsection titel = "Listen">
Im Gegensatz zu unseren eigenen Listen sind Listenobjekte in Java
zunächst einmal veränderbare Objekte. In unserer Modellierung gab es
keine Methode wie <tt>add</tt>, die in einer Liste ein Objekt  eingefügt hat. Bei uns wurde stets eine neue Liste mit einem
zusätzlich vorn angehängten Element erzeugt. Javas Standardlisten
haben Methoden, die den Inhalt eines Listenobjektes verändern:<itemize>
          <item><tt>add</tt> zum Hinzufügen von Elementen.</item>
          <item><tt>clear</tt> zum Löschen  aller Elemente.</item>
          <item><tt>remove</tt> zum Löschen  einzelner Elemente.</item>
        </itemize>

Der Unterschied zwischen unseren eigenen Listen und den Listen der
Javabibliothek ist ungefähr derselbe wie der zwischen der 
Klasse <tt>String</tt> und <tt>StringBuffer</tt>.<subsubsection titel = "Listenklassen">
Listen sind mit Hilfe einer abstrakten Klasse implementiert. Die
eigentlichen konkreten Klassen, die Listen implementieren, 
sind: <tt>ArrayList</tt>, <tt>LinkedList</tt> und <tt>Vector</tt>.
Dabei ist <tt>ArrayList</tt> die gebräuchlichste 
Implementierung. <tt>Vector</tt> ist eine ältere Implementierung, die
als Nachteil hat, daß sie stets eine Synchronisation für nebenläufige
Steuerfäden vornimmt, die in der Regel nicht unbedingt benötigt wird.<p/>

Folgende Klasse zeigt, wie eine Liste erzeugt wird und ihr nach und
nach Elemente hinzugefügt werden:<code class = "ListUsage"
                lang = "java">import java.util.List;
import java.util.ArrayList;

class ListUsage{

  public static void main(String [] args){
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add(&quot;hallo&quot;);
    xs.add(&quot;welt&quot;);
    xs.add(&quot;wie&quot;);
    xs.add(&quot;geht&quot;);
    xs.add(&quot;es&quot;);
    xs.add(&quot;dir&quot;);
    System.out.println(xs);
  }

}</code>
Das Programm hat folgende Ausgabe:<scode>sep@swe10:~/fh/beispiele&gt; java ListUsage
[hallo , welt , wie , geht , es , dir ]
sep@swe10:~/fh/beispiele&gt;</scode>

Wie man sieht, fügt die Methode <tt>add</tt> Objekte am Ende einer
Liste an.</subsubsection></subsection><subsection titel = "Mengen"> Im Gegensatz zu Listen können Mengenobjekte keine Elemente doppelt
enthalten. Hierbei werden zwei Objekte als gleich betrachtet, wenn
der Aufruf der Methode <tt>equals</tt> für sie den 
Wert <tt>true</tt> ergibt. Daraus folgt insbesondere, daß es nur
sinnvoll ist, Elemente zu einer Menge zuzufügen, für die auch eine
sinnvolle Überschreibung der Methode <tt>equals</tt> existiert.

Die Klasse <tt>HashSet</tt> ist eine Implementierung der  Schnittstelle <tt>Set</tt>. Sie basiert darauf, daß  die Objekte,
die in der Menge gespeichert werden sollen, eine möglichst gute
Implementierung der Methode <tt>hashCode</tt> haben. Möglichst gut
bedeutet in diesem Fall, daß in möglichst vielen Fällen  gilt: <quote>Aus <tt>!x.equals(y)</tt> folgt <tt>x.hashCode != y.hashCode()</tt></quote></subsection><subsection titel = "Iteratoren">
Java stellt eine Schnittstelle <tt>Iterator</tt> bereit. Ihr einziger
Zweck ist, zu beschreiben, daß durch eine Sammlung von Elementen
durchiteriert werden kann. 

Ein Iterator kann nacheinander gebeten werden, sein nächstes Element auszugeben, und ein Iterator kann gefragt werden, ob es noch weitere
Elemente gibt.

Hierzu gibt es die entsprechenden Methoden:<itemize>
          <item><tt>Object next()</tt>, die den Iterator um ein Element
weiterschaltet und das aktuelle Element als Ergebnis hat.</item>
          <item><tt>boolean hasNext()</tt>, die <tt>true</tt> als Ergebnis hat,
wenn die Methode <tt>next</tt> ein weiteres Element liefert.</item>
        </itemize> 



Iteratoren sind zum einmaligen Gebrauch gedacht. Sie werden benutzt,
um einmal durch die Elemente einer Sammlung durchzuiterieren. <subsubsection titel = "Iterator für Li">

Am einfachsten können wir das Prinzip eines Iteratorobjekts verstehen,
wenn wir eine entsprechende Iteratorklasse für unsere eigenen Listen
schreiben: <code class = "LiIterator"
                lang = "java"
                package = "name/panitz/data/list">package name.panitz.data.list;

public class LiIterator&lt;a&gt; implements java.util.Iterator&lt;a&gt;{

  public LiIterator(Li&lt;a&gt; xs){this.xs=xs;}

  private Li&lt;a&gt; xs;

  public boolean hasNext() {return !xs.isEmpty();}

  public a next(){
    a result = xs.head();
    xs = xs.tail();
    return result;
  }

  public void remove(){
   throw new UnsupportedOperationException ();
  }
}</code>

Der Klasse <tt>Li</tt> können wir eine Methode hinzufügen, die den entsprechenden Iterator für die Liste zurückgibt:<code>  public java.util.Iterator&lt;a&gt; iterator(){
    return new LiIterator&lt;a&gt;(this);
  }</code></subsubsection><subsubsection titel = "Benutzung von Iteratoren">
Iteratoren sind dafür gedacht, über die Elemente von Sammlungsklassen
zu iterieren. Hierzu bedient man sich normaler Weise  der <tt>for</tt>-Schleife. Sie wird hierzu mit einem Iterator initialisiert und hat als Bedingung, daß der Iterator noch ein
weiteres Element liefert. Die Weiterschaltung wird in der Regel leer
gelassen, weil Iteratoren mit dem Aufruf der 
Methode <tt>next</tt> beides machen: das nächste Element ausgeben und
den Iterator weiterschalten.

Wir können als kleines Beispiel eine kleine Methode schreiben, die die
Elemente einer Sammlung als <tt>String</tt> aneinanderhängt:<code class = "Iterate"
                lang = "java">import java.util.Collection;
import java.util.ArrayList;
import java.util.Iterator;

class Iterate {
  static public String unwords(Collection&lt;String&gt; cs){
    String result = &quot;&quot;;

    for (String n:cs){
      result = result+&quot; &quot;+cs;
    }
    return result;
  }

  static public void main(String [] _){
    Collection&lt;String&gt; cs = new ArrayList&lt;String&gt;();
    cs.add(&quot;lebt&quot;);
    cs.add(&quot;wohl&quot;);
    cs.add(&quot;gott&quot;);
    cs.add(&quot;weiß&quot;);
    cs.add(&quot;wann&quot;);
    cs.add(&quot;wir&quot;);
    cs.add(&quot;uns&quot;);
    cs.add(&quot;wiedersehen&quot;);

    System.out.println(unwords(cs));
  }
}</code></subsubsection></subsection><subsection titel = "Abbildungen">
Abbildungen assoziieren Elemente einer Art mit Elementen einer anderen
Art. Sie sind vergleichbar mit Wörterbüchern. In einem
deutsch/englischen Wörterbuch werden die deutschen Wörter auf die
englischen Wörter mit der entsprechenden Bedeutung abgebildet.

Wir benutzen eine Abbildung, indem wir für einen Schlüssel (dem
deutschen Wort) den entsprechenden Werteeintrag suchen (das englische
Wort). <subsubsection titel = "Abbildungen als Liste von Paaren"> Da eine Abbildung jeweils ein Element mit einem anderem assoziiert, ist
eine Umsetzung als Liste von Paaren naheliegend.<footnote>Das 
Programm <ttt>Eliza</ttt> aus einer der vorangegangenen Aufgaben hat
genau so Abbildungen umgesetzt.</footnote> Ein Paar besteht dabei aus einem Schlüssel und dem assoziierten Wert.<code class = "Paar"
                lang = "java"
                package = "name/panitz/data/list">
package name.panitz.data.list;
public class Paar&lt;a,b&gt;{
  public a fst;
  public b snd;
  public Paar(a f,b s){fst=f;snd=s;}
}</code>

So ist eine einfache
Umsetzung von Abbildungen durch Erweitern unserer Listenklassen zu
bekommen: <code class = "Abbildung"
                lang = "java"
                package = "name/panitz/data/list">package name.panitz.data.list;
class Abbildung&lt;a,b&gt; extends Li&lt;Paar&lt;a,b&gt;&gt;{
  public Abbildung(a schlüssel,b wert,Abbildung&lt;a,b&gt; xs){
    super(new Paar&lt;a,b&gt;(schlüssel,wert),xs);
  }

  public Abbildung(){}

  b lookup(a schluessel){
    b result = null;
    
    for (Paar&lt;a,b&gt; p:this) {
      if (p.fst.equals(schluessel)){
        return p.snd;
      }
    }
    return result;
  }
}</code> Die Methode <tt>lookup</tt> iteriert über die Liste, bis sie ein
Listenelement gefunden hat, dessen Schlüssel dem gesuchten Schlüssel
gleich kommt.<code class = "Dictionary"
                lang = "java"
                package = "name/panitz/data/list">package name.panitz.data.list;
class Dictionary {
  static final Abbildung&lt;String,String&gt; dic = 
     new Abbildung&lt;String,String&gt;(&quot;Menge&quot;,&quot;set&quot;
    ,new Abbildung&lt;String,String&gt;(&quot;Abbildung&quot;,&quot;map&quot;
    ,new Abbildung&lt;String,String&gt;(&quot;Liste&quot;,&quot;list&quot;
    ,new Abbildung&lt;String,String&gt;(&quot;Iterator&quot;,&quot;iterator&quot;
    ,new Abbildung&lt;String,String&gt;(&quot;Schnittstelle&quot;,&quot;interface&quot;
    ,new Abbildung&lt;String,String&gt;(&quot;Klasse&quot;,&quot;class&quot;
    ,new Abbildung&lt;String,String&gt;()))))));

  static String english(String deutsch){
    return dic.lookup(deutsch);
  }

  public static void main(String [] _){
    System.out.println(english(&quot;Schnittstelle&quot;));    
    System.out.println(english(&quot;Abbildung&quot;));    
  }
}</code></subsubsection><subsubsection titel = "Standardklasse für Abbildungen">
Java stellt eine Schnittstelle zur Verwirklichung von Abbildungen zur
Verfügung, die Schnittstelle <tt>java.util.Map</tt>.

Die wichtigsten zwei Methoden dieser Schnittstelle sind:<itemize>
            <item><tt>void put(a key, b value)</tt>: ein neues Schlüssel-/Wertpaar
wird der Abbildung hinzugefügt. </item>
            <item><tt> Object get(a key)</tt>: für einen bestimmten Schlüssel
wird ein bestimmter Wert nachgeschlagen. Gibt es für diesen Schlüssel
keinen Eintrag in der Abbildung, so ist das Ergebnis dieser 
Methode <tt>null</tt>.</item>
          </itemize>

Eine Schnittstelle, die  Abbildungen implementiert, ist die 
Klasse  <tt>HashMap</tt>. Ihre Benutzung funktioniert ähnlich wie die
unserer Klasse <tt>Abbildung</tt>, mit dem bereits bekannten
Unterschied, daß unsere Abbildungen unveränderbare Objekte sind,
während die Objekte der entsprechenden Javaklasse durch 
die <tt>put</tt>-Methode modifiziert werden:<code class = "Dic"
                lang = "java">import java.util.*;

class Dic{
  static Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();

  static {
    map.put(&quot;Menge&quot;,&quot;set&quot;);
    map.put(&quot;Abbildung&quot;,&quot;map&quot;);
    map.put(&quot;Liste&quot;,&quot;list&quot;);
    map.put(&quot;Iterator&quot;,&quot;iterator&quot;);
    map.put(&quot;Schnittstelle&quot;,&quot;interface&quot;);
    map.put(&quot;Klasse&quot;,&quot;class&quot;);
  }

  static String english(String deutsch){
   return map.get(deutsch);
  }

  public static void main(String [] _){
    System.out.println(english(&quot;Schnittstelle&quot;));    
    System.out.println(english(&quot;Abbildung&quot;));    
  }

}</code></subsubsection></subsection><subsection titel = "Weitere Sammlungsmethoden">
In der Klasse <tt>java.util.Collections</tt> befinden sich statische Methoden zur Manipulation von Listen, wie z.B.~zum Rotieren,
Rückwärtsdrehen oder Sortieren.</subsection><subsection titel = "Vergleiche"> Ähnlich, wie wir für unsere Sortiermethode <tt>sortBy</tt> eine 
Klasse <tt>Relation</tt> als Parameter übergeben haben, in der es eine Methode gab, die prüfte, ob zwei Elemente in der kleiner-Relation stehen,   gibt es in Java die Schnittstelle <tt>java.util.Comparator</tt>. In
dieser Klasse gibt es die 
Methode <tt>int compare(Object o1, Object o2)</tt>, deren Ergebnis eine negative Zahl, 0 oder eine positive Zahl ist, je nachdem, ob das
erste Argument kleiner, gleich oder größer als das zweite Argument
ist.<p/>
Wir können einen Comparator für Stringobjekte schreiben, der zwei
Strings vergleicht, indem er sie erst umdreht und erst dann die Standardvergleiche für Strings anwendet:<code class = "ReverseComparator"
              lang = "java">import java.util.Comparator;
class ReverseComparator implements Comparator&lt;String&gt; {

  public int compare(String o1, String o2) {
    return reverse((String) o1).compareTo(reverse((String) o2));
  }

  static private String reverse(String str){
    StringBuffer result = new StringBuffer();
    for (int i=str.length()-1;i&gt;=0;i=i-1){
      result.append(str.charAt(i));
    }
    return result.toString();
  }

}</code>
Mit diesem Comparator läßt sich jetzt eine Liste von Strings sortieren. Das Ergebnis ist dann eine Liste, in der sich sich reimende
Wörter hintereinander befinden:<code class = "Rhyme"
              lang = "java">import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

class Rhyme {
  public static List&lt;String&gt; rhyme(List&lt;String&gt; xs){
    Collections.sort(xs,new ReverseComparator());
    return xs;
  }

  public static void main(String [] args){
    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add(&quot;maus&quot;);
    xs.add(&quot;rasieren&quot;);
    xs.add(&quot;bauhaus&quot;);
    xs.add(&quot;verlieren&quot;);
    xs.add(&quot;regen&quot;);
    xs.add(&quot;laus&quot;);
    xs.add(&quot;segen&quot;);
    xs.add(&quot;kapitulieren&quot;);
    xs.add(&quot;monieren&quot;);
    xs.add(&quot;existieren&quot;);
    xs.add(&quot;kraus&quot;);
    rhyme(xs);
    System.out.println(xs);
  }
}</code><p/>
Als eine zweite Schnittstelle stellt Java die 
Standardklasse <tt>java.lang.Comparable</tt> zur Verfügung. In dieser
Schnittstelle gibt es eine Methode <tt>int compareTo(Object o)</tt>.
Die Sortiermethoden auf Sammlungsklassen erwarten, daß die Elemente
der Sammlung die 
Schnittstelle <tt>Comparable</tt> implementieren. Ansonsten kommt es 
in der Sammlungsklasse beim Sortieren zu 
einer <tt>ClassCastException</tt>.</subsection></section><section titel = "Ein- und Ausgabe">
Im Paket <tt>java.io</tt> befinden sich eine Reihe von Klassen, die Ein- und Ausgabe von Daten auf externen Datenquellen erlauben. In den
häufigsten Fällen handelt es sich hierbei um Dateien. <p/>
Ein-/Ausgabeoperationen werden in Java auf sogenannten Datenströmen
ausgeführt. Datenströme verbinden das Programm mit einer externen
Datenquelle bzw.<white/>Senke. Auf diesen Strömen stehen
Methoden zum Senden (Schreiben) von Daten an die Senke 
bzw.<white/>Empfangen (Lesen) von Daten aus der
Quelle. Typischer Weise wird ein Datenstrom angelegt, geöffnet, dann werden darauf Daten gelesen und geschrieben und schließlich der Strom wieder
geschlossen. <p/>
Ein Datenstrom charakterisiert sich dadurch, daß er streng sequentiell
arbeitet. Daten werden also auf Strömen immer von vorne nach hinten gelesen und
geschrieben. <p/>
Java unterscheidet zwei fundamentale unterschiedliche Arten von
Datenströmen:<itemize>
        <item><b>Zeichenenströme</b>: Die Grundeinheit der Datenkommunikation
sind Buchstaben und andere Schriftzeichen. Hierbei kann es sich um 
beliebige Zeichen aus dem
Unicode handeln, also Buchstaben so gut wie jeder bekannten Schrift, von lateinischer  über kyrillische, griechische, arabische, chinesische bis hin zu exotischen Schriften wie der keltischen Keilschrift. Dabei ist entscheidend, in welcher Codierurung die
Buchstaben in der Datenquelle vorliegen. Die Codierung wird in der
Regel beim Konstruieren eines Datenstroms festgelegt. Geschieht dieses
nicht, so wird die Standardcodierung des Systems, auf dem das Programm läuft, benutzt.</item>
        <item><b>Byteströme (Oktettströme)</b>: Hierbei ist die Grundeinheit immer ein Byte, das als Zahl verstanden wird. </item>
      </itemize><subsection titel = "Zeichenströme">
Zwei Hauptoberklassen für Zeichenenströme stehen zur Verfügung:<itemize>
          <item><tt>Reader</tt>: für Ströme, aus denen gelesen werden soll.</item>
          <item><tt>Writer</tt>: für Ströme, in die geschrieben werden soll.</item>
        </itemize> Entsprechende Unterklassen stehen zur Verfügung für die verschiedenen
Arten von Datenquellen, 
so z.B.<white/><tt>FileInputStream</tt> und <tt>FileOutputStream</tt>.</subsection><subsection titel = "Byteströme">
Entsprechend gibt es auch zwei Hauptklassen zum Lesen
bzw.<white/>Schreiben von Byteströmen:<itemize>
          <item>
            <tt>InputStream</tt>
          </item>
          <item>
            <tt>OutputStream</tt>
          </item>
        </itemize>

Byteströme sind dafür gedacht, binäre Dateien zu 
lesen und zu schreiben, wie z.B.<w/>Bilddateien. <p/>

Auch hier stehen verschiedene Unterklassen für verschiedene Arten von
Datenquellen zur Verfügung. Für Dateien sind dieses entsprechend die
Klassen <tt>FileInputStream</tt> und <tt>FileOutputStream</tt>.</subsection><subsection titel = "Ausnahmen">
Ein-/Ausgabeoperationen sind fehleranfällig. Externe Datenquellen
können fehlerhaft sein, nicht existieren oder sich unerwartet
verhalten. Daher kann es bei fast allen Methoden auf Datenströmen zu
Ausnahmen kommen, die alle von der 
Oberklasse <tt>IOException</tt> ableiten.</subsection><subsection titel = "Schreiben und Lesen">
Sowohl für Zeichenströme als auch für Byteströme stehen 
Methoden <tt>int read()</tt> bzw.<white/><tt>int write(int c)</tt> zur Verfügung. Die  Methode <tt>read</tt> liefert entweder einen positiven Wert oder den
Wert <tt>-1</tt>, der anzeigt, daß keine weitere Daten im Datenstrom
vorhanden sind.</subsection> <subsection titel = "Datenströme">
Zum Schreiben und Lesen in Dateien haben die entsprechenden Stromklassen Konstruktoren, die einen Datenstrom für einen Dateinamen
erzeugen. Mit der Konstruktion wird der Strom geöffnet. Java schließt
den Strom automatisch wieder, wenn das Objekt nicht mehr benutzt
wird; da dieser Zeitpunkt abhängig davon ist, wann zufällig die 
Speicherverwaltung ein Objekt aus dem Speicher löscht, ist es zu empfehlen, immer explizit die Methode <tt>close</tt> für solche Datenströme
aufzurufen, die nicht mehr benutzt werden.  <subsubsection titel = "Textdateien lesen">
Zum Lesen einer Textdatei läßt sich bequem die 
Klasse <tt>FileReader</tt> benutzen. Im folgenden Programm wird eine über die
Kommandozeile spezifizierte Datei gelesen und jedes darin enthaltene Zeichen zusammen mit seiner Unicodenummer auf dem Bildschirm ausgegeben:<code class = "ShowFile"
                lang = "java">import java.io.*;
class ShowFile{
  public static void main(String [] args) throws Exception{
    Reader reader = new FileReader(args[0]);
    while (true){
      final int next = reader.read();
      if (next==-1) break;
      System.out.print((char)next);
      System.out.print(next);
    }
  }
}</code></subsubsection> <subsubsection titel = "Textdateien schreiben">
Entsprechend gibt es auch eine Klasse, die zum Schreiben einer Textdatei
bequem benutzt  werden kann: <tt>FileWriter</tt>. So läßt sich ein Programm zum Kopieren einer Datei wie folgt schreiben: 
 <code class = "Copy"
                lang = "java">import java.io.*;

public class Copy {
  public static void main(String[] args) throws IOException {
    FileReader in = new <redv>FileReader(args[0])</redv>;
    FileWriter out = new <redv>FileWriter(args[1])</redv>;
    int c;

    while ((c = in.read()) != -1){
      out.write(c);
    }
  }
}</code></subsubsection></subsection><subsection titel = "Vom InputStream zum Reader, vom OutputStream zum Writer"><tt>Reader</tt> und <tt>Writer</tt> sind praktische Klassen zur Verarbeitung
von Zeichenströmen. Primär sind aber auch Textdateien lediglich eine Folge von
Bytes. <subsubsection titel = "InputStreamReader und OutputStreamWriter"> Mit den Klassen <tt>InputStreamReader</tt> und <tt>OutputStreamWriter</tt> lassen
sich Objekte vom Typ <tt>IntputStream</tt> bzw.<white/> <tt>OutputStream</tt> zu <tt>Reader</tt>- bzw.<white/><tt>Writer</tt>-Objekten machen.  <example>
Statt die vorgefertigte Klasse <tt>FileWriter</tt> zum Schreiben einer
Textdatei zu benutzen, erzeugt die folgende Version zum Kopieren von Dateien
einen über einen <tt>FileOutputStream</tt> erzeugten <tt>Writer</tt> bzw.<white/> einen über einen <tt>FileInputStream</tt> erzeugten <tt>Reader</tt>:  <code class = "Copy2"
                  lang = "java">import java.io.*;

class Copy2 {
  static public void main(String [] args)
     throws Exception {
    Reader reader = new FileReader(args[0]);
    Writer writer 
     = <redv>new OutputStreamWriter(new FileOutputStream(args[1]))</redv>;

    int c;
    while ((c = reader.read()) != -1){
      writer.write(c);
    }
    writer.close();
  }
}</code></example></subsubsection><subsubsection titel = "Zeichenkodierungen"> Java-Strings sind Zeichenketten, die nicht auf eine Kultur mit einer bestimmten Schrift beschränkt , sondern in der Lage sind, alle im
Unicode erfassten Zeichen darzustellen; seien es Zeichen der 
lateinischen, kyrillischen,
arabischen, chinesischen oder sonst einer Schrift bis hin zur
keltischen Keilschrift. Jedes Zeichen eines Strings kann
potentiell eines dieser mehreren zigtausend Zeichen einer der vielen
Schriften sein. In der Regel benutzt ein Dokument insbesondere im amerikanischen und europäischen Bereich nur wenige, kaum 100
unterschiedliche Zeichen. Auch ein arabisches Dokument wird mit
weniger als 100 verschiedenen Zeichen auskommen.<p/>
Wenn ein Dokument im Computer auf der Festplatte gespeichert wird, so
werden auf der Festplatte keine Zeichen einer Schrift, sondern Zahlen abgespeichert. Diese Zahlen sind traditionell Zahlen, die acht Bit im Speicher belegen, ein sogenanntes Byte. Ein Byte ist in der Lage, 256 unterschiedliche Zahlen darzustellen. Damit würde ein
Byte ausreichen, alle Buchstaben eines normalen westlichen Dokuments in lateinischer Schrift (oder eines arabischen Dokuments) darzustellen. Für ein chinesisches Dokument reicht es nicht aus, die
Zeichen durch ein Byte allein auszudrücken, denn es gibt mehr als
10000 verschiedene chinesische Zeichen. Es ist notwendig, zwei Byte im
Speicher zu benutzen, um die vielen chinesischen Zeichen als Zahlen
darzustellen. <p/>
Die <em>Codierung</em> eines Dokuments gibt nun an, wie die Zahlen, die
der Computer auf der Festplatte gespeichert hat, als Zeichen
interpretiert werden sollen. Eine Codierung für arabische Texte wird den
Zahlen von 0 bis 255 bestimmte arabische Buchstaben zuordnen, eine
Codierung für deutsche Dokumente wird den Zahlen 0 bis 255 lateinische
Buchstaben inklusive deutscher Umlaute und dem <tt>ß</tt> zuordnen.
Für ein chinesisches Dokument wird eine <em>Codierung</em> benötigt, die den 65536 mit zwei Byte darstellbaren Zahlen jeweils chinesische Zeichen
zuordnet. <p/>
Man sieht, daß es <en>Codierungen</en> geben muß, die für ein Zeichen ein
Byte im Speicher belegen, und solche, die zwei Byte im Speicher
belegen. Es gibt darüberhinaus auch eine Reihe Mischformen; manche Zeichen werden durch ein Byte, andere durch zwei oder sogar durch zwei Byte
dargestellt. <p/>

Die Klasse <tt>OutputStreamWriter</tt> sieht einen Konstruktor vor, dem man
zusätzlich zum <tt>OutputStream</tt>, in den geschrieben werden soll, als zweites Element auch die Codierung angeben kann, in der die
Buchstaben abgespeichert werden sollen. Wenn diese Codierung nicht explizit
angegeben wird, so benutzt Java die standardmäßig auf dem Betriebssystem
benutzte Codierung.<example> In dieser Version der Kopierung einer Textdatei wird für 
den <tt>Writer</tt> ein Objekt der 
Klasse <tt>OutputStreamWriter</tt> benutzt, in der als Zeichenkodierung utf-16
benutzt wird.<code class = "EncodedCopy"
                  lang = "java">import java.nio.charset.Charset;
import java.io.*;

class EncodedCopy {
  static public void main(String [] args)
     throws Exception {
    Reader reader = new FileReader(args[0]);
    Writer writer = new OutputStreamWriter
                         (new FileOutputStream(args[1])
                         ,<redv>Charset.forName(&quot;UTF-16&quot;)</redv>);

    int c;
    while ((c = reader.read()) != -1){
      writer.write(c);
    }
    writer.close();
  }
}</code> Betrachtet man die Größe der geschriebenen Datei, so wird man feststellen, daß sie mehr als doppelt so groß ist wie die Ursprungsdatei.<scode>sep@linux:~/fh/prog1/&gt; java EncodedCopy EncodedCopy.java EncodedCopyUTF16.java
sep@linux:~/fh/prog1/&gt; ls -l EncodedCopy.java
-rw-r--r--    1 sep      users         443 2004-01-07 19:12 EncodedCopy.java
sep@linux:~/fh/prog1/&gt; ls -l EncodedCopyUTF16.java
-rw-r--r--    1 sep      users         888 2004-01-07 19:13 EncodedCopyUTF16.java
sep@linux:~/fh/prog1/&gt;</scode></example><aufgabe>
Schreiben Sie ein Programm <tt>FileConvert</tt> zum  Konvertieren von Textdateien in eine andere Kodierung. Dem Programm sollen über die Kommandozeilenparameter der Name der Eingabedatei, der Name der Ausgabedatei und der Name der benutzten Codierung übergeben werden. Ein möglicher Aufruf wäre also:<scode>linux:~/&gt;java FileConvert test.txt konvertiertTest.txt utf-8</scode>

Lassen Sie eine deutsche Textdatei mit Umlauten in eine Datei mit der Codierung utf-8 konvertieren. Betrachten Sie die Ergebnisdatei. Was stellen
Sie fest?</aufgabe></subsubsection><subsubsection titel = "Gepufferte Ströme"> Die bisher betrachteten Ströme arbeiten immer exakt zeichenweise, bzw.<white/>byteweise. Damit wird bei 
jedem <tt>read</tt> und bei jedem <tt>write</tt> direkt von der
Quelle bzw.<white/>an die Senke ein Zeichen übertragen. Für
Dateien heißt das, es wird über das Betriebssystem auf die Datei auf
der Festplatte zugegriffen. Handelt es sich bei Quelle/Senke um eine
teure und aufwändige Netzwerkverbindung, so ist für jedes einzelne
Zeichen über diese Netzwerkverbindung zu kommunizieren. Da in der
Regel nicht nur einzelne Zeichen über einen Strom übertragen werden sollen, ist es effizienter, wenn technisch gleich eine Menge von Zeichen übertragen wird. Um dieses zu bewerkstelligen, bietet java an, Ströme
in gepufferte Ströme umzuwandeln. <p/> Ein gepufferter Strom hat einen internen Speicher. Bei einer Datenübertragung wird für schreibende Ströme erst eine Anzahl von
Zeichen in diesem Zwischenspeicher abgelegt, bis dieser seine
Kapazität erreicht hat, um dann alle Zeichen aus dem  Zwischenspeicher <em>en bloc</em> zu übertragen. Für lesende Ströme wird entsprechend für ein <tt>read</tt> gleich eine ganze Anzahl von
Zeichen von der Datenquelle geholt und im Zwischenspeicher
abgelegt. Weitere <tt>read</tt>-Operationen holen dann die Zeichen nicht mehr direkt aus der Datenquelle, sondern aus dem
Zwischenspeicher, bis dieser komplett ausgelesen wurde und von der
Datenquelle wieder zu füllen ist.<p/> Die entsprechenden Klassen, die Ströme in gepufferte Ströme verpacken,
heißen:<br/><tt>BufferedInputStream, BufferedOutputStream</tt> und<br/>
entsprechend <tt>BufferedReader, BufferedWriter</tt>.<example>
Jetzt ergänzen wir zur Effizienzsteigerung noch das Kopierprogramm, so daß  der benutzte <tt>Writer</tt> gepuffert ist:<code class = "BufferedCopy"
                  lang = "java">import java.io.*;
import java.nio.charset.Charset;

class BufferedCopy{
  static public void main(String [] args)
     throws Exception {

    Reader reader = new FileReader(args[0]);
    Writer writer = new <redv>BufferedWriter</redv>
                      (new OutputStreamWriter
                          (new FileOutputStream(args[1])
                          ,Charset.forName(&quot;UTF-16&quot;)));

    int c;
    while ((c = reader.read()) != -1){
      writer.write(c);
    }
    writer.close();
  }
}</code></example></subsubsection></subsection><subsection titel = "Ströme für Objekte"> Bisher haben wir uns darauf beschränkt, Zeichenketten über Ströme zu lesen und
zu schreiben. Java bietet darüberhinaus die Möglichkeit an, beliebige Objekte
über Ströme zu schreiben und zu lesen. Hierzu können mit den 
Klassen  <tt>ObjectOutputStream</tt> und <tt>ObjectInputStream</tt> beliebige <tt>OutputStream</tt>- bzw.<white/><tt>InputStream</tt>-Objekte zu Strömen für Objekte gemacht werden.<p/>
In diesen Klassen stehen Methoden zum Lesen und Schreiben von Objekten zur
Verfügung. Allerdings können über diese Ströme nur Objekte von Klassen
geschickt werden, die die Schnittstelle <tt>java.io.Serializable</tt> implementieren. Die meisten Standardklassen
implementieren diese Schnittstelle. <tt>Serializable</tt> enthält keine Methoden, es reicht also zum Implementieren aus, die Klausel <tt>implements Serializable</tt> für eine Klasse zu benutzen, damit Objekte der
Klasse über Objektströme geschickt werden können.<p/> Objektströme haben zusätzlich Methoden zum Lesen und Schreiben von primitiven
Typen. <example>
Folgendes Testprogramm schreibt eine Zahl und ein Listenobjekt in eine Datei,
um diese anschließend wieder aus der Datei auszulesen.<code class = "WriteReadObject"
                lang = "java">import java.io.*;
import java.util.List;
import java.util.ArrayList;

public class WriteReadObject {
  public static void main(String [] args) throws Exception{
    FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;);
    ObjectOutputStream oos = new <redv>ObjectOutputStream</redv>(fos);

    List&lt;String&gt; xs = new ArrayList&lt;String&gt;();
    xs.add(&quot;the&quot;);
    xs.add(&quot;world&quot;);
    xs.add(&quot;is&quot;);
    xs.add(&quot;my&quot;);
    xs.add(&quot;oyster&quot;);

    oos.<redv>writeInt</redv>(12345);
    oos.<redv>writeObject</redv>(xs);
    oos.close();
	
    FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);
    ObjectInputStream ois = new <redv>ObjectInputStream</redv>(fis);

    int i = ois.<redv>readInt</redv>();
    List ys = (List) ois.<redv>readObject</redv>();

    ois.close();
 
    System.out.println(i);
    System.out.println(ys);
  }
}</code><aufgabe>Erweitern Sie die Klasse <tt>Li</tt>, so daß Sie Ihre Listenobjekte
in Dateien schreiben und wieder aus Dateien lesen können. Testen Sie ihre
Implementierung. </aufgabe></example></subsection><subsection titel = "Stromloses IO">
Die Ein- und Ausgabe mit Stromklasse zwingt immer, eine Datenquelle
vom Anfang an durchzulesen, bis man zu den Daten der Quelle kommt, die
einen interessieren. Oft interessiert man sich aber nur für bestimmte
Daten irgendwo in der Mitte einer Datei. Ein typisches Beispiel wäre ein Dateiformat eines Textdokumentes. Am Anfang der Datei ist eine Tabelle, die angibt, auf welcher Position in der Datei sich die einzelnen
Seiten befinden. Ist man nur an einer bestimmten Seite des Dokuments 
interessiert, so kann man ihren Index in der Datei  der Tabelle am
Anfang entnehmen und dann direkt diese Seite lesen, ohne alle
vorherigen Seiten betrachten zu müssen.  
Für eine solche Arbeitsweise stellt Java die 
Klasse <tt>java.io.RandomAccessFile</tt> zur Verfügung.<aufgabe>
Studieren Sie die Dokumentation von <tt>java.io.RandomAccessFile</tt> und
schreiben Sie einige Testbeispiele zur Benutzung dieser Klasse.</aufgabe></subsection></section></kapitel>
  <kapitel titel = "Qualitätssicherung">
    <section titel = "Verträge">
      <code class = "AssertFac"
            lang = "java">public class AssertFac{
  static public int fac(int x){
    assert x&gt;=0;
    if (x==0) return 1;
    return x*fac(x-1);
  }

  static public void main(String [] args){
    for (String arg:args)
      System.out.println(fac(new Integer(arg)));
  }
}</code>
      <scode>sep@pc305-3:~/fh/java&gt; java -cp student/classes/ -ea AssertFac 1 2 3 4 5 -1 17
1
2
6
24
120
Exception in thread &quot;main&quot; java.lang.AssertionError
        at AssertFac.fac(AssertFac.java:4)
        at AssertFac.main(AssertFac.java:11)
sep@pc305-3:~/fh/java&gt;</scode>
      <todo>Seiteneffektfrei, apt für pre und postcondition?</todo>
    </section>
    <section titel = "Unit Tests"/>
    <section titel = "Logging">
      <code class = "JustLogMe"
            lang = "java"
            package = "name/panitz/log/example">package name.panitz.log.example;
import java.util.logging.Logger;
import java.util.logging.Level;
public class JustLogMe{
  private static Logger logger = Logger.getLogger(&quot;name.panitz.log.example&quot;);

  static public void main(String [] args){
    logger.info(&quot;eine log info&quot;);
    logger.log(Level.WARNING, &quot;ein kleines problem&quot; );
    logger.log(Level.SEVERE, &quot;ein großes problem&quot;);
    logger.fine(&quot;eine super feine info&quot;);
  } 
}</code>
    </section>
    <includeLaTeX file = "javadoc"/>
    <section titel = "Qualitätsmaße"/>
  </kapitel>
  <kapitel titel = "Algebraische Datentypen">
Wir haben in diesem Skript bereits Datenstrukturen auf algebraische Weise
spezifiziert und sie dann mit Hilfe von objektorientierter Programmierung
realisiert: Listen und Bäume.

In der Programmierung gibt es oft die Situation, daß die Art der Daten eines
Problemfeldes relativ fest ist und im Laufe des Projektes sich nicht in seiner
Struktur groß ändert. Dann sind die Klassen, die die Datenstruktur realisieren
in ihrer Struktur sehr stabil über den Entwicklungsprozess hinweg. Hingegen
will man mit diesen Daten die unterschiedlichsten Berechnungen anstellen. 

Ein typisches Beispiel für diese Situation findet sich im Compilerbau:
In der Regel schreibt man einen Compiler für eine Programmiersprache, die
fertig definiert ist und sich selten ändert. Der Parser erzeugt für ein
Programm eine strukturierte Darstellung des Programms als Baum. Da die
Sprachdefinition einer Programmiersprache relativ stabil ist, ist der Typ des
Baumes auch sehr stabil und ändert sich selten. Hingegen wird im Laufe der
Entwicklung und Weiterentwicklung eines Compilers auf diesem Baum immer wieder
neue Operationen ausgeführt. Es werden neue Optimierungen eingebaut, für
verschiedene Maschinen Code generiert, neue Checks für Warnungen eingebaut und
und und. Wir haben also die Situation, daß die Datenstruktur sich selten
ändert, aber permanent neue Algorithmen für diese Struktur geschrieben werden.
Nun trägt das objektorientierte Programmiermodell diesem wenig
Rechnung. Algorithmen finden sich hier verteilt auf die unterschiedlichen
Klassen eines Datentyps in den verschieden überschriebenen Versionen der
Methode, die zusammen einen Algorithmus realisieren. Will man einen neuen
Algorithmus schreiben, so muß man in allen Klassen der die die Datenstruktur
realisiert, die Methode überschreiben. Nicht nur der rein praktische Aspekt,
daß man in vielen Dateien programmieren muß, um eine bestimmte Funktionalität
zu programmieren ist lästig, sondern es fehlt auch ein gebündelter Überblick
über den gesamten Algorithmus. Es gibt aber einen Trick, wie man
algorithmuszentriert im Gegensatz zu datenzentriert in einer
objektorientierten Sprache programmieren kann.

   <section titel = "Das Besuchsmuster">
Das Programmiermuster, das einen eine algorithmszentrierte Programmierung
erlaubt, nennt sich da Besuchsmuster.
Es spielt in virtuoser Weise mit den folgenden zwei Konzepten:<itemize>
        <item><b>Überladung:</b> eine Methode existiert mehrfach mit gleichem Namen in
einer Klasse. Die verschiedenen Versionen dieser Methode unterscheiden sich in
ihren Parametern, indem sie unterschiedliche Parametertypen oder eine
unterschiedliche Anzahl von Parametern haben.</item>
        <item><b>Überschreibung:</b> eine Methode ist in verschiedenen Unterklassen
einer Klasse überschrieben worden. Hier hat jede der überschreibenen Methoden
dieselben Parameter. Man spricht im objektorientierten Umfeld auch 
von <em>Polymorphie</em>.</item>
      </itemize> 

So ähnlich die beiden Konzepte von außen auch erscheinen, so haben sie einen
fundamentalen Unterschied in der Art, wie entschieden wird, welche der
unterschiedlichen Versionen einer Methode mit einem bestimmten Namen
ausgeführt wird:<itemize>
        <item><b>Überladung:</b> Der Compiler entscheidet statisch bei der
Codegenerierung. Hierzu schaut er sich bei einem Methodenaufruf an, von welchem
statischen Typ die Parameter des Aufrufs sind und wählt anhand dessen die
Methode aus. Hierbei wird für alle Argumente der deklarierte Typ genommen, es
werden also nicht die Argumentojekte gefragt, ob sie eventuell von einer
Unterklasse ihres deklarierten Typs sind:<example>
Im folgenden kleinen Programm ist eine Funktion <tt>f</tt> überladen.
In der Hauptmethode wird die Version für den 
Parametertyp <tt>Object</tt> ausgeführt, da das lokale 
Feld <tt>s</tt> als von Typ <tt>Object</tt> deklariert wurde. Es ist dabei
unerheblich, daß das Objekt <tt>s</tt> aber eigentlich ein Stringobjekt ist. <code class = "Overloaded"
                  lang = "java">class Overloaded{
  void f(String s){System.out.println(&quot;Stringversion&quot;);}
  void f(Object s){System.out.println(&quot;Objectversion&quot;);}
  public static void main(String [] _){
    Object s = &quot;das ist ein String&quot;;
    new Overloaded().f(s);
  }
}</code></example></item>
        <item><b>Überschreibung</b>: Hier wird erst während der Ausführung des
  Programms entschieden, welche Version der Methode aufgerufen wird. Dieses
  ist das Prinzip dert späten Bindung. Während der Ausführungszeit wird das
  Objekt gebeten seine Version der überschriebenen Methode 
auszuführen.  </item>
        <example>
In diesem Beispiel benutzen wir die Eigenschaft, daß die 
Methode <tt>toString</tt> aus der Klasse <tt>Object</tt> in der 
Klasse <tt>String</tt> überschrieben wurde. Obwohl das lokale 
Feld <tt>s</tt> als von Typ <tt>Object</tt> deklariert ist, wird doch die
  Methode <tt>toString</tt> der Klasse <tt>String</tt> ausgeführt. <code class = "Overridden"
                lang = "java">class Overridden{
  public static void main(String [] _){
    Object s = &quot;das ist ein String&quot;;
    System.out.println(s.toString());
  }
}</code></example>
      </itemize><subsection titel = "Klassen zur Baumdarstellung eines Programms">
Wir werden das Besuchsmuster anhand eines Beispiels aus dem Compilerbau
erklären. Betrachten wir dazu das folgende kleine Programm einer winzigen
kleinen ausgedachten Programmiersprache:<code>result=1;
x=5;
loop (x){
  result=result*x;
  x=x-1
}</code><code class = "Node"
              lang = "java">interface Node{
    void welcome(Visitor x);
}</code><code class = "Num"
              lang = "java">class Num implements Node {
  int value;
  Num(int n){value=n;}
  public void welcome(Visitor x){x.visit(this);}
}</code><code class = "Var"
              lang = "java">class Var implements Node {
  String name;
  Var(String n){name=n;}
  public void welcome(Visitor x){x.visit(this);}
}</code><code class = "Seq"
              lang = "java">class Seq implements Node {
  Node leftChild;
  Node rightChild;
  Seq(Node lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</code><code class = "Assign"
              lang = "java">class Assign implements Node {
  Var leftChild;
  Node rightChild;
  Assign(Var lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</code><code class = "Sub"
              lang = "java">class Sub implements Node {
  Node leftChild;
  Node rightChild;
  Sub(Node lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</code><code class = "Mult"
              lang = "java">class Mult implements Node {
  Node leftChild;
  Node rightChild;
  Mult(Node lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</code><code class = "Loop"
              lang = "java">class Loop implements Node {
  Node leftChild;
  Node rightChild;
  Loop(Node lC,Node rC){leftChild=lC;rightChild=rC;}
  public void welcome(Visitor x){x.visit(this);}
}</code><code class = "GetSimpleProg"
              lang = "java">class GetSimpleProg{
  public static Node getSimpleProg(){
    Var result=new Var(&quot;result&quot;);
    Var x=new Var(&quot;x&quot;);
    Node n1=new Num(1);
    Node n5=new Num(5);
    Node as1 = new Assign(result,n1);
    Node as2 = new Assign(x,n5);
    Node mult = new Mult(result,x);
    Node sub = new Sub(x,n1);
    Node as3 = new Assign(result,mult);
    Node as4 = new Assign(x,sub);
    Node seq3 = new Seq(as3,as4);
    Node loop = new Loop(x,seq3);
    Node seq2 = new Seq(as2,loop);
    Node seq1 = new Seq(as1,seq2);
    return seq1;
  }
}</code><code class = "Visitor"
              lang = "java">interface Visitor {
  void visit(Var x);
  void visit(Num x);
  void visit(Assign x);
  void visit(Loop x);
  void visit(Mult x);
  void visit(Sub x);
  void visit(Seq x);
}</code><subsubsection titel = "Besucher zum Ausgeben">
          <code class = ""
                lang = "java">class PrettyPrinter implements Visitor{
  StringBuffer result= new StringBuffer();
  int indent=0;
  void newline(){
    result.append(&quot;\n&quot;);
    for (int i=indent;i&gt;0;i--)result.append(&#39; &#39;);
  }
  void addIndent(){i=i+2;}
  void removeIndent(){i=i-2;}

  public void visit(Var x){result.append(x.name);}
  public void visit(Num x){result.append(&quot;&quot;+x.value);}
  public void visit(Assign x){
    x.leftChild.welcome(this);
    result.append(&quot; = &quot;);
    x.rightChild.welcome(this);
  }
  public void visit(Loop x){
    result.append(&quot;loop (&quot;);
    x.leftChild.welcome(this);
    resultappend(&quot;){&quot;);
    addIndent();
    newline();
    x.rightChild.welcome(this);
    removeIndent();
    newline();
    result.append(&quot;}&quot;);
  }
  public void visit(Mult x){
    x.leftChild.welcome(this);
    result.append(&quot; * &quot;);
    x.rightChild.welcome(this);
  }
  public void visit(Sub x){
    x.leftChild.welcome(this);
    result.append(&quot; - &quot;);
    x.rightChild.welcome(this);
  }
  public void visit(Seq x){
    x.leftChild.welcome(this);
    result.append(&quot;;&quot;)
    newline();
    x.rightChild.welcome(this);
  }
}</code>
        </subsubsection><subsubsection titel = "Besucher zum Ausführen eines Programms">
          <code class = "Calculate"
                lang = "java">import java.util.*;
class Calculate implements Visitor{
  Map&lt;String,Integer&gt; env=new HashMap&lt;String,Integer&gt;();
  private int result;
  public void visit(Var x){result=env.get(x.name);}
  public void visit(Num x){result=x.value;}
  public void visit(Assign x){
    x.rightChild.welcome(this);
    env.put(x.leftChild.name,result);
  }
  public void visit(Loop x){
    x.leftChild.welcome(this);
    while (result!=0){
      x.rightChild.welcome(this);
      x.leftChild.welcome(this);
    }
  }
  public void visit(Mult x){
    x.leftChild.welcome(this);
    int op1 = result;
    x.rightChild.welcome(this);
    int op2 = result;
    result= op1*op2;
  }
  public void visit(Sub x){
    x.leftChild.welcome(this);
    int op1 = result;
    x.rightChild.welcome(this);
    int op2 = result;
    result= op1-op2;
  }
  public void visit(Seq x){
    x.leftChild.welcome(this);
    x.rightChild.welcome(this);
  }
}</code>
        </subsubsection></subsection></section><section titel = "Putzen der Kochplatte">
Dieses Kapitel ist ein als Papier konzipiert und liegt daher in englischer
Sprache vor. Es geht weiterhin um hierarchische Daten. Es werden weitere
Programmiermuster vorgestellt, die es erlauben noch bequemer durche eine
Datenstruktur durchzulaufen, um mehrere unterschiedliche Aufgaben zu
bewerkstelligen:<itemize>
        <item>Über die komplette Datenstruktur zu gehen um etwas zu berechnen.</item>
        <item>Bestimmte Knoten der Datenstruktur zu verändern.</item>
        <item>Bestimmte Anfrage an die Datenstruktur zu stellen, um Information aus
Ihr zu bekommen.</item>
      </itemize>

Und nun der englischsprachige Teil:<subsection titel = "Itroduction">
Genericity is the key to software reuse. Generic code solves general problems
and can be specialized to specific problems. A general problem is the handling
of hierarchical data.
Almost all interesting data is hierarchical data.  XML<cite label = "xml1.1"/>, 
the universal data 
exchange format  pays tribute to this fact. XML documents represent a
hierarchical structure. In object oriented languages tree nodes are
represented by different classes. Child nodes are represented as fields of
these classes. Number, type and name of fields representing child nodes
are arbitrary.<p/>

Quite often the classes representing tree nodes are generated by some tool, as
e.g. by the parser generator tool javacc or for some XML DTD.<p/>

A common programming task for tree like structures is
to traverse through the tree. Generally  two different task may be archieved
during traversal:  <itemize>
          <item>certain tree nodes may be modified,</item>
          <item>or certain information
may be collected from the tree.</item>
        </itemize>

In object oriented languages there are mainly two ways how tree traversal
may be put into realization:<itemize>
          <item>in a pure object oriented manner: classes representing tree nodes
contain specialized methods for different tasks.</item>
          <item>in a functional way by means of the visitor 
pattern<cite label = "visitorpattern"/>: tree classes
implement an interface <tt>Visitable</tt>. 
Algorithms can be expressed by terms of
visitor classes. A visitor class overloads a function for every kind of tree
node.</item>
        </itemize>


Both ways are not generic.  Both require that the tree traversal code is
implemented for every node type.
Even worse, in both cases the tree traversal code mixes
with the actual application logic. Thus the tree traversal code gets
duplicated for every algorithm working on the tree. 
The methods in the tree node classes or the overloaded 
methods <tt>visits</tt> in the visitor need to code, how to access the child
nodes. <p/>


Furthermore, both techniques are not very flexible as in respect to  
program evolution.
If in the object oriented scenario a new class is
added, then this class needs to implement all methods, which for some reason
traverse over the tree. 
A visitor class, on the other hand is only applicable to a certain
type of tree node. It is specialized for some type. If a new node 
class is added to
the tree  type, then  every visitor needs to implement a new 
overloaded method variant for the new class.<p/>

A generic way for tree manipulation will clearly seperate the tree traversal
code and the actual application logic. Furthermore it will be very flexible in
terms of programm evolution: new classes arriving on the scene will not force
any changes in the existing code.<p/>

A simple pattern for tree traversal has been proposed for the programming
language Haskell<cite label = "revisedHaskellReport"/>.
The <em>scrap your boilerplate 
code</em> pattern<cite label = "LPJ03"/><cite label = "syb2"/> factors out the 
tree 
traversal code and makes it reusable for different algorithms. We will apply
this pattern to the programming language Java.<p/>

 
The paper is structured as follows: in section~<ref name = "problem"/> the
problem to be solved is presented by way of a concrete example taken 
from~<cite label = "LPJ03"/>. Section~<ref name = "naiv"/> gives some
 na\&quot;iv non generic solutions to the problem. 
Section~<ref name = "transform"/> implements a generic tree transformer 
and section~<ref name = "query"/> implements a generic query method for trees.
Both  implementations are refined in section~<ref name = "cut"/>. The Java code
within this paper is complete and can 
be <exlink address = "http://panitz.name/paper/boilerplate/index.html"> downloaded from the
web</exlink>.
     </subsection><subsection titel = "The Problem"><label name = "problem"/>
We use the same example as presented in <cite label = "LPJ03"/>. 
It is a simple company
structure, which can be expressed by the following XML document type
definition. <code class = "company"
              lang = "dtd"
              package = "company"
              commandchars = "_~^"
              size = "footnotesize">&lt;!DOCTYPE Company SYSTEM &quot;company.dtd&quot; [
  &lt;!ELEMENT Company (Dept)*&gt;  
  &lt;!ELEMENT Dept (Name,Employee,(PU|DU)*)&gt;  
  &lt;!ELEMENT PU (Employee)&gt;  
  &lt;!ELEMENT DU (Dept)&gt;  
  &lt;!ELEMENT Employee (Person,Salary)&gt;  
  &lt;!ELEMENT Person (Name,Address)&gt;  
  &lt;!ELEMENT Salary (#PCDATA)&gt;  
  &lt;!ELEMENT Name (#PCDATA)&gt;  
  &lt;!ELEMENT Address (#PCDATA)&gt;
]&gt;</code>

This definition gives directely rise to a Java implementation. For every
element type defined in the DTD we can provide
a Java class. The child elements are represented by way of fields in these
classes. For the alternative operator <tt>|</tt> of several child 
elements as e.g. expressed  in <tt>(PU|DU)</tt> a common superinterface for the
classes <tt>PU</tt> and <tt>DU</tt> can be defined. For the repetitive
occurrence of
child elements as e.g. <tt>(Dept)*</tt> the standard Java 
interface <tt>List</tt> is used.<p/>

Java classes for the DTD above are given in appendix~<ref name = "companyClasses"/>.
Usually some generator tool can be used to generate classes from a DTD or from
a XML schema definition.<p/>

Throughout this paper we will work with an example instance 
of <tt>Company</tt>. It is the same example instance as used 
in <cite label = "LPJ03"/>.<footnote>Not quite it is extended with a
subdepartment, otherwise one of the algorithms in this (as well as in the
original paper) does not have any effect.</footnote><code size = "footnotesize"
              class = "MyComp"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class MyComp{
  static Company getCompany(){
   Company company= new Company();
   Employee blair= new Employee(new Person(&quot;Blair&quot;,&quot;London&quot;),new Salary(100000.0));
   Employee nn=new Employee(new Person(&quot;NN&quot;,&quot;Mars&quot;),new Salary(90000.0));
   Employee marlow=new Employee(new Person(&quot;Marlow&quot;,&quot;Cambridge&quot;),new Salary(2000.0));
   Employee joost = new Employee(new Person(&quot;Joost&quot;,&quot;Amsterdam&quot;),new Salary(1000.0));
   Employee ralf = new Employee(new Person(&quot;Ralf&quot;,&quot;Amsterdam&quot;),new Salary(8000.0));
   List&lt;SubUnit&gt; ralfSu = new ArrayList&lt;SubUnit&gt;();
   ralfSu.add(new PU(joost));ralfSu.add(new PU(marlow));
   company.add(new Dept(&quot;Research&quot;,ralf,ralfSu));
   company.add(new Dept(&quot;Strategy&quot;,blair,new ArrayList&lt;SubUnit&gt;()));
   ralfSu.add(new DU(new Dept(&quot;Research2&quot;,nn,new ArrayList&lt;SubUnit&gt;())));
   return company;
  }
}</code>

Tasks to be solved for a structure like the company above are:<itemize>
          <item>increase the salary of each employee.</item>
          <item>liquidate a certain sub department.</item>
          <item>sum up all salary numbers for an overall salary bill of the company.</item>
          <item>represent the company by a <tt>String</tt>.</item>
          <item>compare two companies for equality.</item>
          <item>represent the company in an XML document.</item>
        </itemize>

All these task need to travers the company. This will make it necessary to
rewrite the traversal code for each of these tasks.
We want traverse tree structures in a generic way, i.e. write the traversal
code once for all. <p/>

The domain specific language XSLT<cite label = "xslt"/>, the for transforming
XML 
documents gives us some
hints on how this can be achieved in Java.
In XSLT rules for nodes with a certain condition can be expressed. Elements
nodes, which do not match any of these conditions simply traverse to the child
nodes. 
XSLT allows to express default templates of how to traverse for elements,
which do not match any specific rule. The first of the above tasks can 
easily be expressed in XSLT by:<p/><code class = "IncreaseSalary"
              lang = "xsl"
              package = "company"
              size = "footnotesize"
              commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;
&lt;xsl:template match=&quot;Salary&quot;&gt;
  &lt;xsl:variable name=&quot;arg1&quot;&gt;&lt;xsl:apply-templates select=&quot;text()&quot;/&gt;&lt;/xsl:variable&gt;
  &lt;Salary&gt;&lt;xsl:value-of select=&quot;$arg1 * 1.17&quot; /&gt;&lt;/Salary&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match=&quot;*&quot;&gt;
  &lt;xsl:copy select=&quot;*&quot; &gt;&lt;xsl:apply-templates/&gt;&lt;/xsl:copy &gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code><p/>

Note that this XSLT program will work on any XML document. It is not necessary
that the document is structured according to some schema or DTD. It will
automatically traverse the complete document and increase the numbers found
within 
every <tt>Salary</tt> node.
XSLT relies on the fact that XML documents are trees. 
The <tt>&lt;xsl:apply-templates/&gt;</tt> apllies to the direct children of
the current node.
We would like to get an comparatively simple solution for this task in Java.</subsection><subsection titel = "Na\&quot;ive hand coded instances"><label name = "naiv"/>
In the previous section it turned out that the notion of child nodes is
crucial for any tree traversal. In order to result in some generic tree
traversal code, we will need some uniform method of how to retrieve the direct
child nodes of some node. For this we can instrumentalize  
Java&#39;s standard interface <tt>Iterable</tt>. We will 
use <tt>Iterable</tt> such that it will not iterate over all  descendents of a
tree node, but only its direct children. In fact this is what we did for the
classes representing the <tt>Company</tt> DTD as can be found 
in appendix~<ref name = "companyClasses"/>. Since the type of the child nodes is
arbitrary we implemented the most general instantiation of the
interface: <tt>Iterable&lt;Object&gt;</tt>.<subsubsection titel = "Show">
With iterator over the direct child nodes, the boilerplate code allready
implodes to a minimal amount. As an example we give an implementation of a
generic <tt>show</tt> method. Thanks to Java&#39;s new <em>for-each</em> loop 
the tree traversal boilerplate code is just one line.<code size = "footnotesize"
                class = "Show"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
class Show{
  static String show(Object o){
    StringBuffer result = new StringBuffer(); 
    if (o instanceof Iterable) {
      result.append(&quot;new &quot;+o.getClass().getSimpleName()+&quot;(&quot;);
      boolean first = true;
      <redv>for (Object x:((Iterable)o)){</redv><bluev>//the tree traversal code</bluev>
        if (first) first=false;else result.append(&quot;,&quot;);
        result.append(show(x));
      }
      result.append(&quot;)&quot;);
    }else result.append(o);
    return result.toString();
  }
}</code>
This method calculates a <tt>String</tt> representation for any object. If the
object is iterable, we will traverse its child nodes.<code size = "footnotesize"
                class = "TestShow"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
class TestShow{
  public static void main(String [] args){
    System.out.println(Show.show(MyComp.getCompany()));}}</code></subsubsection><subsubsection titel = "Eq">
          <code size = "footnotesize"
                class = "Eq"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.Iterator;
class Eq{
  static boolean eq(Object x,Object y){
    if (x instanceof Iterable &amp;&amp; y instanceof Iterable){
      Iterator ity = ((Iterable)y).iterator();
      for (Object z:(Iterable)x){if (!ity.hasNext())    return false;
                                 if (!eq(z,ity.next())) return false;}
    }else return x.equals(y);
    return true;
  }
}</code>
          <code size = "footnotesize"
                class = "TestEq"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
class TestEq{
  public static void main(String [] args){
    System.out.println(Eq.eq(MyComp.getCompany(),MyComp.getCompany()));}}</code>
        </subsubsection></subsection><subsection titel = "Generic Transformers"><label name = "transform"/>
In this section, we will generalize the traversal code. The actual application
logic will be encapsulated in a method <tt>transform</tt>. We can define an
interface for this method:<code size = "footnotesize"
              class = "Transformer"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
interface Transformer{void transform(Object o);}</code>

The generic tree traversal code is divided onto two methods. The first method
is a generic <tt>map</tt> function.
It iterates  over the direct child nodes of the argument
node and applies the transform method to these: <code size = "footnotesize"
              class = "Transform"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
public abstract class Transform  implements Transformer{
  public  void gmap(Object x){
    if (x instanceof Iterable) for (Object a:((Iterable)x)) transform(a);
  }</code>

For the complete traversal of the tree, the method <tt>everywhere</tt> is
provided. it needs an inner <tt>Transform</tt> object, which will be cached:<code size = "footnotesize"
              sequel = "true"
              class = "Transform"
              lang = "java"
              package = "name/panitz/boilerplate">  Transform everywhereT = null;
  public void everywhere(Object x){</code>
The inner <tt>everywhere</tt> transformer will recursively call the 
method <tt>everywhere</tt> of this transformer:<code size = "footnotesize"
              sequel = "true"
              class = "Transform"
              lang = "java"
              package = "name/panitz/boilerplate">    final Transform dies = this;
    if (everywhereT==null)
      everywhereT
       = new Transform(){public void transform(Object o){dies.everywhere(o);}};</code>

Now we can use the generic <tt>map</tt> function to recurse everywhere into
the child nodes. Afterwards we can apply the actual transform method to the
root node:<code size = "footnotesize"
              sequel = "true"
              class = "Transform"
              lang = "java"
              package = "name/panitz/boilerplate">    everywhereT.gmap(x);
    transform(x);
  }
}</code>

The technique of providing a general <tt>map</tt> function for the direct children of
an node is not very novel, e.g. <cite label = "CoFu92"/> a tree like data definition
induces the compiler to generate a <tt>map</tt> function.<subsubsection titel = "Example: increase of all salary">
Now we can implement  a very simple solution to the first task of increasing
the salary in every salary node of the tree. We can achieve this by extending
the abstract class <tt>Transform</tt> where we  implement the 
method <tt>transform</tt> according to our needs. <code size = "footnotesize"
                class = "Increase"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
public class Increase extends Transform{
 Double k; Increase(Double k){this.k=k;}
 public void transform(Object o){
  if (<redv>o instanceof Salary){Salary s = (Salary)o;s.amount=s.amount*(1+k)</redv>;}
 }
}</code>
This looks even simpler than the XSLT solution. We do not need to bother about
the tree traversal code. Applying this transformer to out company is equally
as easy and straightforward.<footnote>We apply this transformer 100000
times. This is done for some rough performance measure later in the paper.</footnote><code size = "footnotesize"
                class = "TestIncrease"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
class TestIncrease{
  public static void main(String [] args){
    Company company = MyComp.getCompany();
    for (int i=0;i&lt;100000;i++)
      <redv>new Increase(.000017).everywhere(company)</redv>;
    System.out.println(Show.show(company));}}</code></subsubsection><subsubsection titel = "Example: flatten company structure">
The second of the task stated in the beginning of this paper, was to liquidate
certain subdepartments and integrate its employees into the next upper department. 
As we see, this is allready a rather complex application task. Fortunatly we
no longer are concerned with the tree traversal code and can concentrate on
the actual task at hand:<p/><code size = "footnotesize"
                class = "Flatten"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class Flatten extends Transform{
  String deptName;
  Flatten(String deptName){this.deptName=deptName;}
  public void transform(Object o){
   if (o instanceof Dept){
     List&lt;SubUnit&gt; newSus=new ArrayList&lt;SubUnit&gt;();
     Dept d = (Dept)o;
     for (SubUnit su:d.subUnits){
       if (su instanceof DU){
         Dept du= ((DU)su).dept;
         if (du.name.equals(deptName)){
           newSus.add(new PU(du.manager));newSus.addAll(du.subUnits);
         }else newSus.add(su);
       }else newSus.add(su);
     }
     d.subUnits=newSus;
   }
  }
}</code>

This new transformer can be applied to our company in the same way as 
the <tt>Increase</tt> transformer.<code size = "footnotesize"
                class = "TestFlatten"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
class TestFlatten{
  public static void main(String [] args){
    Company company = MyComp.getCompany();
    new Flatten(&quot;Research2&quot;).everywhere(company);
    System.out.println(Show.show(company));}}</code>

Note, that our transformers work on any object. We do not need to know the
exact tree structure or all classes involved in a company structure. Our
algorithms still work, even if new classes representing new types of
subdepartments are added to the company structure.</subsubsection><subsubsection titel = "Using Reflection">
In the solution above, we did not get completely rid of boilerplate code.
We needed to specify the concrete class, for which the method transform is
specified. This amounts in the <tt>instanceof</tt> construct. It is well
known, how to get rid of such conditions by way of Java&#39;s reflection
mechanism, e.g. in <cite label = "essenceVisitor"/> generic tree traversal
is achieved  by way of using reflection.
Following  <cite label = "essenceVisitor"/> we
 can implement a generic default instance of the 
method <tt>transform</tt>. 
 <code size = "footnotesize"
                class = "TransformReflect"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
class TransformReflect  extends Transform{
  public void transform(Object o){
    try{getClass().getMethod(&quot;transform&quot;,o.getClass()).invoke(this,o);
    }catch(IllegalAccessException  _){}
     catch(IllegalArgumentException _){}
     catch(java.lang.reflect.InvocationTargetException _){}
     catch(NoSuchMethodException _){}
  }
}</code>

This method checks the type of the argument and looks up via reflection, if
a specialized version of <tt>transform</tt> for this class 
is available. Thus the transformer to
increase the salary can simply be written as: <code size = "footnotesize"
                class = "IncreaseReflect"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class IncreaseReflect extends TransformReflect{
 Double k; IncreaseReflect(Double k){this.k=k;}
 public void transform(Salary s){<redv>s.amount=s.amount*(1+k)</redv>;}
}</code>

This implementation is completely free of any boilerplate code. 
However, reflection is slow, very slow.
 As a rough measure compare execution
times of the non-reflective with the reflective solution:<code size = "footnotesize"
                class = "TestIncreaseReflect"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
class TestIncreaseReflect{
  public static void main(String [] args){
    Company company = MyComp.getCompany();
    for (int i=0;i&lt;100000;i++)
      <redv>new IncreaseReflect(.000017).everywhere(company)</redv>;
    System.out.println(Show.show(company));}}</code>

Execution of this version compared to the original version gives the following
result: <scode>sep@pc216-5:~/boilerplate&gt; time java -cp classes/ name.panitz.boilerplate.TestIncrease
new Company(new Dept(Research,new Employee(new Person(Ralf,Amsterdam),new Salary
(43790.9463569525)),new ArrayList(new PU(new Employee(new Person(Joost,Amsterdam)
,new Salary(5473.868294619063))),new PU(new Employee(new Person(Marlow,Cambridge)
,new Salary(10947.736589238126))),new DU(new Dept(Research2,new Employee(new Pers
on(NN,Mars),new Salary(492648.1465157075)),new ArrayList())))),new Dept(Strategy,
new Employee(new Person(Blair,London),new Salary(547386.8294619016)),new ArrayLis
t()))

real    0m0.912s
user    0m0.849s
sys     0m0.013s
sep@pc216-5:~/boilerplate&gt; time java -cp classes/ name.panitz.boilerplate.TestIncreaseReflect
new Company(new Dept(Research,new Employee(new Person(Ralf,Amsterdam),new Salary
(43790.9463569525)),new ArrayList(new PU(new Employee(new Person(Joost,Amsterdam)
,new Salary(5473.868294619063))),new PU(new Employee(new Person(Marlow,Cambridge)
,new Salary(10947.736589238126))),new DU(new Dept(Research2,new Employee(new Pers
on(NN,Mars),new Salary(492648.1465157075)),new ArrayList())))),new Dept(Strategy,
new Employee(new Person(Blair,London),new Salary(547386.8294619016)),new ArrayLis
t()))

real    0m53.016s
user    0m52.010s
sys     0m0.238s
</scode></subsubsection></subsection><subsection titel = "Generic Queries"><label name = "query"/>
The transformers in the last section destructively updated the tree. In this
section we will apply the same technique to retrieve some data from the
tree. We want to state queries over the tree data and leave the tree object
unchanged. What we have in mind is a simple function taking a tree and giving
some query result. Since functions are not first class citizens in Java, we 
express a funtion by way of an interface:<p/><code size = "footnotesize"
              class = "Function1"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
interface Function1&lt;argType,resultType&gt;{resultType eval(argType x);}</code>

We provide a second interface for binary functions.<footnote>We resisted the
temptation of expressing these via currying 
as <ttt>Function1&lt;a,Function1&lt;b,c&gt;&gt;</ttt>.</footnote><code size = "footnotesize"
              class = "Function2"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
interface Function2&lt;a,b,c&gt;{c eval(a x,b y);}</code>


We can now apply the same technique for queries as for transformers. We define
the generic query class <tt>Query</tt>. It is gerneric over the result of the
query. With Java&#39;s generic types this can be elegantly expressed:<code size = "footnotesize"
              class = "Query"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
public abstract class Query&lt;b&gt; implements Function1&lt;Object,b&gt;,Function2&lt;b,b,b&gt;{</code>

Traversal
is again done in two steps. First we define a generic <tt>map</tt> method. This
method  applies the query to the child nodes and results in the list of results:<code size = "footnotesize"
              sequel = "true"
              class = "Query"
              lang = "java"
              package = "name/panitz/boilerplate">  public List&lt;b&gt; gmap(Object x){
    List&lt;b&gt; result= new ArrayList&lt;b&gt;();
    if (x instanceof Iterable) for (Object a:((Iterable)x)) result.add(eval(a));
    return result;
  }</code>

Analogously to the method <tt>everywhere</tt> in transformer case we define 
a method <tt>everything</tt>. It applies the same trick. It defines an inner
query which traverses over the child nodes. Since we get a list of results for
the child nodes, we need a function to add these up to an overall result. That
is the reason why <tt>Query</tt> implements <tt>Function2&lt;b,b,b&gt;</tt>. This function is used to sum up the partial
result to an overall result.<code size = "footnotesize"
              class = "Query"
              lang = "java"
              package = "name/panitz/boilerplate">  public b everything(Object x){
    b result = eval(x);
    final Query&lt;b&gt; dies = this;
    Query&lt;b&gt; everythingQ = null;
    if (everythingQ==null)
      everythingQ = new Query&lt;b&gt;(){
          public b eval(Object o){return dies.everything(o);}
          public b eval(b x,b y) {return dies.eval(x,y);}
      };
    for (b y:everythingQ.gmap(x)) result=eval(result,y);
    return result;
  }
}</code>

A concrete query can now be implemented by extension of 
class <tt>Query</tt>. Two methods need to be implemented: the 
method <tt>eval</tt>, which represents the actual query method and the binary
method <tt>eval</tt>, which defines how to combine partial results. In the example
of a salary bill this might look like:<code size = "footnotesize"
              class = "SalaryBill"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
class SalaryBill extends Query&lt;Double&gt;{
  public Double eval(Object x){
    if (x instanceof Salary) return ((Salary)x).amount;
    return 0.0;
  }</code>

Note that the method needs an neutral default result. <p/>

The second method to be implemented is used to combine partial results. In our
example the simple addition function will do.<code size = "footnotesize"
              class = "SalaryBill"
              lang = "java"
              seque = "true"
              package = "name/panitz/boilerplate">   public Double eval(Double x,Double y){return x+y;}
}</code>

Thus we implemented the task of summing up all salaries, without
reimplementation of the tree traversal code.<code size = "footnotesize"
              class = "TestSalaryBill"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
class TestSalaryBill{
  public static void main(String [] args){
    System.out.println(new SalaryBill().everything(MyComp.getCompany()));
  } 
}</code><subsubsection titel = "Show revisited">
          <code size = "footnotesize"
                class = "Show2"
                lang = "java"
                package = "name/panitz/boilerplate"
                commandchars = "_~^">package name.panitz.boilerplate;
class Show2 extends Query&lt;String&gt;{
  public String eval(Object x){
    return x instanceof Iterable?(&quot;new &quot;+x.getClass().getSimpleName()):x.toString();
  }
  public String eval(String x,String y){return x+&quot;(&quot;+y+&quot;)&quot;;}
  public static void main(String [] args){
    System.out.println(new Show2().everything(MyComp.getCompany()));}}</code>
        </subsubsection><subsubsection titel = "Back to XML">
We started this paper by giving an example as XML document type definition. 
Eventually we turn back to XML. The class <tt>Query</tt> enables us to
generically write a query object, which builds an XML tree for some tree
structure. We need some document builder, which we instantiate once via a
factory method:<code size = "footnotesize"
                class = "ToXML"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import javax.xml.parsers.*;
import org.w3c.dom.*;
class ToXML extends Query&lt;Node&gt;{
  static Document doc;
  static {
   try{doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
   }catch (Exception e) {throw new RuntimeException(e);}
  }</code>
The two eval methods are very simple. We create elements with the class name
of the object. Non iterable types, especially <tt>String</tt> nodes 
result in XML text nodes:<code size = "footnotesize"
                sequel = "true"
                class = "ToXML"
                lang = "java"
                package = "name/panitz/boilerplate">  public Node eval(Object o){
    if (o instanceof Iterable)
      return doc.createElement(o.getClass().getSimpleName());
    return doc.createTextNode(o.toString());
  }</code>
The second method <tt>eval</tt> for combining partial results, inserts the second
argument as child to the first argument.<code size = "footnotesize"
                sequel = "true"
                class = "ToXML"
                lang = "java"
                package = "name/panitz/boilerplate">  public Node eval(Node x,Node y){x.appendChild(y);return x;}
}</code>

This simple query object generically transforms any hierarchical structure
into an XML document. For a simple test we generate an XML document for the
company.  <code size = "footnotesize"
                class = "TestToXML"
                lang = "java"
                package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import org.w3c.dom.Node;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.StringWriter; 

class TestToXML{
  public static void main(String [] args){
    System.out.println(serialize(<redv>new ToXML().everything(MyComp.getCompany())</redv>));} </code>
We use the following simple method for transforming an XML node to a <tt>String</tt>:<code size = "footnotesize"
                class = "TestToXML"
                lang = "java"
                package = "name/panitz/boilerplate">  static public String serialize(Node doc){
    try{
      StringWriter writer = new StringWriter();
      javax.xml.transform.Transformer t
        = TransformerFactory.newInstance().newTransformer();
      t.setOutputProperty(OutputKeys.INDENT,&quot;yes&quot;);
      t.transform(new DOMSource(doc),new StreamResult(writer));
      return writer.getBuffer().toString();
    }catch (TransformerException _){return &quot;&quot;;}
  }
}</code></subsubsection></subsection><subsection titel = "Controling the traversal"><label name = "cut"/>
A close look at the result of the last example reveals that it does not build
  an XML document according to the DTD given in section~<ref name = "problem"/>. This is not a defect in our implementation 
of  <tt>ToXML</tt> but due to the fact that the Java classes for the company
  do not exactly match this DTD. No classes for person or department names are
  given. These are represented directly as a <tt>String</tt>. <p/>

We need specialized cases for certain nodes. Furthermore we need some way to
express a <em>cut</em>, i.e. some means to express, that for this node the
automatic tree traversal shall stop. Therefore we write a refinement of the
class <tt>Query</tt>. A third abstract method is added, the 
method <tt>condition</tt>. It returns true for some arbitrary node, if the
tree traversal is supposed to descent into the child nodes:<code class = "QuerySome"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
abstract class QuerySome&lt;a&gt; 
        implements Function1&lt;Object,a&gt;,Function2&lt;a,a,a&gt;{
  public abstract boolean condition(Object o);</code>

Now the method <tt>gmap</tt> only descents into the child nodes, if the
condition for the current node is true:<code class = "QuerySome"
              lang = "java"
              package = "name/panitz/boilerplate"
              sequel = "true">  public List&lt;a&gt; gmap(Object x){
    List&lt;a&gt; result= new ArrayList&lt;a&gt;();
    if (<redv>condition(x) &amp;&amp;</redv> x instanceof Iterable) 
      for (Object a:((Iterable)x)) result.add(eval(a));
    return result;
  }</code>
The rest of this class is implemented exactly like in the class <tt>Query</tt>:<code class = "QuerySome"
              lang = "java"
              package = "name/panitz/boilerplate"
              sequel = "true">  public a everything(Object x){
    a result = eval(x);
    final QuerySome&lt;a&gt; dies = this;
    QuerySome&lt;a&gt; everythingQ = null;
    if (everythingQ==null)
      everythingQ = new QuerySome&lt;a&gt;(){
       public a eval(Object o){return dies.everything(o);}
       public a eval(a x,a y) {return dies.eval(x,y);}
       public boolean condition(Object o){return dies.condition(o);}
      };
    for (a y:everythingQ.gmap(x)) result=eval(result,y);
    return result;
  }
}</code>

The class <tt>Query</tt> could thus be implemented as the specialisation 
of  <tt>QuerySome</tt> with a constant <tt>true</tt> condition.<code class = "Query2"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
abstract class Query2&lt;a&gt; extends QuerySome&lt;a&gt;{
  public boolean condition(Object o){return true;}
}</code>

No we can write a specialized version for creation of an XML documents, which
meets the special needs of the company structure. Special cases for two node
classes are given. Further traversal is stopped for these nodes:<code size = "footnotesize"
              class = "ToXML2"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import org.w3c.dom.*;
import java.util.*;
import static name.panitz.boilerplate.ToXML.*;
class ToXML2 extends QuerySome&lt;Node&gt;{
  public Node eval(Object o){
    if (o instanceof Person){
      Element p = doc.createElement(&quot;Person&quot;);
      Element n = doc.createElement(&quot;Name&quot;);
      Element a = doc.createElement(&quot;Address&quot;);
      n.appendChild(doc.createTextNode(((Person)o).name));
      a.appendChild(doc.createTextNode(((Person)o).address));
      p.appendChild(n);    
      p.appendChild(a);
      return p;    
    }    
    if (o instanceof Dept){
      Dept d =(Dept)o;
      Element result = doc.createElement(&quot;Dept&quot;);
      Element n = doc.createElement(&quot;Name&quot;);
      n.appendChild(doc.createTextNode(d.name));
      result.appendChild(n);
      result.appendChild(everything(d.manager));
      for (SubUnit su:d.subUnits) result.appendChild(everything(su));
      return result;
    }
    if (o instanceof Iterable)
      return doc.createElement(o.getClass().getSimpleName());
    return doc.createTextNode(o.toString());
  }
  public boolean condition(Object o){
    return ! (o instanceof Person||o instanceof Dept);}
  public Node eval(Node x,Node y){x.appendChild(y);return x;}
}</code>

This will generate an XML document according to <tt>company.dtd</tt>.<code size = "footnotesize"
              class = "TestToXML2"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import static  name.panitz.boilerplate.TestToXML.*;
class TestToXML2 extends ToXML2{
  public static void main(String [] args){
    System.out.println(serialize(new ToXML2().everything(MyComp.getCompany())));}}</code></subsection><subsection titel = "Conclusion">
The pattern presented in this paper is very simple, general and
powerfull. The techniques presented in the original paper for the programming
language Haskell<cite label = "revisedHaskellReport"/> could directly be adapted
to 
an object oriented
framework. Instead of higher order functions subtyping and late-binding are
used. The functions <tt>gmap</tt>, <tt>everywhere</tt> and <tt>everhting</tt> are
parameterized by overridden methods of the transform and query objects.<p/>

Things are even simpler than in the Haskell framework, 
since most necessary means are available: a
common object type and a type instance operator. <p/>

The pattern can be implemented
without using the Java&#39;s reflection mechanism. Thus it avoids
performance problems concerned with reflection. Reflection can simplify the
usage of the pattern, but is not recommendable for reasons of performance.<subsubsection titel = "Future Work">
We did not yet explore if with some minimal and  optimized use of
reflection, construction of trees can be implemented with adequate performance.
This would enable to write generic code for the inverse functions to the
transformers <tt>ToXML</tt> or <tt>Show</tt>.<p/>

In <cite label = "VisitorCombination"/> a system based on visitor combination is
presented. It might be fruitful to apply these techniques to the transformer
presented in this paper.</subsubsection></subsection><subsection titel = "Company classes">
        <label name = "companyClasses"/>
        <code size = "tiny"
              class = "Company"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class Company extends ArrayList&lt;Dept&gt;{}</code>
        <code size = "tiny"
              class = "Dept"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class Dept implements Iterable&lt;Object&gt;{
  String name;
  Employee manager;
  List&lt;SubUnit&gt; subUnits;
  Dept(String name,Employee manager,List&lt;SubUnit&gt; subUnits){
    this.name=name;this.manager=manager;this.subUnits=subUnits;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();
    result.add(name);result.add(manager);result.add(subUnits);
    return result.iterator();
  }
}</code>
        <code size = "tiny"
              class = "SubUnit"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class SubUnit implements Iterable&lt;Object&gt;{
  public Iterator&lt;Object&gt; iterator(){return new ArrayList&lt;Object&gt;().iterator();}
}</code>
        <code size = "tiny"
              class = "PU"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class PU extends SubUnit{
  Employee employee;
  PU(Employee employee){this.employee=employee;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();result.add(employee);
    return result.iterator();
  }
}</code>
        <code class = "DU"
              size = "tiny"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class DU extends SubUnit{
  Dept dept;
  DU(Dept dept){this.dept=dept;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();result.add(dept);
    return result.iterator();
  }
}</code>
        <code class = "Employee"
              size = "tiny"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class Employee implements Iterable&lt;Object&gt;{
  Person person;Salary salary;
  Employee(Person person,Salary salary){this.person=person;this.salary=salary;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();
    result.add(person);result.add(salary);
    return result.iterator();
  }
}</code>
        <code class = "Person"
              size = "tiny"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class Person implements Iterable&lt;Object&gt;{
  String name;String address;
  Person(String name,String address){this.name=name;this.address=address;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();
    result.add(name);result.add(address);
    return result.iterator();
  }
}</code>
        <code class = "Salary"
              size = "tiny"
              lang = "java"
              package = "name/panitz/boilerplate">package name.panitz.boilerplate;
import java.util.*;
class Salary implements Iterable&lt;Object&gt;{
  Double amount;
  Salary(Double amount){this.amount=amount;}
  public Iterator&lt;Object&gt; iterator(){
    List&lt;Object&gt; result = new ArrayList&lt;Object&gt;();result.add(amount);
    return result.iterator();
  }
}</code>
      </subsection></section><section titel = "Generierung von Code mit APT">
      <subsection titel = "ADT">
Algebraic data types are some powerfull means of programming. They constitute
a high level and abstract way of declarative programming. Functional
programming languages like Haskell<cite label = "revisedHaskellReport"/>, 
Clean<cite label = "cleanmanual"/> or 
ML<cite label = "milner:90"/><cite label = "camllight:073"/> 
provide build-in support for algebraic types. An algebraic type is defined by
a  set of constructors. In functional languages algebraic types can be
directly declared; e.g. the following Haskell code defines a type of binary
trees: <code size = "footnotesize"
              lang = "hs"
              class = "Tree"
              main = "main">data Tree a = 
   Branch (Tree a) a (Tree a)
  |Empty</code> 

Algorithms on algebraic types are usually written as equations that match one
of the constructor alternatives of the type. Thus the function that
calculates the size of a binary tree can be written with the following two
equations: <code size = "footnotesize"
              lang = "hs"
              class = "Tree"
              main = "main"
              sequel = "true">size Empty          = 0
size (Branch l a r) = size l + 1 + size r </code>

Common object oriented languages do not directly support algebraic
types. Programming patterns need to be applied. The usual technique used in
examples like the one above is the visitor 
pattern <cite label = "visitorpattern"/>. The algebraic type is expressed by a
base class. The constructors are different subclasses of this. A visitor
overloads a method <tt>visit</tt> for each of the subclasses representing a
constructor. This overloaded method implements the pattern equations as seen
in the Haskell example above.<p/>

The visitor pattern amounts in a lot of boilerplate code. The elegant four
lines of Haskell in the example above result in at least four  classes of
Java. Therefor extensions to Java have been proposed, which directly support
algebraic types, as e.g. <em>Pizza</em><cite label = "pizza"/>, which has been
around for quite a while. However, these extensions are rarely used
in practice. One reason for this certainly is that programmers don&#39;t want to
leave the official pure Java thread.<p/>

Recently algebraic data types have been integrated in the hybrid
functional object oriented 
language <em>Scala</em><cite label = "scala-overview-tech-report"/>.<p/>
With Java 5 an annotation framework has been introduced to Java. Code can be
annotated. These may not just be commentary annotations 
but an integral part of the
program. Annotations may be evaluated by some processor.  They open a door to
language extensions without leaving the Java thread. Typical annotations are
concerned with persistency code, transaction code or serialization code.<p/>

We will use annotions for generation of boilerplate code for the visitor
pattern. </subsection>
      <subsection titel = "Annotations for Algebraic Types">
We propose two annotations for algebraic types in Java. The 
annotation <tt>@Data</tt> for classes, which indicates that the class
represents an algebraic type, and the annotation <tt>@Constr</tt>, which
indicates that a method is a constructor case for the algebraic type.<p/>

Before we have a look at the actual implementation of the annotations we start
with 
an example. 
With these two annotations binary trees can now be defined in Java as 
follows:<p/><code size = "footnotesize"
              class = "T"
              package = "example/tree"
              lang = "java"
              apt = "true">package example.tree;
import name.panitz.adt.*;
@Data class T&lt;a&gt; {
  @Constr void Branch(T&lt;a&gt; left,a element,T&lt;a&gt; right){};
  @Constr void Empty(){};
}</code><p/>


This looks quite similar to the implementation in Haskell and compares well to
the corresponding definition in <em>Scala</em>. An algebraic 
type <tt>T</tt> is defined. This type is generic. It has a type variable for
the node contents. Note that the class above is a normal Java class. It can be
compiled with the standard Java compiler <tt>javac</tt>. However for
generation of the boilerplate code we will need to use Java&#39;s annotation
processing tool <tt>apt</tt>.<subsubsection titel = "Algorithms on algebraic types">
In the Haskell case algorithms over algebraic types could easily declared by
pattern equations. We will generate a bunch of classes for the definition
above. These provide an general visitor class <tt>TVisitor</tt>, a common base
class <tt>TAdt</tt> and specialized classes for the 
constructors <tt>Branch</tt> and <tt>Empty</tt>. With these an algorithm over
trees can be implemented as a specialized visitor. The <tt>visit</tt> function
gets overloaded for the two constructor cases:<p/><code size = "footnotesize"
                class = "TSize"
                package = "example/tree"
                lang = "java">package example.tree;
public class TSize&lt;a&gt; extends TVisitor&lt;a,Integer&gt;{
  public Integer visit(Branch&lt;a&gt; x){
    return size(x.left) + 1 + size(x.right);}
  public Integer visit(Empty&lt;a&gt; _){return 0;}</code><p/>

A general function <tt>size</tt> was assumed, that calls the 
methods <tt>welcome</tt>. 
For some technical reason, we need a cast to the generated
base class <tt>TAdt</tt>.<p/><code size = "footnotesize"
                class = "TSize"
                package = "example/tree"
                lang = "java"
                sequel = "true">  public int size(T&lt;a&gt; t){return ((TAdt&lt;a&gt;)t).welcome(this);}
}</code><p/>


In fact, we are not far away from  the Haskell implementation. 
In the next section
we will reveal, how the processing of the two 
annotations <tt>@Data</tt> and <tt>@Constr</tt> has been implemented.</subsubsection></subsection>
      <subsection titel = "Implementation">
In this section we give the complete implementation of the annotations for
algebraic types in Java. There is no hidden code. In order to  meet the size
restriction of a conference paper, brevity is preferred over clarity in the
code.  <p/>


First of all, annotations are interfaces that need to be defined in Java. <code size = "footnotesize"
              lang = "java"
              class = "Data"
              package = "name/panitz/adt">package name.panitz.adt;
public @interface Data{}</code><code size = "footnotesize"
              lang = "java"
              class = "Constr"
              package = "name/panitz/adt">package name.panitz.adt;
public @interface Constr{}</code>

Now we need a generator. Generators can be loaded by the <tt>apt</tt> tool
through a factory class. The standard way to implement this is by way of a
subclass of <tt>AnnotationProcessorFactory</tt>.<code size = "footnotesize"
              lang = "java"
              class = "AdtGenFact"
              package = "name/panitz/adt">package name.panitz.adt;
import com.sun.mirror.apt.*;
import com.sun.mirror.declaration.*;
import java.util.*;

public class AdtGenFact implements AnnotationProcessorFactory{
  static final String DATA_ANNOT   = &quot;name.panitz.adt.Data&quot;;
  static final String CONSTR_ANNOT = &quot;name.panitz.adt.Constr&quot;;

  public AnnotationProcessor getProcessorFor
    (Set&lt;AnnotationTypeDeclaration&gt; types
    ,AnnotationProcessorEnvironment env){
      return new AdtGen(types,env);
  }
  public Collection&lt;String&gt; supportedAnnotationTypes(){
    ArrayList&lt;String&gt; result= new ArrayList&lt;String&gt;();
    result.add(CONSTR_ANNOT);result.add(DATA_ANNOT);
    return result;
  }
  public Collection&lt;String&gt; supportedOptions(){
    return new ArrayList&lt;String&gt;();
  }
}</code>

We decided for the most simple implementation, which simply returns a instance
of the actual generator class.<code size = "footnotesize"
              lang = "java"
              class = "AdtGen"
              package = "name/panitz/adt">package name.panitz.adt;
import com.sun.mirror.apt.*;
import com.sun.mirror.util.*;
import com.sun.mirror.declaration.*;
import java.util.*;
public class AdtGen extends SimpleDeclarationVisitor
                    implements AnnotationProcessor{
  Set&lt;AnnotationTypeDeclaration&gt; types;
  AnnotationProcessorEnvironment env;
  public AdtGen(Set&lt;AnnotationTypeDeclaration&gt; types
                 ,AnnotationProcessorEnvironment env){
    this.types=types;
    this.env=env;
    constrDeclaration = env.getTypeDeclaration(AdtGenFact.CONSTR_ANNOT);
    dataDeclaration = env.getTypeDeclaration(AdtGenFact.DATA_ANNOT);
  } 
  public void process(){
   for (TypeDeclaration td :env.getSpecifiedTypeDeclarations()){
      td.accept(this);
   }
  }</code>

The actual generator is implemented as an  visitor over the declaration types
in package <tt>com.sun.mirror.declaration</tt>.<code size = "footnotesize"
              lang = "java"
              class = "AdtGen"
              package = "name/panitz/adt"
              sequel = "true">  final private TypeDeclaration constrDeclaration;
  final private TypeDeclaration dataDeclaration;

  boolean hasAnnot(TypeDeclaration a,Declaration m){
    for (AnnotationMirror am : m.getAnnotationMirrors()) 
      if(am.getAnnotationType().getDeclaration().equals(a))
        return true;
    return false;
  }

  public void visitClassDeclaration(ClassDeclaration d){
   if (hasAnnot(dataDeclaration,d)){
    ADT adt = new ADT(env,d); 
    for (MethodDeclaration m:d.getMethods()){
      if (hasAnnot(constrDeclaration,m)){ 
        adt.addConstr(m.getSimpleName(),m.getParameters());
      }
    }
    adt.generateClasses();   
  }}}</code>


Eventually we come to the actual generation of the boilerplate code.<subsubsection titel = "representation of algebraic types">
The main class <tt>ADT</tt> represents an algebraic type:<p/><code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt">package name.panitz.adt;

import java.util.*;
import java.io.*;
import com.sun.mirror.declaration.*;
import com.sun.mirror.apt.*;

public class ADT {</code><p/>
It needs the following information:<itemize>
            <item>a name for the algebraic type.</item>
            <item>the package for the type.</item>
            <item>a list of constructors.</item>
            <item>furthermore we need 
the <tt>AnnotationProcessorEnvironment</tt>, which will give us a filer, for
generating new source files.</item>
          </itemize><p/><code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true">  String name;
  String thePackage;
  public List&lt;Constructor&gt; constructors;
  TypeDeclaration cd;
  final Filer filer;</code><p/>

These fields get initialized in a simple constructor:<p/><code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true">  public ADT
    (AnnotationProcessorEnvironment env,TypeDeclaration cd){
      thePackage = cd.getPackage().getQualifiedName();
      name=cd.getSimpleName();
      constructors=new ArrayList&lt;Constructor&gt;();
      this.cd=cd;
      filer=env.getFiler();
  }</code>


We provide some auxiliary methods for retrieving the name of the type 
and the textual
representation of the type parameters:<code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true"
                commandchars = "`~^">  public String getFullName(){return cd.toString();}
  public String getName(){return name;}
  String commaSepPs(){
    final String qN=getFullName();
    final int index=qN.indexOf(&#39;&lt;&#39;);
    return index&gt;=0?qN.substring(index+1,qN.length()-1):&quot;&quot;;
  }
  public String getParamList(){
    return commaSepPs().length()==0?&quot;&quot;:(&quot;&lt;&quot;+commaSepPs()+&quot;&gt;&quot;);
  }
  String getPackageDef(){
    return  thePackage.length()==0?&quot;&quot;
           :&quot;package &quot;+thePackage+&quot;;\n\n&quot;;
  }</code>

The following method is used to add a further constructor to the algebraic
type. The class <tt>Constructor</tt> will be defined as inner 
class of <tt>ADT</tt> below.<code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true"
                commandchars = "`~^">  void addConstr(String n,Collection&lt;ParameterDeclaration&gt; ps){
   constructors.add(new Constructor(n,ps));
}</code>

Wie need to generate:<itemize>
            <item>a common base class for the type,</item>
            <item>a visitor interface,</item>
            <item>and for each constuctor a subclass of the base class.</item>
          </itemize><p/><code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true">  public void generateClasses(){
    try{generateClass();
        generateVisitorClass();
        for (Constructor c:constructors)c.generateClass(this);
    }catch (IOException _){}}</code><paragraph titel = "Generating the base class">
The base class extends the class, which has been annotated 
as <tt>@Data</tt> class. It has the same name with suffix <tt>Adt</tt>.
We use the filer to create the source for the base class:<p/><code size = "footnotesize"
                  lang = "java"
                  class = "ADT"
                  package = "name/panitz/adt"
                  sequel = "true">  public void generateClass() throws IOException{
    final String fullName = getFullName();
    Writer out 
     = filer.createSourceFile(thePackage+&quot;.&quot;+name+&quot;Adt&quot;);</code><p/>
The generated class is abstract.<p/><code size = "footnotesize"
                  lang = "java"
                  class = "ADT"
                  package = "name/panitz/adt"
                  sequel = "true"
                  commandchars = "`~^">    out.write( getPackageDef());
    out.write(&quot;public abstract class &quot;);
    out.write(getName()+&quot;Adt&quot;+getParamList());
    out.write(&quot; extends &quot;+fullName+&quot;\n&quot;);
    out.write(&quot; implements Iterable&lt;Object&gt;{\n&quot;);</code><p/>
It has the abstract   
method <tt>welcome</tt>. This is the method that welcomes a 
visitor.<footnote>This usually is called <ttt>accept</ttt>.</footnote> 
It is an generic method. Its type variable, which we hard coded 
as <tt>b_</tt>, represents the result type of the visitor.<p/><code size = "footnotesize"
                  lang = "java"
                  class = "ADT"
                  package = "name/panitz/adt"
                  sequel = "true"
                  commandchars = "`~^">    out.write(&quot;  abstract public &lt;b_&gt; b_ welcome(&quot;
            +name+&quot;Visitor&lt;&quot; + commaSepPs()
                            +(commaSepPs().length()==0?&quot;&quot;:&quot;,&quot;)
                            +&quot;b_&gt; visitor);\n&quot;);  
    out.write(&quot;}&quot;);
    out.close();
  }</code><p/></paragraph><paragraph titel = "Generating the visitor interface">
The next class that gets generated is the general visitor class. We decided
for an abstract class, which has an abstract 
method <tt>visit</tt> for each constructor, and additionally a concrete general
method <tt>visit</tt> overloaded for the base class. This ensures that cases,
which were forgotten to be implemented in a concrete visitor class
will cause a runtime exception.<p/>

The visitor class is generic. It has the type variables of the base class and
additionally a type variable for the result type of the 
methods <tt>visit</tt>.<p/><code size = "footnotesize"
                  lang = "java"
                  class = "ADT"
                  package = "name/panitz/adt"
                  sequel = "true"
                  commandchars = "`~^">  public void generateVisitorClass(){
    try{
      final String csName = name+&quot;Visitor&quot;;	
      final String fullName
       = csName+&quot;&lt;&quot;+commaSepPs()
                   +(commaSepPs().length()==0?&quot;&quot;:&quot;,&quot;)+&quot;result&gt;&quot;;
      Writer out=filer.createSourceFile(thePackage+&quot;.&quot;+csName);
      out.write( getPackageDef()+ &quot;\n&quot;);
      out.write(&quot;public abstract class &quot;);
      out.write(fullName+&quot;{\n&quot;);
      for (Constructor c:constructors) 
        out.write(&quot;  &quot;+c.mkVisitMethod(this)+&quot;\n&quot;);

      out.write(&quot;  public result visit(&quot;+getFullName()+&quot; xs){&quot;);
      out.write(&quot;\n    throw new RuntimeException(&quot;);
      out.write(&quot;\&quot;unmatched pattern: \&quot;+xs.getClass());\n&quot;);
      out.write(&quot;  }\n}&quot;);
      out.close();
    }catch (Exception _){}
  }</code></paragraph></subsubsection><subsubsection titel = "Generating constructor classes">

Eventually we generate classes for each of the constructors in the algebraic
type. Constructors are represented by an inner class of class <tt>ADT</tt>:<code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true">private class Constructor {</code><p/>

Constructors have a name and list of parameters:<p/><code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true">  String name;
  Collection&lt;ParameterDeclaration&gt; params;</code><p/>

These get initialized during construction:<p/><code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true">  public Constructor
             (String n,Collection&lt;ParameterDeclaration&gt; ps){
    name=n;params=ps;}</code><p/>



We generate a class with the name of the constructor. It extends the base
class and has the same type variables as the base class:<code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true">  public void generateClass(ADT theType){
    try{
      Writer out
        = filer.createSourceFile(theType.thePackage+&quot;.&quot;+name);
      out.write( theType.getPackageDef());
      out.write(&quot;public class &quot;+name);
      out.write(theType.getParamList()+&quot; extends &quot;);
      out.write(theType.getName()+&quot;Adt&quot;+theType.getParamList());
      out.write(&quot;{\n&quot;);</code>

In the body of the class we generate:<itemize>
            <item>fields for the arguments of the constructor.</item>
            <item>the method <tt>welcome</tt></item>
            <item>the method <tt>equals</tt></item>
            <item>the method <tt>toString</tt></item>
            <item>the method <tt>iterator</tt></item>
          </itemize>

This is done in seperate methods:<code size = "footnotesize"
                lang = "java"
                class = "ADT"
                package = "name/panitz/adt"
                sequel = "true">      mkFields(out);
      mkConstructor(out);
      mkWelcomeMethod(theType, out);
      mkToStringMethod(out);
      mkEqualsMethod(out);
      mkIteratorMethod(out);
      out.write(&quot;}\n&quot;);out.close();
    }catch (Exception _){}
  }</code><p/><paragraph titel = "Fields">
For every argument of the constructor we generate a  field in the
      class. <p/><code size = "footnotesize"
                  lang = "java"
                  class = "ADT"
                  package = "name/panitz/adt"
                  sequel = "true">  private void mkFields(Writer out)throws IOException{
    for (ParameterDeclaration p:params){
     out.write(&quot;  public &quot;+p.getType().toString()+&quot; &quot;);
     out.write(p.getSimpleName());
     out.write(&quot;;\n&quot;);
    }
  }</code><p/></paragraph><paragraph titel = "Constructor">
A single constructor is generated, which initializes the  fields.<p/><code size = "footnotesize"
                  class = "ADT"
                  lang = "java"
                  package = "name/panitz/adt"
                  sequel = "true">  private void mkConstructor(Writer out)throws IOException{
    out.write(&quot;\n  public &quot;+name+&quot;(&quot;);
    boolean first= true;
    for (ParameterDeclaration p:params){
      if (!first){out.write(&quot;,&quot;);}
      out.write(p.getType().toString()+&quot; &quot;);
      out.write(p.getSimpleName());
      first=false;
    }
    out.write(&quot;){\n&quot;);
    for (ParameterDeclaration p:params){
      out.write(&quot;    this.&quot;+p.getSimpleName()+&quot; = &quot;);
      out.write(p.getSimpleName()+&quot;;\n&quot;);
    }
    out.write(&quot;  }\n\n&quot;);
  }</code></paragraph><paragraph titel = "Get-methods">
For each private field a public get-method is generated.<code size = "footnotesize"
                  class = "ADT"
                  lang = "java"
                  package = "name/panitz/adt"
                  sequel = "true">  private void mkGetterMethods(Writer out)throws IOException{
    for (ParameterDeclaration p:params){
      out.write(&quot;  public &quot;);
      out.write(p.getType().toString());
      out.write(&quot; get&quot;);
      out.write(
       Character.toUpperCase(p.getSimpleName().charAt(0)));
      out.write(p.getSimpleName().substring(1));
      out.write(&quot;(){return &quot;+p.getSimpleName() +&quot;;}\n&quot;);
    }
  }</code><p/></paragraph><paragraph titel = "Set-methods">
For each private field a public set-method is generated.<code size = "footnotesize"
                  class = "ADT"
                  lang = "java"
                  package = "name/panitz/adt"
                  sequel = "true">  private void mkSetterMethods(Writer out)throws IOException{
    for (ParameterDeclaration p:params){
      out.write(&quot;  public void set&quot;);
      out.write(
       Character.toUpperCase(p.getSimpleName().charAt(0)));
      out.write(p.getSimpleName().substring(1));
      out.write(&quot;(&quot;);
      out.write(p.getType().toString());
      out.write(&quot; &quot;);
      out.write(p.getSimpleName());
      out.write(&quot;){this.&quot;+p.getSimpleName());
      out.write(&quot;= &quot;+p.getSimpleName()+&quot;;}\n&quot;);
    }
  }</code><p/></paragraph><paragraph titel = "Welcome method">
We generate the standard method <tt>welcome</tt>, which calls the 
method <tt>visit</tt> of the passed visitor with this object:<p/><code size = "footnotesize"
                  class = "ADT"
                  lang = "java"
                  package = "name/panitz/adt"
                  sequel = "true"
                  commandchars = "`~^">  private void mkWelcomeMethod(ADT theType,Writer out)
         throws IOException{
      out.write(&quot;  public &lt;_b&gt; _b welcome(&quot;
		+theType.name+&quot;Visitor&lt;&quot;+theType.commaSepPs()
                      +(theType.commaSepPs().length()==0?&quot;&quot;:&quot;,&quot;)
                                +&quot;_b&gt; visitor){&quot;
                +&quot;\n    return visitor.visit(this);\n  }\n&quot;); 
  }</code></paragraph><paragraph titel = "toString">
For the sake of comfort, we also generate the method <tt>toString</tt> in a
natural way.<code size = "footnotesize"
                  lang = "java"
                  class = "ADT"
                  package = "name/panitz/adt"
                  sequel = "true">  private void mkToStringMethod(Writer out) throws IOException{
    out.write(&quot;  public String toString(){\n&quot;);
    out.write(&quot;    return \&quot;&quot;+name+&quot;(\&quot;&quot;);
    boolean first=true;
    for (ParameterDeclaration p:params){
     if (first){first=false;}
     else out.write(&quot;+\&quot;,\&quot;&quot;);
     out.write(&quot;+&quot;+p.getSimpleName());
    }
    out.write(&quot;+\&quot;)\&quot;;\n  }\n&quot;); 
  }</code></paragraph><paragraph titel = "equals">
In the same way a standard method <tt>equals</tt> is generated:<code size = "footnotesize"
                  lang = "java"
                  class = "ADT"
                  package = "name/panitz/adt"
                  sequel = "true">  private void mkEqualsMethod(Writer out) throws IOException{
    out.write(&quot;  public boolean equals(Object other){\n&quot;);
    out.write(&quot;    if (!(other instanceof &quot;+name+&quot;)) &quot;);
    out.write(&quot;return false;\n&quot;);
    out.write(&quot;    final &quot;+name+&quot; o= (&quot;+name+&quot;) other;\n&quot;);
    out.write(&quot;    return true  &quot;);
    for (ParameterDeclaration p:params){
      out.write(&quot;&amp;&amp; &quot;+p.getSimpleName()
                     +&quot;.equals(o.&quot;+p.getSimpleName()+&quot;)&quot;);
    }
    out.write(&quot;;\n  }\n&quot;); 
  }</code></paragraph><paragraph titel = "iterator">
In the same way a  method <tt>iterator</tt> is generated. This enables us to
apply the <em>scrap your boilerplate 
code</em><cite label = "LPJ03"/><cite label = "syb2"/> pattern to the generated
algebraic type. <code size = "footnotesize"
                  lang = "java"
                  class = "ADT"
                  package = "name/panitz/adt"
                  sequel = "true">  private void mkIteratorMethod(Writer out) throws IOException{
    out.write(&quot;  public java.util.Iterator&lt;Object&gt;iterator(){&quot;);
    out.write(&quot;\n    java.util.List&lt;Object&gt; res\n&quot;);
    out.write(&quot;         =new java.util.ArrayList&lt;Object&gt;();\n&quot;);
    for (ParameterDeclaration p:params)
      out.write(&quot;    res.add(&quot;+p.getSimpleName()+&quot;);\n&quot;);
    out.write(&quot;    return res.iterator();\n  }\n&quot;); 
  }</code></paragraph><paragraph titel = "the method visit">
For each constructor an abstract method <tt>visit</tt> had been generated in
the general abstract visitor class. This was done by calls to the following
method. <code size = "footnotesize"
                  lang = "java"
                  class = "ADT"
                  package = "name/panitz/adt"
                  sequel = "true">  public String mkVisitMethod(ADT theType){
    return &quot;public abstract result visit(&quot;
            +name+theType.getParamList()+&quot; _);&quot;;
  }
}}</code></paragraph></subsubsection></subsection>
      <subsection titel = "Example: a tiny imperativ programming language">
A typical example application for the visitor pattern is compiler
construction. The abstract syntax tree of a programming language can easily be
defined as an algebraic type. The following <tt>@Data</tt> class defines an
abstract syntax tree of statements in a tiny imperative programming language. <code size = "footnotesize"
              class = "Klip"
              lang = "java"
              apt = "true"
              package = "name/panitz/adt/examples">package name.panitz.adt.examples;
import name.panitz.adt.*;
import java.util.List;

abstract @Data class Klip implements Iterable&lt;Object&gt; {
  @Constr void Num(Integer i){};
  @Constr void Add(Klip e1,Klip e2){};
  @Constr void Mul(Klip e1,Klip e2){};
  @Constr void Sub(Klip e1,Klip e2){};
  @Constr void Div(Klip e1,Klip e2){};
  @Constr void Var(String name){};
  @Constr void Assign(String var,Klip e){};
  @Constr void While(Klip cond,Klip body){};
  @Constr void Block(List&lt;Klip&gt; stats){};
}</code><subsubsection titel = "Show">
The first visitor we present for this type, represents it as 
a <tt>String</tt>. The corresponding visitor can be written as: <code size = "footnotesize"
                class = "ShowKlip"
                package = "name/panitz/adt/examples"
                lang = "java">package name.panitz.adt.examples;
import name.panitz.*;
import java.util.*;

public class ShowKlip extends KlipVisitor&lt;String&gt; {
  public String s(Klip a){return ((KlipAdt)a).welcome(this);}

  public String visit(Num x){return x.i.toString();}
  public String visit(Add x){return&quot;(&quot;+s(x.e1)+&quot;+&quot;+s(x.e2)+&quot;)&quot;;}
  public String visit(Sub x){return&quot;(&quot;+s(x.e1)+&quot;-&quot;+s(x.e2)+&quot;)&quot;;}
  public String visit(Div x){return&quot;(&quot;+s(x.e1)+&quot;/&quot;+s(x.e2)+&quot;)&quot;;}
  public String visit(Mul x){return&quot;(&quot;+s(x.e1)+&quot;*&quot;+s(x.e2)+&quot;)&quot;;}
  public String visit(Var v){return v.name;}
  public String visit(Assign x){return x.var+&quot; := &quot;+s(x.e);}
  public String visit(Block b){
    StringBuffer result=new StringBuffer();
    for (Klip x:b.stats)  result.append(s(x)+&quot;;\n&quot;);
    return result.toString();}
  public String visit(While w){
    StringBuffer result=new StringBuffer(&quot;while (&quot;);
    result.append(s(w.cond)+&quot;){\n&quot;);
    result.append(s(w.body)+&quot;\n}&quot;);
    return result.toString();}
}</code>

This will e.g. print a program for calculating the factorial as follows:<code size = "footnotesize"
                class = "fak"
                lang = "klip"
                package = "name/panitz/adt/examples">x := 5;
y := 1;
while (x){
y := (y*x);
x := (x-1);

};
y;</code></subsubsection><subsubsection titel = "Evaluation visitor">
A further visitor defines an interpreter for the tiny imperative language. 
This visitor has an internal map for binding of the variables used in the
program: <code size = "footnotesize"
                lang = "java"
                class = "EvalKlip"
                package = "name/panitz/adt/examples">package name.panitz.adt.examples;
import name.panitz.*;
import java.util.*;

public class EvalKlip extends KlipVisitor&lt;Integer&gt; {
 Map&lt;String,Integer&gt; env = new HashMap&lt;String,Integer&gt;();
 public Integer v(Klip x){return ((KlipAdt)x).welcome(this);}

 public Integer visit(Num x){return x.i;}
 public Integer visit(Add x){return v(x.e1)+v(x.e2);}
 public Integer visit(Sub x){return v(x.e1)-v(x.e2);}
 public Integer visit(Div x){return v(x.e1)/v(x.e2);}
 public Integer visit(Mul x){return v(x.e1)*v(x.e2);}
 public Integer visit(Var v){return env.get(v.name);}
 public Integer visit(Assign ass){
   final Integer i = v(ass.e);env.put(ass.var,i);
   return i;}
 public Integer visit(Block b){
    Integer result = 0;
    for (Klip x:b.stats) result=v(x);
    return result;}
 public Integer visit(While w){
    Integer result = 0;
    while (v(w.cond)!=0) result = v(w.body);
    return result;}
}</code></subsubsection><subsubsection titel = "Generic queries">
Since we implemented the interface <tt>Iterable&lt;Object&gt;</tt> for all
node classes, we can apply the <em>scrap your 
boilerplate</em> pattern.<cite label = "sepboilerplate"/>. Arbitrary tree
traversal code can be implemented through subclasses 
of <tt>Query</tt> or <tt>Transform</tt>. <paragraph titel = "Query">
The following simple example
collects all variable names within an abstract syntax tree.<code size = "footnotesize"
                  class = "GetVars"
                  lang = "java"
                  package = "name/panitz/boilerplate">package name.panitz.adt.examples;
import name.panitz.boilerplate.Query;
import java.util.*;
class GetVars extends Query&lt;Set&lt;String&gt;&gt;{
  public Set&lt;String&gt; eval(Object x){
    Set&lt;String&gt; result = new HashSet&lt;String&gt;(); 
    if (x instanceof Var) result.add(((Var)x).name);
    if (x instanceof Assign) result.add(((Assign)x).var);
    return result;
  }
  public Set&lt;String&gt; eval(Set&lt;String&gt; x,Set&lt;String&gt; y){
    x.addAll(y);
    return x;
  }
}</code></paragraph><paragraph titel = "Transform">
The following transformer adds a prefix to every variable name occuring in the
abstract syntax tree.<code size = "footnotesize"
                  class = "AddPrefix"
                  lang = "java"
                  package = "name/panitz/boilerplate">package name.panitz.adt.examples;
import name.panitz.boilerplate.Transform;
import java.util.*;
public class AddPrefix extends Transform{
  final String prefix;
  public AddPrefix(String prefix){this.prefix=prefix;}
  public void transform(Object x){
    if (x instanceof Var) ((Var)x).name=prefix+((Var)x).name;
    else if (x instanceof Assign) 
       ((Assign)x).var=prefix+((Assign)x).var;;
  }
}</code></paragraph>

A <tt>javacc</tt> parser definition for the tiny imperative language can be
found <exlink address = "http://panitz.name/paper/adt">at 
the corresponding website to this paper</exlink>. 

The different algorithms on the abstract syntax tree in the previous
subsections can be invoked as follows<code class = "TestKlip"
                lang = "java"
                package = "name/panitz/adt/examples">package name.panitz.adt.examples;
import java.io.FileReader;
public class TestKlip{
  public static void main(String [] args)throws Exception{
   final Klip klip = new KlipParser(new FileReader(args[0]))
                    .statementList();

   System.out.println(new ShowKlip().s(klip));
   System.out.println(new EvalKlip().v(klip));
   System.out.println(new GetVars().everything(klip));
   new AddPrefix(&quot;$&quot;).everywhere(klip);
   System.out.println(new ShowKlip().s(klip));
  }
}</code></subsubsection><subsection titel = "javacc Parser für Klip"><p/><code size = "footnotesize"
                lang = "java"
                class = "Pair"
                package = "name/panitz/adt">package name.panitz.adt;
public class Pair&lt;a,b&gt;{
  a e1;
  b e2;
  Pair(a e1,b e2){this.e1=e1;this.e2=e2;}
}</code><p/>


Schließlich, um Klipprogramme ausführen zu können, benötigen wir einen Parser,
 der die textuelle Darstellung eines Klipprogramms in die Baumstruktur
 umwandelt. Wir schreiben einen solchen Parser mit Hilfe des 
Parsergenerators <tt>javacc</tt>.<p/>



Der Parser soll zunächst eine Hauptmethode enthalten, die ein Klipprogramm
parst und die beiden Besucher auf ihn anwendet:<code size = "footnotesize"
                class = "KlipParser"
                lang = "jj"
                package = "name/panitz/adt/examples"
                commandchars = "`~^">options {
   STATIC=false;
}

PARSER_BEGIN(KlipParser)
package name.panitz.adt.examples;

import  name.panitz.adt.Pair;
import java.util.*;
import java.io.FileReader;

public class KlipParser  {
  public static void main(String [] args)throws Exception{
    final Klip klip = new KlipParser(new FileReader(args[0]))
                     .statementList();

    System.out.println(new ShowKlip().s(klip));
    System.out.println(new EvalKlip().v(klip));
    System.out.println(new GetVars().everything(klip));
    new AddPrefix(&quot;$&quot;).everywhere(klip);
    System.out.println(new ShowKlip().s(klip));
  }
}
PARSER_END(KlipParser)</code><subsubsection titel = "Scanner">
In einer <tt>javacc</tt>-Grammatik wird zunächst die Menge der
Terminalsymbole spezifiziert. <code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">TOKEN :
{&lt;WHILE: &quot;while&quot;&gt;
|&lt;#ALPHA:	[&quot;a&quot;-&quot;z&quot;,&quot;A&quot;-&quot;Z&quot;,&quot;_&quot;,&quot;.&quot;]	&gt;
|&lt;NUM:		[&quot;0&quot;-&quot;9&quot;]		&gt;
|&lt;#ALPHANUM:	&lt;ALPHA&gt; | &lt;NUM&gt;		&gt;
|&lt;NAME: &lt;ALPHA&gt; ( &lt;ALPHANUM&gt; )*&gt;
|&lt;ASS: &quot;:=&quot;&gt;
|&lt;LPAR: &quot;(&quot;&gt;
|&lt;RPAR: &quot;)&quot;&gt;
|&lt;LBRACKET: &quot;{&quot;&gt;
|&lt;RBRACKET: &quot;}&quot;&gt;
|&lt;SEMICOLON: &quot;;&quot;&gt;
|&lt;STAR: &quot;*&quot;&gt;
|&lt;PLUS: &quot;+&quot;&gt;
|&lt;SUB: &quot;-&quot;&gt;
|&lt;DIV: &quot;/&quot;&gt;
}</code>

Zusätzlich läßt sich spezifizieren, welche Zeichen als Leerzeichen anzusehen
sind: <code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">SKIP :
{ &quot;\u0020&quot;
| &quot;\t&quot;
| &quot;\n&quot;
| &quot;\r&quot;
}</code></subsubsection><subsubsection titel = "Parser">
Es folgen die Regeln der Klip-Grammatik. Ein Klip Programm ist zunächst eine
Sequenz von Befehlen:<code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">Klip statementList() : 
{  List&lt;Klip&gt; stats = new ArrayList&lt;Klip&gt;();
   Klip stat;}
{ 
  (stat=statement() {stats.add(stat);} &lt;SEMICOLON&gt;)*
  {return new Block(stats);}
}</code>

Ein Befehl kann zunächst ein arithmetischer Ausdruck in Punktrechnung sein. <code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">Klip statement():
{Klip e2;Klip result;boolean sub=false;}
{  
  result=multExpr() 
  [ (&lt;PLUS&gt;|&lt;SUB&gt;{sub=true;}) e2=statement() 
   {result = sub?new Sub(result,e2):new Add(result,e2);}]
  {return result;}
}</code>

Die Operanden der Punktrechnung sind  arithmetische Ausdruck in 
Strichrechnung. Auf diese Weise realisiert der Parser einen Klip-Baum, in dem
Punktrechnung stärker bindet als Strichrechnung. <code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">Klip multExpr():
{Klip e2;Klip result;boolean div= false;}
{  
  result=atomicExpr() 
  [ (&lt;STAR&gt;|&lt;DIV&gt;{div=true;}) 
    e2=multExpr() 
    {result = div?new Div(result,e2):new Mul(result,e2);}]
  {return result;}
}</code>
Die Operanden der Punktrechnung sind entweder Literale, Variablen, 
Zuweisungen, Schleifen
      oder geklammerte Ausdrücke. <code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">Klip atomicExpr():
{Klip result;}
{  
   (result=integerLiteral()
   |result=varOrAssign()
   |result=whileStat()
   |result=parenthesesExpr()
   )
  {return result;}
}</code>
Ein Literal ist eine Sequenz von Ziffern.<code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">Klip integerLiteral():
{ int result = 0;
  Token n;
  boolean m=false;}
{  [&lt;SUB&gt; {m = true;}]
   (n=&lt;NUM&gt;  
    {result=result*10+n.toString().charAt(0)-48;})+
   {return new Num(new Integer(m?-result:result));}
}</code>
Geklammerte Ausdrücke klammern beliebige Befehle.<code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">Klip parenthesesExpr():
{Klip result;}
{ &lt;LPAR&gt; result = statement() &lt;RPAR&gt;
{return result;}}</code>

Variablen können einzeln oder auf der linken Seite einer Zuweisung auftreten. <code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">Klip varOrAssign():
{ Token n;Klip result;Klip stat;}
{ n=&lt;NAME&gt;{result=new Var(n.toString());} 
  [&lt;ASS&gt; stat=statement() 
    {result = new Assign(n.toString(),stat);}
  ]
  {return result;}
}</code>

Und schließlich noch die Regel für die <tt>while</tt>-Schleife.<code size = "footnotesize"
                  class = "KlipParser"
                  lang = "jj"
                  sequel = "true"
                  package = "name/panitz/adt/examples"
                  commandchars = "`~^">Klip whileStat():{
  Klip cond; Klip body;}
{ &lt;WHILE&gt; &lt;LPAR&gt;cond=statement()&lt;RPAR&gt; 
  &lt;LBRACKET&gt; body=statementList()&lt;RBRACKET&gt;
  {return new While(cond,body);}
}</code></subsubsection><subsubsection titel = "Klip-Beispiele">
Unser Klip-Interpreter ist fertig. Wir können Klip-Programme ausführen
lassen. <p/>

Zunächst mal zwei Programme, die die Arithmetik demonstrieren:<code size = "footnotesize"
                  class = "arith1"
                  lang = "klip"
                  package = "name/panitz/adt/examples">2*7+14*2;</code><code size = "footnotesize"
                  class = "arith2"
                  lang = "klip"
                  package = "name/panitz/adt/examples">2*(7+9)*2;</code><scode>sep@linux:~&gt; java name.panitz.adt.examples.KlipParser arith1.klip
((2 * 7) + (14 * 2));

42
sep@linux:~&gt; java name.panitz.adt.examples.KlipParser arith2.klip
(2 * ((7 + 9) * 2));

64
sep@linux:~&gt;</scode>

Auch unser erstes Fakultätsprogramm in Klip läßt sich ausführen:<scode>sep@linux:~&gt; java name.panitz.adt.examples.KlipParser fak.klip
x := 5;
y := 1;
while (x){
y := (y * x);
x := (x - 1);

};
y;

{y=1, x=5}
{y=5, x=4}
{y=20, x=3}
{y=60, x=2}
{y=120, x=1}
120
sep@linux:~&gt;</scode>

Wie man sieht bekommen wir auch eine Traceausgabe über die Umgebung während
der Auswertung.</subsubsection></subsection></subsection>
      <subsection titel = "Conclusion">
We have presented an example of how Java annotations can be used to generate
boilerplate code for a usefull programming pattern. The implementation of the
code generator was fairly easy and could be printed out completely within a
conference paper. The annotations extend Java with some new high level
programming construct: a declarative way of defining algebraic data types. 
While we achieved this, we did not even exploit the full
power of Java annotations.<p/>

A drawback to our solutions is, that it is not possible to add features to
existing classes other than by way of subtyping. Instead of creating a new
base class <tt>KlipAdt</tt> we would have liked to change 
class <tt>Klip</tt>. This amounts in casts from the defining class to the 
generated base class.
It does not seem to be possible, to change existing classes.<p/>


Generation of classes with the <tt>apt</tt> api is (still) somewhat clumsy. A
writer is used. There are no classes, which help to construct new source code.<p/>
It turns out that annotations offer a new way of programming: instead of
switching to newer powerfull languages, which need an seperate compiler, the
language can be extended with new features. We expect to see quite a number of
such extensions to  come up in the future. A lot of common patterns seem to
be candidates for generation of boilerplate code driven by annotations.<p/>

However, this mechanism seems to
be limited. It might be interesting future work, to investigate  how far we can
go. Is it possible to express some real pattern matching expression in terms
of Java annotations? </subsection>
    </section></kapitel>
  <kapitel titel = "XML">
XML ist eine Sprache, die es erlaubt Dokumente mit einer logischen
Struktur zu beschreiben. Die Grundidee dahinter ist, die logische
Struktur eines Dokuments von seiner Visualisierung zu trennen. Ein
Dokument mit einer bestimmten logischen Struktur kann für verschiedene
Medien unterschiedlich visualisiert werden, z.B.~als HTML-Dokument für
die Darstellung in einem Webbrowser, als pdf- oder postscript-Datei
für den Druck des Dokuments und das für unterschiedliche
Druckformate. Eventuell sollen nicht alle Teile eines Dokuments
visualisiert werden. XML ist zunächst eine Sprache, die logisch
strukturierte Dokumente zu schreiben, erlaubt.<p/>
Dokumente bestehen hierbei aus den eigentlichen
Dokumenttext und zusätzlich aus Markierungen dieses Textes. Die Markierungen
sind in 
spitzen Klammern eingeschlossen. <p/><beispiel>
Der eigentliche Text des Dokuments sei:<code>The Beatles White Album</code>
Die einzelnen Bestandteile dieses Textes können markiert werden:<code>&lt;cd&gt;
  &lt;artist&gt;The Beatles&lt;/artist&gt;
  &lt;title&gt;White Album&lt;/title&gt;
&lt;/cd&gt;</code></beispiel>
Die XML-Sprache wird durch ein Industriekonsortium definiert, 
dem <exlink address = "http://www.w3c.org">W3C</exlink>. Dieses ist
ein Zusammenschluß vieler Firmen, die ein gemeinsames Interesse eines
allgemeinen Standards für eine Markierungssprache haben. Die
eigentlichen Standards des W3C heißen nicht Standard, sondern 
Empfehlung <em>(recommendation)</em>, weil es sich bei dem W3C nicht
um eine staatliche oder überstaatliche Standartisiertungsbehörde
handelt. Die aktuelle Empfehlung für XML liegt seit anfang des Jahres als
Empfehlung in der Version 1.1 vor <cite label = "xml1.1"/>.<p/>
XML enstand Ende der 90er Jahre und ist  
abgeleitet von einer umfangreicheren Dokumentenbeschreibungssprache:
SGML. Der SGML-Standard ist wesentlich komplizierter und krankt daran,
daß es extrem schwer ist, Software für die Verarbeitung von
SGML-Dokumenten zu entwickeln. Daher fasste SGML nur Fuß in Bereichen,
wo gut strukturierte, leicht wartbare Dokumente von fundamentaler
Bedeutung waren, so daß die Investition in teure Werkzeuge zur
Erzeugung und Pflege von SGML-Dokumenten sich rentierte. Dies waren
z.B.~Dokumentationen im Luftfahrtbereich.<footnote>Man sagt, ein Pilot
brauche den Copiloten, damit dieser die Handbücher für das 
Flugzeug trägt.</footnote><p/>
Die Idee bei der Entwicklung von XML war: eine Sprache mit den
Vorteilen von SGML zu Entwickeln, die klein, übersichtlich und leicht
zu handhaben ist.<section titel = "XML-Format">
Die grundlegendste Empfehlung des W3C legt fest, wann ein Dokument ein
gültiges XML-Dokument ist, die Syntax eines XML-Dokuments. Die
nächsten Abschnitte stellen die wichtigsten Bestandteile eines
XML-Dokuments vor.<p/>
Jedes Dokument beginnt mit einer Anfangszeile, in dem das Dokument
angibt, daß es ein XML-Dokument nach einer bestimmten Version der XML
Empfehlung ist:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;</code>

Dieses ist die erste Zeile eines XML-Dokuments. Vor dieser Zeile darf
kein Leerzeichen stehen. Die derzeitig aktuellste und einzige Version
der XML-Empfehlung ist die Version 1.0. Ein Entwurf für die Version
1.1~liegt vor. Nach Aussage eines Mitglieds
des W3C ist es sehr unwahrscheinlich, daß es jemals eine Version 2.0
von XML geben wird. Zuviele weitere Techniken und Empfehlungen
basieren auf XML, so daß die Definition von dem, was ein XML-Dokument
ist kaum mehr in größeren Rahmen zu ändern ist.<subsection titel = "Elemente">
Der Hauptbestandteil eines XML-Dokuments sind die Elemente. Dieses
sind mit der Spitzenklammernotation um Teile des Dokuments gemachte
Markierungen. Ein Element hat einen <em>Tagnamen</em>, der ein
beliebiges Wort ohne Leerzeichen sein kann. Für einen
Tagnamen <em>name</em>
 beginnt ein Element mit <ttt>&lt;name&gt;</ttt> und endet 
mit <ttt>&lt;/name&gt;</ttt>. Zwischen dieser Start- und
Endemarkierung eines Elements kann Text oder auch weitere Elemente
stehen.<p/>
Es wird für XML-Dokument verlangt, daß es genau ein einziges oberstes
Element hat. <beispiel>Somit ist ein einfaches XML-Dokument ein solches
Dokument, in dem der gesammte Text mit einem einzigen Element markiert
ist:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;myText&gt;Dieses ist der Text des Dokuments. Er ist
mit genau einem Element markiert.
&lt;/myText&gt;</code></beispiel>

Im einführenden Beispiel haben wir schon ein XML-Dokument gesehen, das
mehrere Elemente hat. Dort umschließt das 
Element <tt>&lt;cd&gt;</tt> zwei weitere Elemente, die 
Elemente <tt>&lt;artist&gt;</tt> und <tt>&lt;title&gt;</tt>. Die
Teile, die ein Element umschließt, werden der Inhalt des Elements
genannt.<p/>
Ein Element kann auch keinen, sprich den leeren Inhalt haben. Dann
folgt der öffnenden Markierung direkt die schließende Markierung.<beispiel>Folgendes Dokument enthält ein Element ohne Inhalt:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;skript&gt;
  &lt;page&gt;erste Seite&lt;/page&gt;
  &lt;page&gt;&lt;/page&gt;
  &lt;page&gt;dritte Seite&lt;/page&gt;
&lt;/skript&gt;</code></beispiel><subsubsection titel = "Leere Elemente">
Für ein Element mit Tagnamen <em>name</em>, das keinen Inhalt hat,
gibt es die abkürzenden Schreibweise: <tt>&lt;name/&gt;</tt><beispiel>Das vorherige Dokument läßt sich somit auch wie folgt schreiben:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;skript&gt;
  &lt;page&gt;erste Seite&lt;/page&gt;
  &lt;page/&gt;
  &lt;page&gt;dritte Seite&lt;/page&gt;
&lt;/skript&gt;</code></beispiel></subsubsection><subsubsection titel = "Gemischter Inhalt">
Die bisherigen Beispiele haben nur Elemente gehabt, deren Inhalt
entweder Elemente oder Text waren, aber nicht beides. Es ist aber auch
möglich Elemente mit Text und Elementen als Inhalt zu schreiben. Man
spricht dann vom gemischten Inhalt <em>(mixed content)</em>.<beispiel>Ein Dokument, in dem das oberste Element einen gemischten
Inhalt hat:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;myText&gt;Der &lt;landsmann&gt;Italiener&lt;/landsmann&gt;
&lt;eigename&gt;Ferdinand Carulli&lt;/eigename&gt; war  als Gitarrist 
ebenso wie der &lt;landsmann&gt;Spanier&lt;/landsmann&gt; 
&lt;eigename&gt;Fernando Sor&lt;/eigename&gt; in &lt;ort&gt;Paris&lt;/ort&gt;
ansäßig.&lt;/myText&gt;</code></beispiel></subsubsection><subsubsection titel = "XML-Dokumente als Bäume">
Die wohl wichtigste Beschränkung für XML-Dokumente ist, daß sie eine
hierarchische Struktur darstellen müssen. Zwei Elemente dürfen sich
nicht überlappen. Ein Element darf erst wieder geschlossen werden,
wenn alle nach ihm geöffneten Elemente wieder geschlossen wurden.<beispiel>Das folgende ist kein gültiges XML-Dokument. Das 
Element <tt>&lt;bf&gt;</tt> wird geschlossen bevor das später geöffnete
Element <tt>&lt;em&gt;</tt> geschlossen worde.<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;illegalDocument&gt;
  &lt;bf&gt;fette Schrift &lt;em&gt;kursiv und fett&lt;/bf&gt; 
  nur noch kursiv&lt;/em&gt;.
&lt;/illegalDocument&gt;</code>
Das Dokument wäre wie folgt als gültiges XML zu schreiben:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;validDocument&gt;
  &lt;bf&gt;fette Schrift &lt;em&gt;kursiv und fett&lt;/em&gt;&lt;/bf&gt; 
  &lt;em&gt;nur noch kursiv&lt;/em&gt;.
&lt;/validDocument&gt;</code>
Dieses Dokument hat eine hierarchische Struktur.</beispiel>

Die hierarchische Struktur von XML-Dokumenten läßt sich sehr schön
veranschaulichen, wenn man die Darstellung von XML-Dokumenten in
Microsofts Internet Explorer betrachtet.  </subsubsection></subsection><subsection titel = "Attribute">
Die Elemente eines XML-Dokuments können als zusätzliche Information
auch noch Attribute haben. Attribute haben einen Namen und einen
Wert. Syntaktisch ist ein Attribut dargestellt durch den Attributnamen
gefolgt von einem Gleichheitszeichen gefolgt von dem in
Anführungszeichen eingeschlossenen Attributwert. Attribute stehen im
Starttag eines Elements. <p/>
Attribute werden nicht als Bestandteils des
eigentlichen Textes eines Dokuments betrachtet.<beispiel>Dokument mit einem Attribut für ein Element. <code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;text&gt;Mehr Information zu XML findet man auf den Seiten
des &lt;link address=&quot;www.w3c.org&quot;&gt;W3C&lt;/link&gt;.&lt;/text&gt;</code></beispiel></subsection><subsection titel = "Kommentare">
XML stellt auch eine Möglichkeit zur Verfügung, bestimmte Texte als
Kommentar einem Dokument zuzufügen. Diese Kommentare werden 
mit <tt>&lt;!--</tt> begonnen und mit <tt>--&gt;</tt> beendet.
Kommentartexte sind nicht Bestandteil des eigentlichen Dokumenttextes.<beispiel>Im folgenden Dokument ist ein Kommentar eingefügt:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;drehbuch filmtitel=&quot;Ben Hur&quot;&gt;
&lt;akt&gt;
  &lt;szene&gt;Ben Hur am Vorabend des Wagenrennens.
    &lt;!--Diese Szene muß noch ausgearbeitet werden.--&gt;
  &lt;/szene&gt;
&lt;/akt&gt;
&lt;/drehbuch&gt;</code></beispiel></subsection><subsection titel = "Character Entities">Sobald in einem XML-Dokument
eine der spitze Klammern <tt>&lt;</tt> oder <tt>&gt;</tt> auftaucht, wird dieses als
Teil eines Elementtags interpretiert. Sollen diese Zeichen  hingegen
als Text und nicht als Teil der Markierung benutzt werden, sind also
Bestandteil des Dokumenttextes, so muß man einen Fluchtmechanismus für
diese Zeichen benutzen. Diese Fluchtmechanismen nennt 
man <em>character entities</em>. Eine Character Entity beginnt in XML
mit dem Zeichen <tt>&amp;</tt> und endet mit einem Semikolon<tt>;</tt>. Dazwischen steht der Name des Buchstabens. XML kennt die
folgenden Character Entities:<quote>
          <table layout = "lll">
            <zeile>
              <zelle>Entity</zelle>
              <zelle>Zeichen</zelle>
              <zelle>Beschreibung</zelle>
            </zeile>
            <hline/>
            <zeile>
              <zelle>
                <tt>&amp;lt;</tt>
              </zelle>
              <zelle>
                <tt>&lt;</tt>
              </zelle>
              <zelle> (less than)</zelle>
            </zeile>
            <zeile>
              <zelle>
                <tt>&amp;gt;</tt>
              </zelle>
              <zelle>
                <tt>&gt;</tt>
              </zelle>
              <zelle> (greater than)</zelle>
            </zeile>
            <zeile>
              <zelle>
                <tt>&amp;amp;</tt>
              </zelle>
              <zelle>
                <tt>&amp;</tt>
              </zelle>
              <zelle> (ampersant)</zelle>
            </zeile>
            <zeile>
              <zelle>
                <tt>&amp;quot;</tt>
              </zelle>
              <zelle>
                <tt>&quot;</tt>
              </zelle>
              <zelle> (quotation mark)</zelle>
            </zeile>
            <zeile>
              <zelle>
                <tt>&amp;apos;</tt>
              </zelle>
              <zelle>
                <tt>&#39;</tt>
              </zelle>
              <zelle>(apostroph)</zelle>
            </zeile>
          </table>
        </quote>
Somit lassen sich in XML auch Dokumente schreiben, die diese Zeichen
als Text beinhalten.<beispiel>Folgendes Dokument benutzt Character Entities um
mathematische Formeln zu schreiben:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;gleichungen&gt;
  &lt;gleichung&gt;x+1&amp;gt;x&lt;/gleichung&gt;
  &lt;gleichung&gt;x*x&amp;lt;x*x*x für x&amp;gt;1&lt;/gleichung&gt;
&lt;/gleichungen&gt;</code></beispiel></subsection><subsection titel = "CDATA-Sections">
Manchmal gibt es große Textabschnitte in denen Zeichen vorkommen, die
eigentlich durch character entities zu umschreiben wären, weil sie in
XML eine reservierte Bedeutung haben. XML bietet die Möglichkeit
solche kompletten Abschnitte als eine sogenannte <em>CData
Section</em> zu schreiben. Eine <em>CData section</em> beginnt mit der
Zeichenfolge <ttt>&lt;![CDATA[</ttt> und endet mit der 
Zeichenfolge: <ttt>]]&gt;</ttt>. Dazwischen können beliebige
Zeichenstehen, die eins zu eins als Text des Dokumentes interpretiert werden.<beispiel>Die im vorherigen Beispiel mit Character Entities
beschriebenen Formeln lassen sich innerhalb einer CDATA-Section wie
folgt schreiben.<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;formeln&gt;&lt;![CDATA[
  x+1&gt;x 
  x*x&lt;x*x*x für x &gt; 1
]]&gt;&lt;/formeln&gt;</code></beispiel></subsection><subsection titel = "Processing Instructions">
In einem XML-Dokument können Anweisung stehen, die angeben, was mit
einem Dokument von einem externen Programm zu tun ist. Solche
Anweisungen können z.B.~angeben, mit welchen Mitteln das Dokument
visualisiert werden soll. Wir werden hierzu im nächsten Kapitel ein
Beispiel sehen. Syntaktisch beginnt eine <em>processing 
instruction</em> mit <tt>&lt;?</tt> und endet mit <tt>?&gt;</tt>. 
Dazwischen stehen wie in der Attributschreibweise
Werte für den Typ der Anweisung und eine Referenz auf eine externe
Quelle. <beispiel>Ausschnitt aus dem XML-Dokument diesen Skripts, in dem auf
ein Stylesheet verwiesen wird, daß das Skript in eine HTML-Darstellung
umwandelt:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;?xml-stylesheet 
   type=&quot;text/xsl&quot; 
   href=&quot;../transformskript.xsl&quot;?&gt;

&lt;skript&gt;
&lt;titelseite&gt;
&lt;titel&gt;Grundlagen der Datenverarbeitung&lt;white/&gt;II&lt;/titel&gt;
&lt;semester&gt;WS 02/03&lt;/semester&gt;
&lt;/titelseite&gt;
&lt;/skript&gt;</code></beispiel></subsection><subsection titel = "Namensräume">
Die <em>Tagnamen</em> sind zunächst einmal Schall und Rauch. Erst eine
externes Programm wird diesen Namen eine gewisse Bedeutung zukommen
lassen, indem es auf die <em>Tagnamen</em> in einer bestimmten Weise
reagiert. <p/>
Da jeder Autor eines XML-Dokuments zunächst vollkommen frei in der
Wahl seiner <em>Tagnamen ist</em>, wird es vorkommen, daß zwei Autoren
denselben <em>Tagnamen</em> für die Markierung gewählt haben, aber
semantisch mit diesem Element etwas anderes ausdrücken
wollen. Spätestens dann, wenn verschiedene Dokumente verknüpft werden,
wäre es wichtig, daß <em>Tagnamen</em> einmalig mit einer Eindeutigen
Bedeutung benutzt wurden. Hierzu gibt es in XML das Konzept der
Namensräume. <p/><em>Tagnamen</em> können aus zwei Teilen bestehen, die durch einen
Doppelpunkt getrennt werden:<itemize>
          <item>dem Präfix, der vor dem Doppelpunkt steht.</item>
          <item>dem lokalen Namen, der nach dem Doppelpunkt folgt.</item>
        </itemize>
Hiermit allein ist das eigentliche Problem 
gleicher <em>Tagnamen</em> noch nicht gelöst, weil ja zwei Autoren den
gleichen Präfix und gleichen lokalen Namen für ihre Elemente gewählt
haben können. Der Präfix wird aber an einem weiteren Text gebunden,
der eindeutig ist. Dieses ist der eigentliche Namensraum. Damit
garantiert ist, daß dieser Namensraum tatsächlich eindeutig ist, wählt
man als Autor seine Webadresse, denn diese ist weltweit eindeutig. <p/>
Um mit Namensräume zu arbeiten ist also zunächst ein Präfix an eine
Webadresse zu binden; dies geschieht durch ein Attribut der Art:<br/><tt>xmlns:myPrefix=&quot;http://www.myAdress.org/myNamespace&quot;</tt>.<beispiel>
Ein Beispiel für ein XML-Dokument, daß den Präfix <tt>sep</tt> an
einem bestimmten Namensraum gebunden hat:<code commandchars = "_&#39;^">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;sep:skript 
   xmlns:sep=&quot;http://www.tfh-berlin.de/~panitz/dv2&quot;&gt;
  &lt;sep:titel&gt;Grundlagen der DV 2&lt;/sep:titel&gt;
  &lt;sep:autor&gt;Sven Eric Panitz&lt;/sep:autor&gt;
&lt;/sep:skript&gt;
</code></beispiel>
Die Webadresse eines Namensraumes hat keine eigentliche Bedeutung im
Sinne des Internets. Das Dokument geht nicht zu dieser Adresse und
holt sich etwa Informationen von dort. Es ist lediglich dazu da, einen
eindeutigen Namen zu haben. Streng genommen brauch es diese Adresse
noch nicht einmal wirklich zu geben. </subsection></section><section titel = "Codierungen">
XML ist ein Dokumentenformat, das nicht auf eine Kultur mit einer
bestimmten Schrift beschränkt ist, sondern in der Lage ist, alle im
Unicode erfassten Zeichen darzustellen, seien es Zeichen der lateinischen, kyrillischen,
arabischen, chinesischen oder sonst einer Schrift bis hin zur
keltischen Keilschrift. Jedes Zeichen eines XML-Dokuments kann
potentiell eines dieser mehrerern zigtausend Zeichen einer der vielen
Schriften sein. In der Regel benutzt ein XML-Dokument insbesondere im
amerikanischen und europäischen Bereich nur wenige kaum 100
unterschiedliche Zeichen. Auch ein arabisches Dokument wird mit
weniger als 100 verschiedenen Zeichen auskommen.<p/>
Wenn ein Dokument im Computer auf der Festplatte gespeichert wird, so
werden auf der Festplatte keine Zeichen einer Schrift, sondern Zahlen
abgespeichert. Diese Zahlen sind traditionell Zahlen die 8 Bit im
Speicher belegen, ein sogenannter Byte (auch Oktett). Ein Byte ist in
der Lage 256 unterschiedliche Zahlen darzustellen. Damit würde ein
Byte ausreichen, alle Buchstaben eines normalen westlichen Dokuments
in lateinischer Schrift (oder eines arabischen Dokuments
darzustellen). Für ein Chinesisches Dokument reicht es nicht aus, die
Zeichen durch ein Byte allein auszudrücken, denn es gibt mehr als
10000 verschiedene chinesische Zeichen. Es ist notwendig, zwei Byte im
Speicher zu benutzen, um die vielen chinesischen Zeichen als Zahlen
darzustellen. <p/>
Die <em>Codierung</em> eines Dokuments gibt nun an, wie die Zahlen, die
der Computer auf der Festplatte gespeichert hat, als Zeichen
interpretiert werden sollen. Eine Codierung für arabische Texte wird den
Zahlen von 0 bis 255 bestimmte arabische Buchstaben zuordnen, eine
Codierung für deutsche Dokumente wird den Zahlen 0 bis 255 lateinische
Buchstaben inklusive deutscher Umlaute und dem <tt>ß</tt> zuordnen.
Für ein chinesisches Dokument wird eine <em>Codierung</em> benötigt, die
den 65536 mit 2 Byte darstellbaren Zahlen jeweils chinesische Zeichen
zuordnet. <p/>
Man sieht, daß es <en>Codierungen</en> geben muß, die für ein Zeichen ein
Byte im Speicher belegen, und solche, die zwei Byte im Speicher
belegen. Es gibt darüberhinaus auch eine Reihe Mischformen, manche
Zeichen werden durch ein Byte andere durch 2 oder sogar durch 3 Byte
dargestellt. <p/>
Im Kopf eines XML-Dokuments kann angegeben werden, in welcher Codierung
das Dokument abgespeichert ist.<beispiel>Dieses Skript ist in einer Codierung gespeichert, die für
westeuropäische Dokumente gut geeignet ist, da es für die
verschiedenen Sonderzeichen der westeuropäischen Schriften einen
Zahlenwert im 8-Bit-Bereich zugeordnet hat. Die Codierung mit dem 
Namen: <tt>iso-8859-1</tt>. Diese wird im Kopf des Dokuments
angegeben:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;skript&gt;&lt;kapitel&gt;blablabla&lt;/kapitel&gt;&lt;/skript&gt;</code></beispiel>
Wird keine Codierung im Kopf eines Dokuments angegeben, so wird als
Standardcodierung die sogenannte <tt>utf-8</tt> Codierung benutzt. In
ihr belegen lateinische Zeichen einen Byte und Zeichen anderer
Schriften (oder auch das Euro Symbol) zwei bis drei Bytes.<p/>
Eine Codierung, in der alle Zeichen mindestens mit zwei Bytes
dargestellt werden ist: <tt>utf-16</tt>, die Standardabbildung von
Zeichen, wie sie im <em>Unicode</em> definiert ist.</section><section titel = "Dokumente als Bäume in Java">
Wie wir festgestellt haben, sind XML-Dokumente mit ihrer hierarchischen
Struktur Bäume. In den Vorgängerkapitel haben wir uns schon auf
unterschiedliche Weise mit Bäumen beschäftigt. Von den dabei gemachten
Erfahrungen können wir jetzt profitieren. <subsection titel = "APIs für XML">
Wir wollen jetzt einen Blick auf die gängigen Schnittstellen für die
XML-Programmierung werfen.<subsubsection titel = "DOM">
Die allgemeine Schnittstellenbeschreibung für XML als Baumstruktur ist 
das <em>distributed object  
modell</em> kurz <em>dom</em><cite label = "dom3"/>, für das das W3C eine
Empfehlung herausgibt. Die Ursprünge von  <em>dom</em> liegen nicht in der
XML-Programmierung sondern in der Verarbeitung von HTML-Strukturen im
Webbrowser über Javascript. Mit dem Auftreten von XML entwickelte sich der
Wunsch, eine allgemeine, platform- und sprachunabhänge
Schnittstellenbeschreibung für XML- und HTML-Baumstrukturen zu bekommen, die
in verschiedenen Sprachen umgesetzt werden kann.<p/>

Da es sich um ein implementierungsunabhängiges API handelt, finden 
wir <em>dom</em> in der Javabibliothek nur als Schnittstellen.<paragraph titel = "Wichtige Schnittstellen">
Die zentrale Schnittstelle in <em>dom</em> ist <tt>Node</tt>. Sie hat als
Unterschnittstellen alle Knotentypen, die es in XML gibt. Folgende Graphik 
gibt über diese Knotentypen einen Überblick.<code>interface org.w3c.dom.Node
 | 
 |--interface org.w3c.dom.Attr
 |--interface org.w3c.dom.CharacterData
 |   | 
 |   |--interface org.w3c.dom.Comment
 |   |--interface org.w3c.dom.Text
 |       |
 |       |--interface org.w3c.dom.CDATASection
 | 
 |--interface org.w3c.dom.Document
 |--interface org.w3c.dom.DocumentFragment
 |--interface org.w3c.dom.DocumentType
 |--interface org.w3c.dom.Element
 |--interface org.w3c.dom.Entity
 |--interface org.w3c.dom.EntityReference
 |--interface org.w3c.dom.Notation
 |--interface org.w3c.dom.ProcessingInstruction</code>

Eine der entscheidenen Methoden der 
Schnittstelle <tt>Node</tt> selektiert die Liste der Kinder eines Knotens:<br/><tt>public NodeList getChildNodes()</tt><p/>

Knoten, die keine Kinder haben können (Textknoten, Attribute etc.) geben bei
dieser Methode die leere Liste zurück. Attribute zählen auch wie in unserer
Modellierung nicht zu den Kindern eines Knotens. Um an die Attribute zu
gelangen, gibt es eine eigene Methode:<br/><tt>NamedNodeMap getAttributes()</tt><p/>


Wie man sieht, benutzt Javas <em>dom</em> Umsetzung keine von Javas
Listenklassen zur Umsetzung einer Knotenliste, sondern nur genau die 
in <em>dom</em> spezifizierte Schnittstelle <tt>NodeList</tt>. 
Eine <tt>NodeList</tt> hat genau zwei Methoden:<code>int getLength()
Node item(int index)</code>

Dieses ist insofern schade, da somit nicht die 
neue <em>for</em>-Schleife aus Java 1.5 für die Knotenliste 
des <em>dom</em> benutzt werden kann. </paragraph><paragraph titel = "Einen Parser für XML">
Wir benötigen einen Parser, der uns die Baumstruktur eines XML-Dokuments
erzeugt. In der Javabibliothek ist ein solcher Parser integriert, allerdings
nur über seine Schnittstellenbeschreibung. 
Im Paket <tt>javax.xml.parsers</tt> gibt es nur Schnittstellen. Um einen
konkreten Parser zu erlangen, bedient man sich einer Fabrikmethode: In der
Schnittstelle <tt>DocumentBuilderFactory</tt> gibt es eine statische 
Methode <tt>newInstance</tt> und über 
das  <tt>DocumentBuilderFactory</tt>-Objekt, läßt sich mit der 
Methode <tt>newDocumentBuilder</tt> ein Parser erzeugen.<example>
Wir können so eine statischen Methode zum Parsen eines XML-Dokuments
schreiben: <code class = "ParseXML"
                    package = "name/panitz/domtest"
                    lang = "java">package name.panitz.domtest;

import org.w3c.dom.Document;
import javax.xml.parsers.*;
import java.io.File;

public class ParseXML {
  public static Document parseXml(String xmlFileName){
    try{
     return
      <redv>DocumentBuilderFactory</redv>
       .<redv>newInstance</redv>()
       .<redv>newDocumentBuilder</redv>()
       .parse(new File(xmlFileName));
    }catch(Exception _){return null;}
  }

  public static void main(String [] args){
   System.out.println(parseXml(args[0]));
  }
}</code>
Wir können jetzt z.B. den Quelltext dieses Skripts parsen.<scode>sep@linux:~/fh/prog4/examples&gt; java -classpath classes/ name.panitz.domtest.ParseXML ../skript.xml
[#document: null]
</scode>
Wie man sieht ist die Methode <tt>toString</tt> in der implementierenden
   Klasse der Schnittstelle <tt>Document</tt>, die unser Parser benutzt nicht
   sehr aufschlußreich.</example></paragraph><paragraph titel = "Beispielalgorithmen auf DOM">

Wir können  versuchen für das <em>dom</em>-Objekten ähnliche Methoden zu
schreiben, wie für die Bäume im vorangegangenen Kapitel. <p/>

Zunächst zählen wir wieder alle Knoten im Dokument:<code class = "CountNodes"
                  package = "name/panitz/domtest"
                  lang = "java">package name.panitz.domtest;

import org.w3c.dom.Node;

public class CountNodes{
  static int count(Node node){
    int result = 1;
    for (Node n:new NoteListIterator(node.getChildNodes()))
      result=result+count(n);
    return result; 
  }
  public static void main(String [] args){
    System.out.println(count(ParseXML.parseXml(args[0])));
  }
}</code>

Hierbei haben wir in der <b>for</b>-Schleife für Objekte die die 
Schnittstelle <tt>NodeList</tt> implementieren einen Wrapper benutzt, der
diese Objekte zu einem Iteratorobjekt verpackt. <code class = "NoteListIterator"
                  package = "name/panitz/domtest"
                  lang = "java">package name.panitz.domtest;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.util.Iterator;

public class NoteListIterator implements Iterator&lt;Node&gt;
                                       , Iterable&lt;Node&gt;{
  NodeList nodes;
  int current=-1;
  public NoteListIterator(NodeList n){nodes=n;}

  public Node next(){
    current=current+1; return nodes.item(current);}

  public boolean hasNext(){return current+1&lt;nodes.getLength();}

  public void remove(){
    throw new UnsupportedOperationException();
  }

  public Iterator&lt;Node&gt; iterator(){return this;}
}</code>
Wir können uns zum Beispiel die Anzahl der Knoten in diesem Skript ausgeben
lassen:<scode>sep@linux:~/fh/prog4&gt; java -classpath classes/ name.panitz.domtest.CountNodes skript.xml
1316</scode>

Als einen weiteren Algorithmus können wir wieder die maximale Pfadlänge
berechnen lassen:<code class = "DomDepth"
                  package = "name/panitz/domtest"
                  lang = "java">package name.panitz.domtest;

import org.w3c.dom.Node;

public class DomDepth{
  static int depth(Node node){
    int result = 0;
    for (Node n:new NoteListIterator(node.getChildNodes())){
      final int currentDepth = depth(n);
      if (result&lt;currentDepth) result=currentDepth;
    }
    return result+1; 
  }
  public static void main(String [] args){
    System.out.println(depth(ParseXML.parseXml(args[0])));
  }
}</code>
Auch dieses läßt sich wunderbar mit dem Quelltext dieses Skriptes testen.<scode>sep@linux:~/fh/prog4&gt; java -classpath classes/ name.panitz.domtest.DomDepth skript.xml
13</scode></paragraph><paragraph titel = "Manuelles Manipulieren von Dom">
Das DOM Api ermöglicht nicht nur in einem XML-Baum beliebig zu navigieren,
sondern auch diesen Baum zu manipulieren. Es lassen sich neue Knoten einhängen
und bestehende Knoten löschen. Hierzu stehen in der 
Schnittstelle <tt>Node</tt> entsprechende Methoden zur Verfügung:<code>Node appendChild(Node newChild)      throws DOMException;
Node insertBefore(Node newChild,Node refChild)
                                      throws DOMException;
Node replaceChild(Node newChild,Node oldChild)
                                      throws DOMException;
Node removeChild (Node oldChild)      throws DOMException;</code>

Speziellere Methoden zum Manipulieren der verschieden Baumknoten finden sich
in den Unterschnittstellen von <tt>Node</tt>.<p/>

Zum Erzeugen eines neuen Knotens ist es notwendig den Dokumentknoten des zu
manipulierenden Knotens zu kennen. Der Dokumentknoten eines Knotens 
läßt sich über die
Methode <tt>Document getOwnerDocument()</tt> erfragen. Hier gibt es dann
Methoden zur Erzeugung neuer Knoten:<code>Attr createAttribute(String name); 
Attr createAttributeNS(String namespaceURI, String qualifiedName); 
CDATASection createCDATASection(String data);
Comment createComment(String data);
DocumentFragment createDocumentFragment(); 
Element createElement(String tagName);
Element createElementNS
                 (String namespaceURI, String qualifiedName); 
EntityReference createEntityReference(String name); 
ProcessingInstruction createProcessingInstruction
                                  (String target, String data); 
Text createTextNode(String data); </code></paragraph></subsubsection><subsubsection titel = "SAX">
Oft brauchen wir nie das komplette XML-Dokument als Baum im Speicher. Eine
Großzahl der Anwendungen auf XML-Dokumenten geht einmal das Dokument durch, um
irgendwelche Informationen darin zu finden, oder ein Ergebnis zu
erzeugen. Hierzu reicht es aus, immer nur einen kleinen Teil des Dokuments zu
betrachten. Und tatsächlich hätte diese Vorgehensweise, bai allen bisher
geschriebenen Programmen gereicht. Wir sind nie im Baum hin und her
gegangen. Wir sind nie von einem Knoten zu seinem Elternknoten oder seinen vor
ihm liegenden Geschwistern gegangen.<p/>

Ausgehend von dieser Beobachtuung hat eine Gruppe von Programmierern ein
API zur Bearbeitungen von XML-Dokumenten vorgeschlagen, das nie das gesammte
Dokument im Speicher zu halten braucht. Dieses API heißt <em>SAX</em>, 
für <em>simple api for xml processing</em>. <em>SAX</em> ist keine Empfehlung
des W3C. Es ist außerhalb des W3C entstanden.<p/>

Die Idee von <em>SAX</em> ist ungefähr die, daß uns jemand das Dokument
vorliest, einmal von Anfang bis Ende. Wir können dann auf das gehörte
reagieren. Hierzu ist für einen Parse mit einem SAX-Parser stets mit
anzugeben, wie auf das Vorgelesene reagiert werden soll. Dieses ist ein Objekt
der Klasse <tt>DefaultHandler</tt>. In einem solchen <em>handler</em> sind
Methoden auszuprogrammieren, in denen spezifiziert ist, was gemacht werden
soll, wenn ein Elementstarttag, Elementendtag, Textknoten etc. vorgelsen wird.
Man spricht bei einem SAX-Parser von einem ereignisbasierten Parser. Wir
reagieren auf bestimmte Ereignisse des Parses, nämlich dem Starten/Enden von
Elementen und so weiter. <paragraph titel = "Instanziieren eines SAX-Parsers">
Auch ein SAX-Parser liegt in Java nur als Schnittstelle vor und kann nur über
eine statische Fabrikmethode instanziiert werden.<code class = "SaxParse"
                  package = "name/panitz/saxtest"
                  lang = "java">package name.panitz.saxtest;
import org.xml.sax.helpers.DefaultHandler;
import javax.xml.parsers.*;
import org.xml.sax.*;
import java.io.File;

public class SaxParse{
  public static void parse(File file,DefaultHandler handler)
                               throws Exception{
    SAXParserFactory.<redv>newInstance</redv>()
                    .<redv>newSAXParser</redv>()
                    .parse(file,handler); 
  }  
}</code></paragraph><paragraph titel = "Zählen von Knoten">
Als erstes Beispiel wollen wir unser altbekanntes Zählen der Knoten
  programmieren.  Hierzu ist ein eigener <tt>DefaultHandler</tt> zu schreiben,
der, sobald beim Vorlesen ihm der Beginn eines Elements gemeldet wird, darauf
  reagiert, indem er seinen Zähler um eins weiterzählt. 
Wir überschreiben demnach
  genau eine Methode aus dem <tt>DefaultHandler</tt>, nämlich die 
Methode <tt>startElement</tt>: <code class = "SaxCountNodes"
                  package = "name/panitz/saxtest"
                  lang = "java">package name.panitz.saxtest;
import org.xml.sax.helpers.DefaultHandler;
import java.util.*;
import org.xml.sax.*;

public class SaxCountNodes extends DefaultHandler{
  public int result = 0;
  public void startElement
   (String uri, String localName
   , String qName, Attributes attributes)
                          throws SAXException {
    result=result+1;
  }

  public static void main(String [] args) throws Exception{
    SaxCountNodes counter = new SaxCountNodes();
    SaxParse.parse(new java.io.File(args[0]),counter);
    System.out.println(counter.result); 
  }
}</code></paragraph><paragraph titel = "Selektion von Code-Knoten">
In einem nächsten Beispiel für einen Handler, schreiben wir einen Handler, der
    bestimmte Knoten selektiert und in einer Ergebnisliste sammelt.<p/>

Wir wollen die <tt>code</tt> Knoten aus diesem Skript selektieren.<p/>
Hierzu können wir als
algebraischen Datentypen einfach eine Klasse vorsehen, die ein Codefragment
aus dem Skript darstellt. Dieses hat einen Programmnamen, ein Paketnamen und
schließlich den darin enthaltenen Code.<code class = "CodeFragment"
                  lang = "adt"
                  package = "name/panitz/saxtest">package name.panitz.saxtest;
data class CodeFragment {
  CodeFragment(String progName,String packageName,String code);
}</code>

Der entsprechende Handler sammelt die benötigte Information auf.<code class = "SelectNodes"
                  package = "name/panitz/saxtest"
                  lang = "java">package name.panitz.saxtest;
import org.xml.sax.helpers.DefaultHandler;
import java.util.*;
import org.xml.sax.*;

public class SelectNodes extends DefaultHandler{
  final List&lt;String&gt; names;
  final List&lt;CodeFragment&gt; result = new ArrayList&lt;CodeFragment&gt;();

  public SelectNodes(List&lt;String&gt; ls){names=ls;}
  public SelectNodes(String ls){
    names=new ArrayList&lt;String&gt;(); names.add(ls);}

  private StringBuffer currentCode = new StringBuffer();
  private String currentProgName = &quot;&quot;;
  private String currentPackageName = &quot;&quot;;

  public void startElement
   (String uri, String localName, String qName, Attributes attributes)
                throws SAXException {
     if (names.contains(qName)){
       currentCode = new StringBuffer();
       currentProgName = attributes.getValue(&quot;class&quot;);
       currentPackageName = attributes.getValue(&quot;package&quot;);
     }    
  }

  public void endElement
    (String uri, String localName, String qName)
                throws SAXException {
     if (names.contains(qName)){
       result.add(
         new CodeFragment
            (currentProgName
            ,currentPackageName
            ,currentCode.toString()));
     }    
  }

  public void characters(char[] ch,int start,int length)
                throws SAXException {
    currentCode.append(ch,start,length);
  }
}</code>

Den obigen Handler können wir jetzt z.B. benutzen, um aus dem Quelltext dieses
Skriptes bestimmte Beispielklassen zu extrahieren und in eine Javadatei zu
speichern. <code class = "GetCode"
                  package = "name/panitz/saxtest"
                  lang = "java">package name.panitz.saxtest;

import javax.xml.parsers.*;
import java.io.*;

public class GetCode {
  public static void main(String [] args) throws Exception{
    final  SelectNodes selectCodeHandler = new SelectNodes(&quot;code&quot;); 

    SaxParse.parse(new File(args[0]),selectCodeHandler); 
    final Writer out = new FileWriter(args[1]+&quot;.java&quot;); 

    for (CodeFragment cf:selectCodeHandler.result){
      if (args[1].equals(cf.getProgName()))
        out.write(cf.getCode());
    }
    out.flush();
    out.close();
  }
}</code></paragraph></subsubsection>
Wie man insgesamt sehen kann, ist das Vorgehen zum Schreiben 
eines <em>handlers</em> in SAX ähnlich zum Schreiben eines Besuchers unseres
    algebraischen Typens für XML-Dokumente.</subsection></section><section titel = "Transformationen und Queries">
Dieses Kapitel beschäftigt sich mit Sprachen, die darauf zugeschnitten sind,
XML-Dokumente zu verarbeiten. <subsection titel = "XPath: Pfade in Dokumenten">

Wir haben XML-Dokumente als Bäume betrachtet. Eine der fundamentalen Konzepten
in einem Baum, sind die Pfade innerhalb eines Baumes. So kann zum Beispiel
jeder Knoten eines Baumes eindeutig mit einem Pfad beschrieben werden. Zum
Beschreiben von Pfaden innerhalb eines XML existiert eine Sprache, die als
Empfehlung des W3C vorliegt, XPath<cite label = "xpath1.0"/>. Eine sehr schöne
formale Beschreibung einer denotationalen Semantik für XPath findet sich 
in <cite label = "xpathsemantics"/>.<p/>


XPath lehnt sich
syntaktisch an eine Beschreibungssprache für Pfade in Bäumen an, die sehr
verbreitet ist, nämlich Pfadbeschreibungen im Dateibaum. Um eine Datei in
einem Dateisystem zu adressieren geben wir einen Pfad von der Wurzel des
Dateibaums bis zu dieser Datei an. Die Datei dieses Skriptes findet sich
z.B. in folgenden Pfad auf meinem Rechner:<br/><tt>/home/sep/fh/prog4/skript.xml</tt><p/>

Ein Schrägstrich bedeutet in dieser Syntax, es wird nach diesem Strich sich
auf die Kinder des vor dem Strich spezifizierten Knotens bezogen. Ist vor dem
Strich nichts spezifiziert, so beginnen wir mit der Wurzel des Baums. Nach
einem Schrägstrich kann man die gewünschten Kinderknoten selektieren. Bei der
Pfadangabe eines Dateibaums, spezifizieren wir die Knoten über  die Datei-
und Ordnernamen. <p/>

XPath greift diese Idee auf. Hier bezeichnen die Namen die Tagnamen der
Elemente. Im vorliegenden Dokument läßt sich so der folgende Pfad 
beschreiben:<br/><tt>/skript/kapitel/section/subsection/code</tt>.<p/>

Damit sind alle Elementknoten dieses Dokuments gemeint, deren 
Tagname <tt>code</tt>, die ein Elternknoten <tt>subsection</tt> haben, deren
Elternlnoten den Tagnamen <tt>section</tt> haben, deren 
Eltern <tt>kapitel</tt>, deren Eltern das 
Wurzelelement <tt>skript</tt> ist.<p/>

Wie man sieht, bezeichnen XPath-Ausdrücke in der Regel Mengen von
Dokumentknoten.<p/> 

XPath Pfade lassen sich in zwei Weisen benutzen:<itemize>
          <item>Zum Selektieren bestimmter Knoten in einem Dokument. Ausgehend von einem
Wurzelknoten werden anhand des Ausdrucks aus dem Baum bestimmte Knoten 
selektiert.</item>
          <item>Zum Prüfen, ob ein Knoten die in dem Pfad beschriebene Eigenschaft
hat. Ausgehend von einem Knoten wird anhand des Ausdrucks getestet, ob er
diese beschriebene Pfadeigenschaft hat.</item>
        </itemize>

Beide Arten, XPath-Ausdrücke zu  verwenden sind in der Praxis
üblich. Beispiele hierfür werden wir in den nächsten Abschnitten sehen.<p/>

Um XPath möglichst gut kennenzulernen, wird im folgenden ein kleiner Prozessor
implementiert, der für einen XPath-Ausdruck die Menge der von ihm
beschriebenen Knoten ausgehend von einem Knoten selektiert. <subsubsection titel = "Achsen">
Eines der wichtigsten Konzepten von XPath sind die sogenannten Achsen. Sie
beschreiben bestimmte Arten sich in einem Baum zu bewegen. 
XPath kennt 13 Achsen.
Die am häufigste
verwendete Achse ist, die Kinderachse. Sie beschreibt die Menge aller Kinder
eines Knotens. Entsprechend gibt es die Elternachse, die den Elternknoten
beschreibt. Eine sehr simple Achse beschreibt den Knoten selbst. Achsen für
Vorfahren und Nachkommen sind der transitive Abschluß der Eltern- 
bzw. Kinderachse. Zusätzlich gibt es noch Geschwisterachsen, eine für die
Geschwister, die vor dem aktuellen Knoten stehen
und einmal für die Geschwister, die nach dem aktuellen Knoten
stehen. Eigene Achsen stehen für Attribute und Namensraumdeklarationen zur
Verfügung.  
 <p/>

Mit den seit Java 1.5 zur Verfügung stehenden Aufzählungstypen, läßt sich in
Java einfach ein Typ der alle 13 Achsen beschreibt implementieren.<code class = "AxisType"
                lang = "java"
                package = "name/panitz/xml/xpath">package name.panitz.xml.xpath;
public enum AxisType 
  {self
  ,child
  ,descendant
  ,descendant_or_self
  ,parent
  ,ancestor
  ,ancestor_or_self
  ,following_sibling
  ,following
  ,preceding_sibling
  ,preceding
  ,namespace
  ,attribute
}</code>

Für jede dieser Achsen geben wir eine Implementierung auf DOM. Eine
Achsenimplementierung entspricht dabei einer Funktion, die für einen Knoten
eine Liste von Knoten zurückgibt.<paragraph titel = "Achsenhilfsklasse">
Wir schreiben eine Klasse mit statischen Methoden zur Berechnung der
Achsen. Da in DOM nicht die Listen aus <tt>java.util</tt> benutzt werden
sondern die Schnittstelle <tt>org.w3c.dom.Nodelist</tt>, schreiben wir zunächst
eine kleine Methode, die eine <tt>NodeList</tt> in 
eine <tt>java.util.List&lt;Node&gt;</tt> umwandelt.<code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath">package name.panitz.xml.xpath;
import name.panitz.crempel.util.FromTo;
import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;
import name.panitz.domtest.*;

public class Axes{
  public static List&lt;Node&gt; nodelistToList (NodeList nl){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (int i:new FromTo(0,nl.getLength()-1)){
      result.add(nl.item(i));
    }
    return result;
  }</code></paragraph><paragraph titel = "self">
Die einfachste Achse liefert genau den Knoten selbst. Die entsprechende
  Methode liefert die einelementige Liste des Eingabeknotens: <code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; self(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    result.add(n);
    return result;
  }</code></paragraph><paragraph titel = "child">
Die gebräuchlichste Achse beschreibt die Menge aller Kinderknoten. Wir lassen
uns die Kinder des DOM Knotens geben und konvertieren 
die <tt>NodeList</tt> zu einer Javaliste:<code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; child(Node n){
    return nodelistToList(n.getChildNodes());
  }</code></paragraph><paragraph titel = "descendant">
Die Nachkommen sind Kinder und deren Nachkommen. Für fügen jedes Kind zur
Ergebnisliste hinzu, sowie alle deren Nachkommen: <code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; descendant(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node child:child(n)){
      result.add(child);
      result.addAll(descendant(child));
    }
    return result;
  }</code></paragraph><paragraph titel = "descendant-or-self">
In der Nachkommenachse taucht der Knoten selbst nicht auf. Diese Achse fügt
den Knoten selbst zusätzlich ans Ergebnis an:<code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; descendant_or_self(Node n){
    List&lt;Node&gt; result = self(n);
    result.addAll(descendant(n));
    return result;
  }</code></paragraph><paragraph titel = "parent">
Die Kinderachse lief in den Baum Richtung Blätter eine Ebene nach unten, die
Elternachse läuft diese eine Ebene Richtung Wurzel nach oben:<code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; parent(Node n){
     List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
     result.add(n.getParentNode());
     return result;
  }</code></paragraph><paragraph titel = "ancestor">
Die Vorfahrenachse ist der transitive Abschluß über die Elternachse, sie
bezeichnet also die Eltern und deren Vorfahren:<code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; ancestor(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node parent:parent(n)){
      if (parent!=null){
        result.addAll(ancestor(parent));
        result.add(parent);
      }
    }
    return result;
  }</code></paragraph><paragraph titel = "ancestor-or-self">
Die Vorfahrenachse enthält nicht den Knoten selbst. Entsprechend wie auf der
Nachkommenachse gibt es auch hier eine Version, die den Knoten selbst enthält: <code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; ancestor_or_self(Node n){
    List&lt;Node&gt; result = ancestor(n);
    result.addAll(self(n));
    return result;
  }</code></paragraph><paragraph titel = "following-sibling">
Diese Achse beschreibt die nächsten Geschwister. Wir erhalten diese, indem wir
den Elternknoten holen, durch dessen Kinder iterieren und nachdem wir an
unseren aktuellen Knoten gelangt sind, anfangen diese Kinderknoten ins
Ergebnis aufzunehmen.<code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; following_sibling(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    int nodeType = n.getNodeType();
    boolean take = false;
    if (nodeType != Node.ATTRIBUTE_NODE){
      for (Node sibling:child(n.getParentNode())){
        if (take) result.add(sibling);
        if (sibling==n) take=true;
      }
    }
    return result;
  }</code></paragraph><paragraph titel = "preceding-sibling">
Entsprechend gibt es die Achse, die die vor dem aktuellen Knoten stehenden
Geschwister extrahieren. Wir gehen ähnlich vor wie oben, sammeln jetzt jedoch
die Kinder nur bis zum aktuellen Knoten auf.<code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; preceding_sibling(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    int nodeType = n.getNodeType();
    if (nodeType != Node.ATTRIBUTE_NODE){
      for (Node sibling:child(n.getParentNode())){
        if (sibling==n) break;
        result.add(sibling);
      }
    }
    return result;
  }</code></paragraph><paragraph titel = "following">
Die Nachfolgerachse bezieht sich auf die Dokumentordnung in serialisierter
Form. Sie bezeichnet alle Knoten, deren Tag im gedruckten XML Dokument nach
dem Ende des aktuellen Knotens beginnen. Dieses sind die nachfolgenden
Geschwister und deren Nachkommen:<code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; following(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node follow_sib:following_sibling(n)){
      result.add(follow_sib);
      result.addAll(descendant(follow_sib));
    }
    return result;
  }</code></paragraph><paragraph titel = "preceding">
Analog hierzu funktioniert die Vorgängerachse. Auch sie bezieht sich auf die
Dokumentordnung: <code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; preceding(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node preced_sib:preceding_sibling(n)){
      result.add(preced_sib);
      result.addAll(descendant(preced_sib));
    }
    return result;
  }</code></paragraph><paragraph titel = "attribute">
Attribute werden in einer gesonderten Achse beschrieben. Sie tauchen in keiner
der vorherigen Achsen auf. Ausgenommen sind in dieser Achse die Attribute die
eine Namensraumdefinition beschreiben:<code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; attribute(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    if (n.getNodeType()==Node.ELEMENT_NODE){
      NamedNodeMap nnm = n.getAttributes();
      for (int i:new FromTo(0,nnm.getLength()-1)){
        Node current = nnm.item(i);
        if (!current.getNodeName().startsWith(&quot;xmlns&quot;))
          result.add(current);
      }
    }
    return result;
  }</code></paragraph><paragraph titel = "namespace">
Ebenso gesondert werden in der letzten Achse die Namensraumdefinitionen
behandelt. XML-technisch sind diese Attribute, deren Attributname 
mit <tt>xmlns</tt> beginnt: <code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; namespace(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    if (n.getNodeType()==Node.ELEMENT_NODE){
      NamedNodeMap nnm = n.getAttributes();
      for (int i:new FromTo(0,nnm.getLength()-1)){  
        Node current = nnm.item(i);
        if (current.getNodeName().startsWith(&quot;xmlns&quot;))
          result.add(current);
      }
    }
    return result;
  }</code></paragraph><paragraph titel = "Achsenberechnung">
Für Aufzählungstypen ab Java 1.5 läßt sich eine 
schöne <tt>switch</tt>-Anweisung schreiben. So können wir eine allgemeine
Methode zur Achsenberechnung schreiben, die für jede Achse die entsprechende
Methode aufruft.<footnote>Die Version Beta1 von Java 1.5 hat einen Bug, so daß
der javac Commpiler bei der folgenden Klasse während der Codegenerierung
abstürzt. Daher ist der Code vorerst auskommentiert.</footnote><code class = "Axes"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static List&lt;Node&gt; getAxis(Node n,AxisType axis){
     switch (axis){
      case ancestor          : return ancestor(n); 
      case ancestor_or_self  : return ancestor_or_self(n); 
      case attribute         : return attribute(n);
      case child             : return child(n); 
      case descendant        : return descendant(n); 
      case descendant_or_self: return descendant_or_self(n); 
      case following         : return following(n);
      case following_sibling : return following_sibling(n); 
      case namespace         : return namespace(n);
      case parent            : return parent(n);
      case preceding         : return preceding(n); 
      case preceding_sibling : return preceding_sibling(n);
      case self              : return self(n);
      default                :throw new UnsupportedOperationException();
    }
  }
}</code></paragraph></subsubsection><subsubsection titel = "Knotentest">
Die Kernausdrücke in XPath sind von der Form: <quote>
            <em>axisType</em>
            <tt>::</tt>
            <em>nodeTest</em>
          </quote><em>axisType</em> beschreibt dabei eine der 13 
Achsen. <em>nodeTest</em> ermöglicht es, aus den durch die Achse beschriebenen
Knoten bestimmte Knoten zu selektieren. Syntaktisch gibt es 8 Arten des
Knotentests:<itemize>
            <item><tt>*</tt>: beschreibt Elementknoten mit beliebigen Namen.</item>
            <item><em>pref</em><tt>:*</tt>: beschreibt Elementknoten mit dem 
Prefix <em>pref</em> und beliebigen weiteren Namen.</item>
            <item><em>pref</em><tt>:</tt><em>name</em>: beschreibt Elementknoten mit dem 
Prefix <em>pref</em> und den weiteren Namen <em>name</em>. Der Teil vor den
Namen kann dabei auch fehlen.</item>
            <item><tt>comment()</tt>: beschreibt Kommentarknoten.</item>
            <item><tt>text()</tt>: beschreibt Textknoten.</item>
            <item><tt>processing-instruction()</tt>: beschreibt
Processing-Instruction-Knoten.</item>
            <item><tt>processing-instruction(</tt><em>target</em><tt>)</tt>: beschreibt
Processing-Instruction-Knoten mit einem bestimmten Ziel.</item>
            <item><tt>node()</tt>: beschreibt beliebige Knoten.</item>
          </itemize><paragraph titel = "Algebraischer Typ für Knotentests">
Wir können die acht verschiedene Knotentests durch einen algebraischen Typ
ausdrücken: <code class = "NodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  apt = "true">package name.panitz.xml.xpath;
import java.util.List;
import name.panitz.adt.*;

@Data abstract class NodeTest{
  @Constr void StarTest(){};
  @Constr void PrefixStar(String prefix){};
  @Constr void QName(String prefix,String name){};
  @Constr void IsComment(){};
  @Constr void IsText(){};
  @Constr void IsProcessingInstruction(){};
  @Constr void IsNamedProcessingInstruction(String name){};
  @Constr void IsNode(){};

  abstract public &lt;b_&gt; b_ welcome(NodeTestVisitor&lt;b_&gt; visitor);
}</code></paragraph><paragraph titel = "Textuelle Darstellung für Knotentests">
Für diesen algebraischen Typ läßt sich ein einfacher Besucher zur textuellen
Darstellung des Typs schreiben. Er erzeugt für die einzelnen Knotentests die
Syntax wie sie in XPath-Ausdrücken vorkommt. <code class = "ShowNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath">package name.panitz.xml.xpath;

public class ShowNodeTest extends NodeTestVisitor&lt;String&gt; {
  public String visit(StarTest _){return &quot;*&quot;;}
  public String visit(PrefixStar e){return e.prefix+&quot;:*&quot;;}
  public String visit(QName e){String result=&quot;&quot;;
    if (e.prefix.length()&gt;0) result=e.prefix+&quot;:&quot;;
    result=result+e.name;
    return result;
  }
  public String visit(IsComment _){return &quot;comment()&quot;;}
  public String visit(IsText _){return &quot;text()&quot;;}
  public String visit(IsProcessingInstruction _){
    return &quot;processing-instruction()&quot;;}
  public String visit(IsNamedProcessingInstruction e){
    return &quot;processing-instruction(&quot;+e.name+&quot;)&quot;;
  }
  public String visit(IsNode _){return &quot;node()&quot;;}
}</code></paragraph><paragraph titel = "Auswerten von Knotentests">
Ein Knotentest ergibt für einen konkreten Knoten 
entweder <tt>true</tt> oder <tt>false</tt>. Hierfür können wir einen Besucher
schreiben, der für einen Knotentest und einen konkreten Knoten diesen
bool&#39;schen Wert berechnet.<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath">package name.panitz.xml.xpath;

import java.util.List;
import java.util.ArrayList;
import static org.w3c.dom.Node.*;
import org.w3c.dom.*;

public class DoNodeTest extends NodeTestVisitor&lt;Boolean&gt; {
  Node current;
  public DoNodeTest(Node n){current=n;}</code>

Der Test auf einen Stern ist wahr für jedes Element oder Attribut:<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public Boolean visit(StarTest _){
    return    current.getNodeType()==ELEMENT_NODE
           || current.getNodeType()==ATTRIBUTE_NODE;
  }</code>

Der Test auf ein bestimmtes Prefix ist wahr für jeden Knoten, der diesen
Prefix hat:<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public Boolean visit(PrefixStar e){
    String currentPrefix = current.getPrefix();
    if (currentPrefix==null) currentPrefix=&quot;&quot;;
    return   new StarTest().welcome(this) 
         &amp;&amp; currentPrefix.equals(e.prefix);
  }</code>

Jeder Test nach einen qualifizierten Namen ist wahr, wenn der Knoten diesen
Namen hat:<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public Boolean visit(QName e){
    return   new PrefixStar(e.prefix).welcome(this) 
         &amp;&amp;  current.getNodeName().equals(e.name);
  }</code>

Der Test nach Kommentaren ist für Kommantarknoten wahr:<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public Boolean visit(IsComment _){
    return current.getNodeType()==COMMENT_NODE;}</code>

Der Test nach Text ist für Textknoten wahr:<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public Boolean visit(IsText _){
    return current.getNodeType()==TEXT_NODE;}</code>

Der Test nach Processing-Instruction ist für PI-Knoten wahr:<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public Boolean visit(IsProcessingInstruction _){
    return current.getNodeType()==PROCESSING_INSTRUCTION_NODE;}</code>

Der Test nach Processing-Instruction mit bestimmten Namen 
ist für PI-Knoten mit diesen Namen wahr:<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public Boolean visit(IsNamedProcessingInstruction e){
    return current.getNodeType()==PROCESSING_INSTRUCTION_NODE
        &amp;&amp; e.name.equals(current.getNodeName());
  }</code>

Der Test nach Knoten ist immer wahr:<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public Boolean visit(IsNode _){return true;}</code>

Einen großen Teil eines XPath-Prozessors haben wir damit schon
implmentiert. Wir können uns die Knoten einer Achse geben lassen und wir
können diese Knoten auf einen Knotentest hin prüfen. Zusammen läßt sich damit
bereits eine Methode zu Auswertung eines Kernausdrucks mit Achse und
Knotentest schreiben. Hierzu iterieren wir über die Liste der durch die Achse
spezifizierten Knoten und fügen diese bei positiven Knotentest dem Ergebnis 
zu:<code class = "DoNodeTest"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  static public List&lt;Node&gt; evalAxisExpr
        (AxisType axis,NodeTest test1,Node context){
    NodeTestAdt test = (NodeTestAdt)test1;	
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (Node node:Axes.getAxis(context,axis)){
      if (test.welcome(new DoNodeTest(node)))
        result.add(node);
    }
    return result;
  }
}</code></paragraph></subsubsection><subsubsection titel = "Pfadangaben">
In obiger Einführung haben wir bereits gesehen, daß XPath den aus dem
Dateissystem bekannten Schrägstrich für Pfadangaben benutzt. Betrachten wir
XPath-Ausdrücke als Terme, so stellt der Schrägstrich einen Operator
dar. Diesen Operator gibt es sowohl einstellig wie auch zweistellig.<p/>

Die Grundsyntax in XPath sind eine durch Schrägstrich getrennte Folge von
Kernausdrücke mit Achsentyp und Knotentest.<example>
Der Ausdruck<p/><tt>child::skript/child::*/descendant::node()/self::code/attribute::class</tt><p/>

beschreibt die Attribute mit Attributnamen <tt>class</tt>, die an einem
Elementknoten mit Tagnamen <tt>code</tt> hängen, die Nachkommen eines
beliebigen Elementknotens sind, die Kind eines Elementknotens mit 
Tagnamen <tt>skript</tt> sind, die Kind des aktuellen Knotens, auf dem der
Ausdruck angewendet werden soll sind.<p/>

Vorwärts gelesen ist dieser Ausdruck eine Selektionsanweisung:<br/>
Nehme alle <tt>skript</tt>-Kinder des aktuellen Knotens. Nehme von diesen
beliebige Kinder. Nehme von diesen alle <tt>code</tt>-Nachkommen. Und nehme
von diesen jeweils alle <tt>class</tt>-Attribute.</example>

Der einstellige Schrägstrichoperator bezieht sich auf die Dokumentwurzel des
aktuellen Knotens.</subsubsection><subsubsection titel = "Abkürzende Pfadangaben">
XPath kennt einen zweiten Pfadoperator <tt>//</tt>.  
Auch er existiert jeweils einmal
einstellig und einmal zweistellig. Der doppelte Schrägstrich ist eine
abkürzende Schreibweise, die übersetzt werden kann in Pfade mit einfachen
Schrägstrichoperator. <p/><center>
            <table layout = "ll">
              <zeile>
                <zelle>
                  <b>//</b>
                  <em>expr</em>
                </zelle>
                <zelle>
                  <minipage dimension = "0.8\textwidth">Betrachte beliebige Knoten
unterhalt des Dokumentknotens, die durch <em>expr</em> charakterisiert 
werden.\\[0.5em]</minipage>
                </zelle>
              </zeile>
              <zeile>
                <zelle>
                  <b><m>e_1</m>//</b>
                  <m>e_2</m>
                </zelle>
                <zelle>
                  <minipage dimension = "0.8\textwidth">Betrachte beliebiege Knoten  unterhalb
der durch <m>e_1</m> charkterisierten Knoten.und prüfe diese 
auf <m>e_2</m>.</minipage>
                </zelle>
              </zeile>
            </table>
          </center><paragraph titel = "Übersetzung in Kernsyntax">
Der Doppelschrägstrich ist eine abkürzende Schreibweise 
für: <tt>/descendant-or-self::node()/</tt></paragraph></subsubsection><subsubsection titel = "Weitere abkürzende Schreibweisen">
In XPath gibt es weitere abkürzende Schreibweisen, die auf die Kernsyntax
abgebildet werden können.<paragraph titel = "der einfache Punkt">
Für die Selbstachse kann als abkürzende Schreibweise ein einfacher Punkt<tt>.</tt> gewählt werden, wie er aus den Pfadangaben im Dateisystem bekannt
ist.  <p/>

Der Punkt <tt>.</tt> ist die abkürzende Schreibweise 
für: <tt>self::node()</tt>.</paragraph><paragraph titel = "der doppelte Punkt">
Für die Elternachse kann als abkürzende Schreibweise ein doppelter Punkt<tt>..</tt> gewählt werden, wie er aus den Pfadangaben im Dateisystem bekannt
ist.  <p/>

Der Punkt <tt>..</tt> ist die abkürzende Schreibweise 
für: <tt>parent::node()</tt>.</paragraph><paragraph titel = "implizite Kinderachse">
Ein Kernausdruck, der Form <tt>child::</tt><em>nodeTest</em> kann abgekürzt
werden durch <em>nodeTest</em>. Die Kinderachse ist also der Standardfall.</paragraph><paragraph titel = "Attributselektion">
Auch für die Attributachse gibt es eine abkürzende Schreibweise:
ein Kernausdruck, der 
Form <tt>attribute::</tt><em>pre</em><tt>:</tt><em>name</em> kann abgekürzt
werden durch <tt>@</tt><em>pre</em><tt>:</tt><em>name</em>. </paragraph><example>Insgesamt läßt sich der obige Ausdruck abkürzen 
zu: <tt>skript/*//code/@class</tt></example></subsubsection><subsubsection titel = "Vereinigung">
In XPath gibt es ein Konstrukt, das die Vereinigung zweier durch einen
XPath-Ausdruck beschriebener Listen beschreibt. Syntaktisch wird dieses durch
einen senkrechten Strich <tt>|</tt> ausgedrückt. <example>Der 
Audruck <tt>/skript/kapitel | /skript/anhang/kapitel</tt> beschreibt 
die <tt>kapitel</tt>-Elemente die unter  top-level 
Knoten <tt>skript</tt> hängen oder die unter einen 
Knoten <tt>anhang</tt>, der unter dem <tt>skript</tt>-Element hängt.</example></subsubsection><subsubsection titel = "Funktionen und Operatoren">
XPath kommt mit einer großen Zahl eingebauter Funktionen und Operatoren. Diese
sind in einer eigenen Empfehlung des W3C 
spezifiziert<cite label = "xpathfunop"/>. Sie können auf Mengen von Knoten aber
auch auf Zahlen, Strings und bool&#39;schen Werten definiert sein. 
So gibt es z.B. die 
Funktion <tt>count</tt>, die für eine Knotenliste die Anzahl der darin
enthaltenen Knoten angibt. <example>Der Ausdruck <tt>count(//code)</tt> gibt die Anzahl der in einem
Dokument enthaltenen <tt>code</tt>-Elemente zurück.</example></subsubsection><subsubsection titel = "Literale">
Für die Rechnung mit Funktionen und Operatorn gibt es Literalen für Strings
und Zahlen in XPath.<example>Der Ausdruck <tt>count(//kapitel)=5</tt> wertet 
zu <tt>true</tt> aus, wenn des Dokument genau fünf <tt>kapitel</tt>-Elemente
hat. </example></subsubsection><subsubsection titel = "Qualifizierung">
Bisher haben wir gesehen, wie entlang der Achsen Mengen von Teildokumenten von
XML-Dokementen selektiert werden können. XPath sieht zusätzlich vor, durch ein
Prädikat über diese Menge zu filtern. Ein solches Prädikat gibt dabei an, ob
ein solcher Knoten in der Liste gewünscht ist oder nicht. Man nennt Ausdrücke
mit einem Prädikat auch qulifizierte Ausdrücke.<p/>

Syntaktisch stehen die Prädikate eines XPath-Ausdrucks in eckigen Klammern
hinter den Ausdruck. Das Prädikat ist selbst wieder ein XPath-Ausdruck.
Die Auswertung eines qualifizierten XPath-Ausdrucks funktioniert nach
folgender Regel:<quote>Berechne die Ergebnisliste des Ausdrucks. Für jedes Element dieser
Liste als aktuellen Kontextknoten berechne  das Ergebnis des
Prädikats. Interpretiere dieses Ergebnis als bool&#39;schen Wert und verwerfe
entweder den Kontextknoten oder nimm ihn in das Ergebnis aus.</quote>

Je
nachdem was das Prädikat für ein Ergebnis hat, wird es als wahr oder falsch
interpretiert. Diese Interpretation ist relativ pragmatisch. XPath war
ursprünglich so konzipiert, daß es vollkommen ungetypt ist und es während der
Ausführung zu keinerlei Typcheck kommt, geschweige denn ein statisches
Typsyystem existiert. Daher wird bei der Anwendung von Funktionen und
Operatoren als auch bei der Auswertung eines Prädikats versucht, jeden Wert als jeden
beliebige Typ zu interpretieren.<paragraph titel = "bool&#39;sches Ergebnis">
Prädikate die direkt durch ein Funktionsergebnis oder eine Operatoranwendung
einen bool&#39;schen Wert als Ergebnis haben, können direkt als Prädikat
interpretiert werden.<example>Der  XPath-Ausdruck <tt>//code[@lang=&quot;hs&quot;]</tt> selektiert alle
Code-Knoten des Dokuments, die ein Attribut <tt>lang</tt> mit dem 
Wert <tt>hs</tt>  haben.</example></paragraph><paragraph titel = "leere oder nichtleere Ergebnisliste">
Wenn der XPath-Ausdruck eines Prädikats zu einer Liste auswertet, dann wird
eine leere Liste als der bool&#39;sche Wert <tt>false</tt> ansonsten 
als <tt>true</tt> interpretiert.<example>Der XPath-Ausdruck <tt>//example[.//code]</tt> selektiert 
alle <tt>example</tt>-Knoten des Dokuments, die mindestens 
einen <tt>code</tt>-Nachkommen haben. Also alle Beispiele, in denen ein
Programm vorkommt.    </example></paragraph><paragraph titel = "eine Zahl als Ergebnis">
Über Funktionen kann ein XPath-Ausdruck auch eine Zahl als Ergebnis haben. In
dem Fall, daß ein XPath-Ausdruck zu einer Zahl auswertet, wird ein Knoten
selektiert, wenn er an der Stelle dieser Zahl in der Liste des qualifizierten
Ausdrucks ist.<example>Der Ausdruck <tt>/skript/kapitel[3]</tt> selektiert jeweils das 
dritte <tt>kapitel</tt>-Element innerhalb 
eines <tt>skript</tt>-Elements.</example></paragraph></subsubsection><subsubsection titel = "Klammerung">Schließlich kennt XPath noch die Klammerung von Teilausdrücken.<example>Der Ausdruck <tt>./skript/(./kapitel | ./anhang)</tt> bezeichnet 
alle <tt>kapitel</tt>- oder <tt>anhang</tt>-Elemente ausgehend 
vom <tt>skript</tt>-Kind des Kontextknotens. 
Hingegen <tt>./skript/kapitel | ./anhang</tt> bezeichnet 
die <tt>kapitel</tt>-Elemente unter dem <tt>skript</tt>-Kinder des
Kontextknotens oder <tt>anhang</tt>-Kinder des Kontextknotens. </example></subsubsection><subsubsection titel = "Algebraischer Typ für XPath-Ausdrücke">
In diesem Abschnitt wollen wir einmal versuchen einen eigenen 
zumindest rudimentären XPath Prozessor
zu schreiben. Ein XPath Prozessor selektiert ausgehend von einem aktuellen
Knoten anhand eines gegebenen XPath Ausdrucks eine Liste von Teildokumenten.
Zunächst brauchen wir einen Typ, der XPath-Ausdrücke beschreiben kann. Wir
können dieses in einem algebraischen Tyen einfach zusammenfassen. Für
jedes XPath 
Konstrukt  gibt es einen eigenen Konstruktor:<code class = "XPath"
                lang = "java"
                package = "name/panitz/xml/xpath"
                apt = "true">package name.panitz.xml.xpath;
import java.util.List;
import name.panitz.adt.*;

@Data abstract class XPath {
  @Constr void Axis(AxisType type,NodeTest nodeTest){};
  @Constr void RootSlash(XPath expr){};
  @Constr void RootSlashSlash(XPath expr){};
  @Constr void Slash(XPath e1,XPath e2){};
  @Constr void SlashSlash(XPath e1,XPath e2){};
  @Constr void TagName(String name){};
  @Constr void AttributeName(String name){};
  @Constr void Dot(){};
  @Constr void DotDot(){};
  @Constr void NodeSelect(){};
  @Constr void TextSelect(){};
  @Constr void PISelect(){};
  @Constr void CommentSelect(){};
  @Constr void Star(){};
  @Constr void AtStar(){};
  @Constr void Union(XPath e1,XPath e2){};
  @Constr void Function(String name,List&lt;XPath&gt; arguments){};
  @Constr void BinOperator(String name, XPath e1,XPath e2){};
  @Constr void UnaryOperator(String name, XPath expr){};
  @Constr void QualifiedExpr(XPath expr,XPath qualifier){}; 
  @Constr void NumLiteral(Integer value){};
  @Constr void StringLiteral(String value){};

  abstract public &lt;b_&gt; b_ welcome(XPathVisitor&lt;b_&gt; visitor);
}</code>

Die Klammerung wird in Objekten diesen algebraischen Typs durch die
Baumstruktur dargestellt.<paragraph titel = "Textuelle Darystellung von XPath Ausdrücken">
Zunächst folgt ein Besucher, der uns ein XPath-Objekt wieder in der
XPath-Syntax darstellt:<code class = "ShowXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath">package name.panitz.xml.xpath;

public class ShowXPath extends XPathVisitor&lt;StringBuffer&gt; {
  StringBuffer result = new StringBuffer();
  public StringBuffer visit(Axis e){
    result.append(e.type);
    result.append(&quot;::&quot;);
    result.append(e.nodeTest.welcome(new ShowNodeTest()));
    return result;
  }
  public StringBuffer visit(RootSlash e){
    result.append(&quot;/&quot;); e.expr.welcome(this);
    return result;}
  public StringBuffer visit(RootSlashSlash e){
    result.append(&quot;//&quot;); e.expr.welcome(this);
    return result;}
  public StringBuffer visit(Slash e){
    e.e1.welcome(this);result.append(&quot;/&quot;);e.e2.welcome(this);
    return result;}
  public StringBuffer visit(SlashSlash e){
    e.e1.welcome(this);result.append(&quot;//&quot;);e.e2.welcome(this);
    return result;}
  public StringBuffer visit(TagName e){result.append(e.name);
    return result;}
  public StringBuffer visit(AttributeName e){
    result.append(&quot;@&quot;);result.append(e.name);
    return result;}
  public StringBuffer visit(Dot e){result.append(&quot;.&quot;);
    return result;}
  public StringBuffer visit(DotDot e){result.append(&quot;..&quot;);
    return result;}
  public StringBuffer visit(NodeSelect e){result.append(&quot;node()&quot;);
    return result;}
  public StringBuffer visit(TextSelect e){result.append(&quot;text()&quot;);
    return result;}
  public StringBuffer visit(CommentSelect e){result.append(&quot;comment()&quot;);
    return result;}
  public StringBuffer visit(PISelect e){
    result.append(&quot;processing-instruction()&quot;);
    return result;}
  public StringBuffer visit(Star e){result.append(&quot;*&quot;);
    return result;}
  public StringBuffer visit(AtStar e){result.append(&quot;@*&quot;);
    return result;}
  public StringBuffer visit(Union e){
    e.e1.welcome(this);result.append(&quot;|&quot;);e.e2.welcome(this);
    return result;}
  public StringBuffer visit(Function e){
    result.append(e.name);result.append(&quot;(&quot;);
    boolean first = true;
    for (XPath arg:e.arguments){
      if (!first) result.append(&quot;,&quot;);else first=false;
      arg.welcome(this);
    }
    result.append(&quot;)&quot;);
    return result;}
  public StringBuffer visit(UnaryOperator e){
    result.append(e.name+&quot;\u0020&quot;);e.expr.welcome(this);
    return result;}
  public StringBuffer visit(BinOperator e){
    e.e1.welcome(this);result.append(&quot;\u0020&quot;+e.name+&quot;\u0020&quot;);
    e.e2.welcome(this);return result;}
  public StringBuffer visit(QualifiedExpr e){
    e.expr.welcome(this);result.append(&quot;[&quot;);
    e.qualifier.welcome(this);result.append(&quot;]&quot;);
    return result;}
  public StringBuffer visit(NumLiteral e){result.append(&quot;&quot;+e.value);
    return result;}
  public StringBuffer visit(StringLiteral e){
   result.append(&quot;\&quot;&quot;);result.append(e.value) ;result.append(&quot;\&quot;&quot;);
   return result;}
}</code></paragraph></subsubsection><subsubsection titel = "Entfernen von abkürzenden Schreibweisen">
Wir wollen XPath-Ausdrücke auf Dokumentknoten anwenden. Wenn wir zunächst 
alle abkürzende Schreibweisen in einem XPath-Ausdruck durch ihren Kernausdruck
ersetzen, so brauchen wir bei der Anwendung eines XPath-Ausdrucks nicht mehr
um abgekürzte Ausdrücke kümmern. Daher schreiben wir zunächst einen Besucher,
der in einem XPath-Ausdruck alle Abkürzungen löscht:<code class = "RemoveAbbreviation"
                lang = "java"
                package = "name/panitz/xml/xpath">package name.panitz.xml.xpath;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;
import name.panitz.domtest.*;

public class RemoveAbbreviation extends XPathVisitor&lt;XPath&gt; {</code><paragraph titel = "Entfernung von: //e">
Die komplexeste abkürzende Schreibweise ist der Doppelschrägstrich. Er wird
ersetzt durch den Ausdruck: <tt>/descendant-or-self::node()/</tt>. Für den
einstelligen <tt>//</tt>-Operator ergibt das den Javaausdruck:<scode>new RootSlash(new Slash(new Axis(AxisType.descendant_or_self,new IsNode()),expr))</scode>

Wir erhalten folgende Implementierung:<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(RootSlashSlash e){
  /* //expr -&gt; /descendant-or-self::node()/expr  */
  return 
    new RootSlash(
     new Slash(new Axis(AxisType.descendant_or_self,new IsNode())
              ,e.expr.welcome(this)));}</code></paragraph><paragraph titel = "Entfernung von: e1//e2">
In gleicher Weise ist der doppelte Schrägstrich als zweistelliger Operator
durch den Kernausdruck <tt>/descendant-or-self::node()/</tt> zu ersetzen.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(SlashSlash e){
  final XPath e1 = e.e1;
  final XPath e2 = e.e2;
  /* e1//e2 -&gt; e1/descendant-or-self::node()/e2 */
  return 
   new Slash
     (e1.welcome(this)
     ,new Slash(new Axis(AxisType.descendant_or_self,new IsNode())
               ,e2.welcome(this)));}</code></paragraph><paragraph titel = "Entfernung von: .">
Der einfache Punkt wird durch einen Kernausdruck auf der Selbstachse ersetzt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(Dot e){
  return new Axis(AxisType.self,new IsNode());}</code></paragraph><paragraph titel = "Entfernung von: ..">
Der doppelte Punkt wird durch einen Kernausdruck auf der Elternachse ersetzt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(DotDot e){
  return new Axis(AxisType.parent,new IsNode());}</code></paragraph><paragraph titel = "Entfernung von: qname">
Für einen einfachen Tagnamen wird die implizit vorhandene  Kinderachse eingefügt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(TagName e){
  return new Axis(AxisType.child,new QName(&quot;&quot;,e.name));}</code></paragraph><paragraph titel = "Entfernung von: @attr">
Für einen einfachen Attributnamen wird die implizit vorhandene  
Attributachse eingefügt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(AttributeName e){
  return new Axis(AxisType.attribute,new QName(&quot;&quot;,e.name));}</code></paragraph><paragraph titel = "Entfernung von: node()">
Für einen einfache Knotentest wird die implizit vorhandene  
Kinderachse eingefügt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(NodeSelect e){
  return new Axis(AxisType.child,new IsNode());}</code></paragraph><paragraph titel = "Entfernung von: text()">
Für einen einfache Texttest wird die implizit vorhandene  
Kinderachse eingefügt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(TextSelect e){
  return new Axis(AxisType.child,new IsText());}</code></paragraph><paragraph titel = "Entfernung von: processing-instruction()">
Für einen einfache Processing-Instruction-Test wird die implizit vorhandene  
Kinderachse eingefügt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(PISelect e){
  return new Axis(AxisType.child,new IsProcessingInstruction());}</code></paragraph><paragraph titel = "Entfernung von: comment()">
Für einen einfache Kommentartest wird die implizit vorhandene  
Kinderachse eingefügt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(CommentSelect e){
  return new Axis(AxisType.child,new IsComment());}</code></paragraph><paragraph titel = "Entfernung von: *">
Für einen einfache Sterntest wird die implizit vorhandene  
Kinderachse eingefügt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(Star e){
  return new Axis(AxisType.child,new StarTest());}</code></paragraph><paragraph titel = "Entfernung von: @*">
Für einen einfache Sterntest auf Attributen  wird die implizit vorhandene  
Attributachse eingefügt.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(AtStar e){
  return new Axis(AxisType.attribute,new StarTest());}</code></paragraph><paragraph titel = "Nichtabgekürzte Ausdrücke">
Für die Ausdrücke, die keine abkürzende Schreibweise darstellen, wird der
Besucher in die Unterausdrücke geschickt, um in diesen abkürzende
Schreibweisen zu ersetzen.<code class = "RemoveAbbreviation"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">public XPath visit(Slash e){
  return new Slash(e.e1.welcome(this),e.e2.welcome(this));}
public XPath visit(Axis e){return e;}
public XPath visit(RootSlash e){
  return new RootSlash(e.expr.welcome(this));}
public XPath visit(Union e){
  return new Union(e.e1.welcome(this),e.e2.welcome(this));}
public XPath visit(Function e){
  final List&lt;XPath&gt; args = e.arguments;
  List&lt;XPath&gt; newArgs = new ArrayList&lt;XPath&gt;();
  for (XPath arg:args) newArgs.add(arg.welcome(this));
  return new Function(e.name,newArgs);}
public XPath visit(BinOperator e){
  return new BinOperator(e.name
                        ,e.e1.welcome(this)
                        ,e.e2.welcome(this));}
public XPath visit(UnaryOperator e){
  return new UnaryOperator(e.name,e.expr.welcome(this));}
public XPath visit(QualifiedExpr e){
  return new QualifiedExpr(e.expr.welcome(this)
                          ,e.qualifier.welcome(this));}
public XPath visit(NumLiteral e){return e;}
public XPath visit(StringLiteral e){return e;}
}</code></paragraph></subsubsection><subsubsection titel = "Auswerten von XPath Ausdrücken">
Wir haben nun alles beisammen, um einen XPath-Prozessor zu definieren.<paragraph titel = "Auswertungsergebnis">
 Die
Auswertung eines XPath-Ausdrucks kann eine Liste von Knoten, eine Zahl, ein
String oder ein bool&#39;sches Ergebnis haben. Hierfür sehen wir einen
algebraischen Typ vor.<code class = "XPathResult"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  apt = "true">package name.panitz.xml.xpath;
import org.w3c.dom.Node;
import java.util.List;
import name.panitz.adt.*;

@Data abstract class XPathResult {
  @Constr void BooleanResult(Boolean value){};
  @Constr void NumResult(Integer value){};
  @Constr void StringResult(String value){};
  @Constr void Nodes(List&lt;Node&gt; value){};

  abstract public &lt;b_&gt; b_ welcome(XPathResultVisitor&lt;b_&gt; visitor);
}</code></paragraph><paragraph titel = "Auswertung">
Der eigentliche Prozessor wird als Besucher über einen XPath-Ausdruck
geschrieben.  Dieser Besucher braucht drei Informationen:<itemize>
              <item>den Kontextknoten, auf den der Ausdruck angewendet werden soll.</item>
              <item>die Größe der Liste, in der der Knotextknoten ist.</item>
              <item>die Position des Kontextknotens in der Liste, in der er sich 
befindet.</item>
            </itemize><code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath">package name.panitz.xml.xpath;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;
import static org.w3c.dom.Node.*;
import name.panitz.domtest.*;

import static name.panitz.xml.xpath.Axes.*;

public class EvalXPath extends XPathVisitor&lt;XPathResult&gt; {
  Node current;
  int contextPosition=1;
  int contextSize=1;

  public EvalXPath(Node n){current=n;}
  public EvalXPath(Node n,int pos,int size){
    this(n);contextPosition=pos;contextSize=size;}</code>

Einen Kernausdruck mit einer Achse können wir bereits auswerten. Die
entsprechende Methode haben wir bereits in der 
Klasse <tt>DoNodeTest</tt> implementiert.<code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public XPathResult visit(Axis e){
    return new Nodes(
      DoNodeTest.evalAxisExpr(e.type,e.nodeTest,current));
  }</code>

Für den einstelligen Schrägstrich ist der Dokumentknoten des Knotextsknotens
zu beschaffen, um für diesen als neuen Kontextknoten den XPath-Ausdruck rechts
von  dem Schrägstrich anzuwenden.<code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public XPathResult visit(RootSlash e){
    Node doc ;
    if (current.getNodeType()==DOCUMENT_NODE) doc=current;
    else{
      doc = current.getOwnerDocument();
    }
    if (doc!=null) return e.expr.welcome(new EvalXPath(doc));

    return new Nodes(new ArrayList&lt;Node&gt;());
  }</code>

Für den zweistelligen Schrägstrich ist zunächst der linke Kinderausdruck zu
besuchen. Falls dieses eine Knotenliste darstellt, ist für jedes Element
dieser Liste als Kontextknoten der zweite Operand zu besuchen. <code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public XPathResult visit(Slash e){
    XPathResult res1 = e.e1.welcome(this);

    if (res1 instanceof Nodes){
      final List&lt;Node&gt; resultNodes = new ArrayList&lt;Node&gt;();
      final List&lt;Node&gt; e1s = ((Nodes)res1).value;
      final int size = e1s.size();
      int pos = 1;
      for (Node e1:e1s){
        XPathResult e2s = e.e2.welcome(new EvalXPath(e1,pos,size));
        if (e2s instanceof Nodes)
           resultNodes.addAll(((Nodes)e2s).value);
        else return e2s;
        pos=pos+1;
      }
      return new Nodes(resultNodes);
    }
    return res1;
  }</code>

Für die Vereinigung zweier XPath-Ausdrücke, sind diese beide Auszuwerten und
in Falle einer Knotenliste als Ergebnis beide Liste zu vereinigen.<code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public XPathResult visit(Union e){
    XPathResult r1 = e.e1.welcome(this);
    XPathResult r2 = e.e1.welcome(this);
    if (r1 instanceof Nodes &amp;&amp; r2 instanceof Nodes){
      List&lt;Node&gt; resultNodes = ((Nodes)r1).value;
      resultNodes.addAll(((Nodes)r2).value);
      return new Nodes(resultNodes);
    }
    return r1;
  }</code>

Ein numerisches Literal ist gerade nur der Wert dieses Literals das Ergebnis.<code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public XPathResult  visit(NumLiteral e){
    return new NumResult(e.value);}</code>

Ein Stringliteral ist gerade nur der Wert dieses Literals das Ergebnis.<code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public XPathResult visit(StringLiteral e){
    return new StringResult(e.value);}</code>

Für einen qualifizierten Ausdruck ist erst der XPath-Ausdruck auszuwerten, und
dann für jedes Element der Knotenliste das Prädikat. Es ist zu testen, ob
dieses Prädikat als wahr oder falsch zu interpretieren ist. Hierzu wird ein
Besucher auf <tt>XPathResult</tt> geschrieben.<code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public XPathResult visit(QualifiedExpr e){
    XPathResult result1 = e.expr.welcome(this);
    if (result1 instanceof Nodes){
      final List&lt;Node&gt; resultNodes = new ArrayList&lt;Node&gt;();
      final List&lt;Node&gt; rs = ((Nodes)result1).value;
      final int size = rs.size();
      int pos = 1;
      for (Node r : rs){
        XPathResult qs 
           = e.qualifier.welcome(new EvalXPath(r,pos,size));
        if (qs.welcome(new TestQualifier(r,pos,size)))
          resultNodes.add(r);
        pos=pos+1;
      }
      return new Nodes(resultNodes);
    }
    return result1;
  }</code>


Die folgenden Fälle brauchen wir in der Auswertung nicht betrachten, weil wir
sie der Elemination von abkürzenden Schreibweisen aus dem XPath-Baum 
entfernt haben<code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public XPathResult visit(RootSlashSlash e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(SlashSlash e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(TagName e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(AttributeName e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(Dot e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(DotDot e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(NodeSelect e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(TextSelect e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(PISelect e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(CommentSelect e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(Star e){
   throw new UnsupportedOperationException();}
  public XPathResult visit(AtStar e){
   throw new UnsupportedOperationException();}</code>

Operatoren und Funktionen sind in unserem Prozessor noch nicht implementiert.<code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public XPathResult visit(Function e){
   throw new UnsupportedOperationException();
  }
  public XPathResult visit(BinOperator e){
   throw new UnsupportedOperationException();
  }
  public XPathResult visit(UnaryOperator e){
   throw new UnsupportedOperationException();
  }</code>


Es folgen ein paar erste Beispielaufrufe:<code class = "EvalXPath"
                  lang = "java"
                  package = "name/panitz/xml/xpath"
                  sequel = "true">  public static XPathResult eval(XPathAdt xpath,Node n){
    System.out.println(xpath.welcome(new NormalizeXPath())
                            .welcome(new ShowXPath()));

    System.out.println(xpath.welcome(new NormalizeXPath())
                            .welcome(new RemoveAbbreviation())
                            .welcome(new ShowXPath()));

    return xpath.welcome(new NormalizeXPath())
                .welcome(new RemoveAbbreviation())
                .welcome(new EvalXPath(n));
  }

  public static void main(String [] args){
    Node doc = ParseXML.parseXml(args[0]);

    XPathResult result 
     =  eval(new QualifiedExpr
           (new RootSlashSlash
               (new Slash(new TagName(&quot;code&quot;),new AttributeName(&quot;class&quot;)))
           ,new StringLiteral(&quot;XPath&quot;))
            ,doc);
    System.out.println(result);

    result 
     =  eval
         (new QualifiedExpr(new RootSlash
            (new Slash(new TagName(&quot;skript&quot;)
            ,new Slash(new TagName(&quot;kapitel&quot;)
            ,new Slash(new TagName(&quot;section&quot;),new DotDot()))))
          ,new NumLiteral(1))
         ,doc);

    System.out.println(result);

    result 
     =  eval
         (new RootSlash
            (new Slash(new TagName(&quot;skript&quot;)
            ,new Slash(new TagName(&quot;kapitel&quot;)
            ,new QualifiedExpr(new TagName(&quot;section&quot;),new NumLiteral(2)))))
         ,doc);

    System.out.println(result);
  }
}</code></paragraph><paragraph titel = "Prädikatauswertung">
Es bleibt das Ergebnis eines Prädikats als bool&#39;schen Wert zu
  interpretieren. Hierzu schreiben wir einen Besucher 
auf <tt>XPathResult</tt>. <code class = "TestQualifier"
                  lang = "java"
                  package = "name/panitz/xml/xpath">package name.panitz.xml.xpath;

import org.w3c.dom.Node;

public class TestQualifier extends XPathResultVisitor&lt;Boolean&gt; {
  final int pos;
  final int size;
  final Node context;

  public TestQualifier(Node c,int p,int s){context=c;pos=p;size=s;}

  public Boolean visit(BooleanResult e){return e.value;}
  public Boolean visit(NumResult e){return e.value==pos;}
  public Boolean visit(StringResult e) {
   return e.value.equals(context.getNodeValue());}
  public Boolean visit(Nodes e) {return !e.value.isEmpty();}
}</code></paragraph><code class = "NormalizeXPath"
                lang = "java"
                package = "name/panitz/xml/xpath">package name.panitz.xml.xpath;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;
import name.panitz.domtest.*;

public class NormalizeXPath extends XPathVisitor&lt;XPath&gt; {

public XPath visit(Axis e){return e;}

public XPath visit(RootSlash e){
//  final XPath n1 = e.expr;
  return new RootSlash(e.expr.welcome(this));}


public XPath visit(RootSlashSlash e){
  return new RootSlashSlash(e.expr.welcome(this));}

/**  mache Slash(Slash(e1,e2),e3)
   zu Slash(e1,Slash(e2,e3))
und
  mache Slash(SlashSlash(e1,e2),e3)
   zu SlashSlash(e1,Slash(e2,e3))
*/

public XPath visit(Slash e){
  final XPath n1 = e.e1;
  final XPath e3 = e.e2;
  if (n1 instanceof Slash){
    final XPath e1 = ((Slash)n1).e1;
    final XPath e2 = ((Slash)n1).e2;
    return new Slash(e1,new Slash(e2,e3)).welcome(this);    
  }
  if (n1 instanceof SlashSlash){
    final XPath e1 = ((SlashSlash)n1).e1;
    final XPath e2 = ((SlashSlash)n1).e2;
    return new SlashSlash(e1,new Slash(e2,e3)).welcome(this);    
  }
  return new Slash(n1.welcome(this),e3.welcome(this));
}

public XPath visit(SlashSlash e){
  final XPath n1 = e.e1;
  final XPath e3 = e.e2;
  if (n1 instanceof Slash){
    final XPath e1 = ((Slash)n1).e1;
    final XPath e2 = ((Slash)n1).e2;
    return new Slash(e1,new SlashSlash(e2,e3)).welcome(this);    
  }
  if (n1 instanceof SlashSlash){
    final XPath e1 = ((SlashSlash)n1).e1;
    final XPath e2 = ((SlashSlash)n1).e2;
    return new SlashSlash(e1,new SlashSlash(e2,e3)).welcome(this);    
  }
  return new Slash(n1.welcome(this),e3.welcome(this));
}

public XPath visit(Union e){
  return new Union(e.e1.welcome(this),e.e2.welcome(this));}
public XPath visit(TagName e){return e;}
public XPath visit(AttributeName e){return e;}
public XPath visit(Dot e){return e;}
public XPath visit(DotDot e){return e;}
public XPath visit(NodeSelect e){return e;}
public XPath visit(TextSelect e){return e;}
public XPath visit(PISelect e){return e;}
public XPath visit(CommentSelect e){return e;}
public XPath visit(Star e){return e;}
public XPath visit(AtStar e){return e;}

public XPath visit(Function e){return e;}
public XPath visit(BinOperator e){return e;}
public XPath visit(UnaryOperator e){return e;}
public XPath visit(QualifiedExpr e){
  return new QualifiedExpr(e.expr.welcome(this)
                          ,e.qualifier.welcome(this));}
public XPath visit(NumLiteral e){return e;}
public XPath visit(StringLiteral e){return e;}
}</code></subsubsection></subsection><subsection titel = "XSLT: Transformationen in Dokumenten">
XML-Dokumente enthalten keinerlei Information darüber, wie sie
visualisiert werden sollen. Hierzu kann man getrennt von seinem
XML-Dokument ein sogenanntes <em>Stylesheet</em> schreiben. XSL ist
eine Sprache zum Schreiben von Stylesheets für XML-Dokumente. XSL ist
in gewisser Weise eine Programmiersprache, deren Programme eine ganz
bestimmte Aufgabe haben: XML Dokumente in andere XML-Dokumente zu
transformieren. Die häufigste Anwendung von XSL dürfte sein,
XML-Dokumente in HTML-Dokumente umzuwandeln. <example>Wir werden die wichtigsten XSLT-Konstrukte mit folgendem
kleinem XML Dokument ausprobieren:<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;cdTable.xsl&quot;?&gt;
&lt;cds&gt;
 &lt;cd&gt;
  &lt;artist&gt;The Beatles&lt;/artist&gt;
  &lt;title&gt;White Album&lt;/title&gt;
  &lt;label&gt;Apple&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;The Beatles&lt;/artist&gt;
  &lt;title&gt;Rubber Soul&lt;/title&gt;
  &lt;label&gt;Parlophone&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;Duran Duran&lt;/artist&gt;
  &lt;title&gt;Rio&lt;/title&gt;
  &lt;label&gt;Tritec&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;Depeche Mode&lt;/artist&gt;
  &lt;title&gt;Construction Time Again&lt;/title&gt;
  &lt;label&gt;Mute&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;Yazoo&lt;/artist&gt;
  &lt;title&gt;Upstairs at Eric&#39;s&lt;/title&gt;
  &lt;label&gt;Mute&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;Marc Almond&lt;/artist&gt;
  &lt;title&gt;Absinthe&lt;/title&gt;
  &lt;label&gt;Some Bizarre&lt;/label&gt;
 &lt;/cd&gt;
 &lt;cd&gt;
  &lt;artist&gt;ABC&lt;/artist&gt;
  &lt;title&gt;Beauty Stab&lt;/title&gt;
  &lt;label&gt;Mercury&lt;/label&gt;
 &lt;/cd&gt;
&lt;/cds&gt;
</code></example><subsubsection titel = "Gesamtstruktur">
XSLT-Skripte sind syntaktisch auch wieder XML-Dokumente. Ein
XSLT-Skript hat feste Tagnamen, die eine Bedeutung für den
XSLT-Prozessor haben. Diese Tagnamen haben einen festen definierten
Namensraum. Das äußerste Element eines XSLT-Skripts hat den 
Tagnamen <tt>stylesheet</tt>. Damit hat ein XSLT-Skript einen Rahmen
der folgenden Form: <code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;xsl:stylesheet 
  version=&quot;1.0&quot;
  xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;
&lt;/xsl:stylesheet&gt;
</code><paragraph titel = "Einbinden in ein XML-Dokument">
Wir können mit einer <em>Processing-Instruction</em> am Anfang eines
XML-Dokumentes definieren, mit welchem XSLT Stylesheet es zu
bearbeiten ist. Hierzu wird als Referenz im 
Attribut <tt>href</tt> die XSLT-Datei angegeben.<code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;cdTable.xsl&quot;?&gt;
&lt;cds&gt;
 &lt;cd&gt;........</code></paragraph></subsubsection><subsubsection titel = "Templates (Formulare)">
Das wichtigste Element in einem XSLT-Skript ist das 
Element <tt>xsl:template</tt>. In ihm wird definiert, wie ein
bestimmtes Element transformiert werden soll. Es hat schematisch
folgende Form:<br/><tt>&lt;xsl:template match=&quot;</tt><em>Elementname</em><tt>&quot;&gt;</tt><br/><em><white/> zu erzeugender Code</em><br/><tt>&lt;/xsl:template &gt;</tt><example>
Folgendes XSLT-Skript transformiert die XML-Datei mit den CDs in eine
HTML-Tabelle, in der die CDs tabellarisch aufgelistet sind. <code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;xsl:stylesheet 
  version=&quot;1.0&quot;
  xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;

&lt;!-- Startregel für das ganze Dokument. --&gt;
&lt;xsl:template match=&quot;/&quot;&gt;
  &lt;html&gt;&lt;head&gt;&lt;title&gt;CD Tabelle&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
  &lt;/html&gt;   
&lt;/xsl:template&gt;


&lt;!-- Regel für die CD-Liste. --&gt;
&lt;xsl:template match=&quot;cds&quot;&gt;
  &lt;table border=&quot;1&quot;&gt;
    &lt;tr&gt;&lt;td&gt;&lt;b&gt;Interpret&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;Titel&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;cd&quot;&gt;
  &lt;tr&gt;&lt;xsl:apply-templates/&gt;&lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;artist&quot;&gt;
  &lt;td&gt;&lt;xsl:apply-templates/&gt;&lt;/td&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;title&quot;&gt;
  &lt;td&gt;&lt;xsl:apply-templates/&gt;&lt;/td&gt;
&lt;/xsl:template&gt;

&lt;!-- Regel für alle übrigen Elemente. 
     Mit diesen soll nichts gemacht werden --&gt;
&lt;xsl:template match=&quot;*&quot;&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</code>
Öffnen wir nun die XML Datei, die unsere CD-Liste enthält im
Webbrowser, so wendet er die Regeln des referenzierten XSLT-Skriptes
an und zeigt die so generierte Webseite wie in 
Abbildung <ref name = "cds1"/> zu sehen an.<bild name = "cds1"
                  pdfscale = "0.7"
                  psscale = "0.9"
                  caption = "Anzeige der per XSLT-Skript generierten HTML-Seite."/>

Läßt man sich vom Browser hingegen den Quelltest der Seite anzeigen,
so wird kein HTML-Code angezeigt sondern der XML-Code.</example></subsubsection><subsubsection titel = "Auswahl von Teildokumenten">
Das Element <tt>xsl:apply-templates</tt> veranlasst den XSLT-Prozessor
die Elemente des XML Ausgangsdokuments weiter mit dem XSL Stylesheet
zu bearbeiten. Wenn dieses Element kein Attribut hat, wie in unseren
bisherigen Beispielen, dann werden alle Kinder berücksichtigt. Mit dem
Attribut <tt>select</tt> lassen sich bestimmte Kinder selektieren, die
in der Folge nur noch betrachtet werden sollen.<example>
Im folgenden XSL Element selektieren wir für <tt>cd</tt>-Elemente nur
die <tt>title</tt> und <tt>artist</tt> Kinder und ignorieren 
die <tt>label</tt> Kinder.<code commandchars = "_~^">
&lt;!-- für das Element &quot;cd&quot; --&gt;
&lt;xsl:template match=&quot;cd&quot;&gt;
 &lt;!--erzeuge ein Element &quot;tr&quot; --&gt;
 &lt;tr&gt;
   &lt;!-- wende das stylesheet weiter an auf die Kinderelemente
   &quot;title&quot; --&gt;
   &lt;xsl:apply-templates select=&quot;title&quot;/&gt;
   &lt;!-- wende das stylesheet weiter an auf die Kinderelemente
   &quot;artist&quot; --&gt;
   &lt;xsl:apply-templates select=&quot;artist&quot;/&gt;
 &lt;/tr&gt;
&lt;/xsl:template&gt;</code></example></subsubsection><subsubsection titel = "Sortieren von Dokumentteilen">
XSLT kennt ein Konstrukt, um zu beschreiben, daß bestimmte Dokumente
sortiert werden sollen nach bestimmten Kriterien. Hierzu gibt es das
XSLT-Element <tt>xsl:sort</tt>. In einem Attribut <tt>select</tt> wird

angegeben, nach welchen Elementteil sortiert werden soll.<example>Zum Sortieren der CD-Liste kann mit <tt>xsl:sort</tt> das
Unterelement <tt>artist</tt> als Sortierschlüssel bestimmt werden.<code commandchars = "_~^">&lt;xsl:template match=&quot;cds&quot;&gt;
  &lt;table border=&quot;1&quot;&gt;
    &lt;tr&gt;&lt;td&gt;&lt;b&gt;Interpret&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;Titel&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;xsl:apply-templates select=&quot;cd&quot;&gt;
      &lt;xsl:sort select=&quot;artist&quot;/&gt; 
    &lt;/xsl:apply-templates&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</code></example></subsubsection><subsubsection titel = "Weitere Konstrukte">
XSLT kennt noch viele weitere Konstrukte, so z.B.<white/>für
bedingte Ausdrücke wie in herkömmlichen Programmiersprachen durch 
einen <b>if</b>-Befehl und explizite Schleifenkonstrukte,
Möglichkeiten das Ausgangsdokument, mehrfach verschiedentlich zu
durchlaufen, und bei einem Element nicht nur auf Grund seines
Elementnamens zu reagieren, sondern auch seine Kontext im Dokument zu
berücksichtigen. Der interessierte Leser sei auf eines der vielen
Tutorials im Netz oder auf die Empfehlung des W3C verwiesen.</subsubsection><subsubsection titel = "XSLT in Java">
          <code class = "XSLT"
                package = "name/panitz/xml/xslt">package name.panitz.xml.xslt;

import org.w3c.dom.Node;

import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.TransformerException; 

import java.io.StringWriter; 
import java.io.File ;

public class XSLT {
  static public String transform(File xslt,File doc){
    return transform(new StreamSource(doc),new StreamSource(doc));
  }

  static public String transform(Source xslt,Source doc){
    try{
      StringWriter writer = new StringWriter();
      Transformer t =
         TransformerFactory
          .newInstance()
          .newTransformer(xslt);
      t.transform(doc,new StreamResult(writer));
      return writer.getBuffer().toString();
    }catch (TransformerException _){
      return &quot;&quot;;
    }
  }

  public static void main(String [] args)throws Exception {
    System.out.println(transform(new File(args[0]),new File(args[1])));
  }

}</code>
        </subsubsection></subsection><subsection titel = "XQuery: Anfragen">
        <code class = "fac"
              lang = "xquery">declare function fac($n) {if ($n=0) then 1 else $n*fac($n - 1)};
fac(5)</code>
        <code class = "htmlfac"
              lang = "xquery">declare function fac($n) {if ($n=0) then 1 else $n*fac($n - 1)};

&lt;html&gt;&lt;body&gt;fac(5)={fac(5)}&lt;/body&gt;&lt;/html&gt;</code>
        <code class = "countKapitel"
              lang = "xquery">count(doc(&quot;/home/sep/fh/prog4/skript.xml&quot;)//kapitel)</code>
        <code class = "countCode"
              lang = "xquery">let $name := distinct-values
                (doc(&quot;/home/sep/fh/prog4/skript.xml&quot;)//code/@class)
return count($name)</code>
        <code class = "exampleProgs1"
              lang = "xquery">&lt;ul&gt;{
for $name in distinct-values(doc(&quot;/home/sep/fh/prog4/skript.xml&quot;)//code/@class)
return &lt;li&gt;
         {string($name)}
       &lt;/li&gt;
}&lt;/ul&gt;</code>
        <code class = "exampleProgs2"
              lang = "xquery">&lt;ul&gt;{
for $name in distinct-values(doc(&quot;/home/sep/fh/prog4/skript.xml&quot;)//code/@class)
order by $name
return &lt;li&gt;
         {string($name)}
       &lt;/li&gt;
}&lt;/ul&gt;</code>
        <code class = "exampleProgs"
              lang = "xquery">&lt;html&gt;
&lt;title&gt;Klassen aus dem Skript&lt;/title&gt;
&lt;body&gt;
&lt;ul&gt;{
let $codeFrags := doc(&quot;/home/sep/fh/prog4/skript.xml&quot;)//code[@class]
let 
 $codes := 
   for $name in distinct-values($codeFrags/@class)
   let $codeFrag := $codeFrags[@class=$name][1]
   return 
     &lt;code&gt;
        &lt;className&gt;{string($codeFrag/@class)}&lt;/classname&gt;
        &lt;lang&gt;{if ($codeFrag/@lang) 
               then string($codeFrag/@lang) 
               else &quot;java&quot;}&lt;/lang&gt;
        &lt;package&gt;{if ($codeFrag/@package) 
                  then string($codeFrag/@package) 
                  else &quot;.&quot;}&lt;/package&gt;
     &lt;/code&gt;
for $code in $codes
order by $code/className
return 
  let $name:= ($code/className/text(),&quot;.&quot;,$code/lang/text())
  let $fullname:= ($code/package/text(),&quot;/&quot;,$name)
  return
    &lt;li&gt;&lt;a&gt;{attribute href {$fullname}}{$name}&lt;/a&gt;&lt;/li&gt;
}&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code>
      </subsection></section><section titel = "Dokumenttypen">
Wir haben bereits verschiedene Typen von XML-Dokumenten kennengelernt:
XHTML-, XSLT-  und SVG-Dokumente. Solche Typen von XML-Dokumenten
sind dadurch gekennzeichnet,
daß sie gültige XML-Dokumente sind, in denen nur bestimmte
vordefinierte Tagnamen vorkommen und das auch nur in einer bestimmten
Reihenfolge. Solche Typen von XML-Dokumenten können mit einer
Typbeschreibungssprache definiert werden. Für XML gibt es zwei solcher
Typbeschreibungssprachen: DTD und Schema.<subsection titel = "DTD">
DTD <em>(document type description)</em> ermöglicht es zu formulieren,
welche Tags in einem Dokument vorkommen sollen. DTD ist keine eigens
für XML erfundene Sprache, sondern aus SGML geerbt.<p/>

DTD-Dokumente sind keine XML-Dokumente, sondern haben eine eigene
Syntax. Wir stellen im einzelnen diese Syntax vor:
 <itemize>
          <item><ttt>&lt;!DOCTYPE <em>root-element</em> [ <em>doctype-declaration</em>... ]&gt;</ttt><br/>
  Legt den Namen des top-level Elements fest und enthält die gesammte
  Definition des erlaubten Inhalts.</item>
          <item><ttt>&lt;!ELEMENT <em>element-name</em><white/><em>content-model</em>&gt;</ttt><br/>
  assoziiert einen <em>content model</em> mit allen Elementen, die
  diesen Namen haben.
  <p/><em>content models</em> können wie folgt gebildet werden.: 
  <itemize>
              <item><tt>EMPTY</tt>: Das Element hat keinen Inhalt.</item>
              <item><tt>ANY</tt>: Das Element hat einen beliebigen Inhalt</item>
              <item><tt>#PCDATA</tt>: Zeichenkette, also der eigentliche Text.
  <item>durch einen regulären Ausdruck, der aus den folgenden
  Komponenten gebildet werden kann.</item><itemize>
                  <item> Auswahl von Alternativen (oder): <tt>(...|...|...)</tt></item>
                  <item> Sequenz von Ausdrücken: <tt>(...,...,...)</tt></item>
                  <item> Option: <tt>...?</tt></item>
                  <item> Ein bis mehrfach Wiederholung: <tt>...*</tt></item>
                  <item> Null bis mehrfache Wiederholung: <tt>...+</tt></item>
                </itemize></item>
            </itemize></item>
          <item><ttt>&lt;!ATTLIST<em>element-name</em><white/><em>attr-name</em><white/><em>attr-type</em><white/><em>attr-default</em> ...&gt;</ttt><br/>
Liste, die definiert, was für Attribute ein Element hat:
  <p/>
  Attribute werden definiert durch:
  <itemize>
              <item><tt>CDATA</tt>: beliebiger Text ist erlaubt</item>
              <item><ttt>(<em>value</em>|...)</ttt>: Aufzählung erlaubter Werte</item>
            </itemize><p/>
  Attribut <em>default</em> sind:
  <itemize>
              <item><tt>#REQUIRED</tt>: Das Attribut muß immer vorhanden sein.</item>
              <item><tt>#IMPLIED</tt>: Das Attribut ist optional</item>
              <item><tt>&quot;value&quot;</tt>: Standardwert, wenn das Attribut fehlt.</item>
              <item><tt>#FIXED &quot;value&quot;</tt>: Attribut kennt nur diesen Wert.</item>
            </itemize></item>
        </itemize><beispiel>Ein Beispiel für eine DTD, die ein Format für eine
Rezeptsammlung definiert.<code commandchars = "_~^">&lt;!DOCTYPE collection SYSTEM &quot;collection.dtd&quot; [
&lt;!ELEMENT collection (description,recipe*)&gt;

&lt;!ELEMENT description ANY&gt;

&lt;!ELEMENT recipe (title,ingredient*,preparation
                 ,comment?,nutrition)&gt;

&lt;!ELEMENT title (#PCDATA)&gt;

&lt;!ELEMENT ingredient (ingredient*,preparation)?&gt;
&lt;!ATTLIST ingredient name CDATA #REQUIRED
                     amount CDATA #IMPLIED
                     unit CDATA #IMPLIED&gt;

&lt;!ELEMENT preparation (step)*&gt;

&lt;!ELEMENT step (#PCDATA)&gt;

&lt;!ELEMENT comment (#PCDATA)&gt;

&lt;!ELEMENT nutrition EMPTY&gt;
&lt;!ATTLIST nutrition fat CDATA #REQUIRED
                    calories CDATA #REQUIRED
                    alcohol CDATA #IMPLIED&gt;]&gt;</code></beispiel><aufgabe>Schreiben Sie ein XML Dokument, daß nach den Regeln der
obigen DTD gebildet wird.</aufgabe></subsection><subsection titel = "Schema">
Daß DTDs keine XML-Dokumente sind, hat die Erfinder von XML im
Nachhinein recht geärgert. Außerdem war für die vorgesehen Zwecke im
Bereich Datenverwaltung mit XML, die Ausdrucksstärke von DTD zum
Beschreiben der Dokumenttypen nicht mehr ausdruckstark genug. Es läßt
sich z.B.<white/> nicht formulieren, daß ein Attribut nur
Zahlen als Wert haben darf. Aus diesen Gründen wurde eine
Arbeitsgruppe ins Leben gerufen, die einen neuen Standard definieren
sollte, der DTDs langfristig ersetzen kann. Die neue Sprache sollte in
XML Syntax notiert werden und die bei DTDs vermissten Ausdrucksmittel
beinhalten. Diese neue Typbneschreibungssprache heißt Schema und ist
mitlerweile im W3C verabredet worden. Leider ist das endgültige
Dokument über Schema recht komplex und oft schwer verständlich
geworden. Wir wollen in dieser Vorlesung nicht näher auf Schema
eingehen. </subsection><subsection titel = "Geläufige Dokumenttypen"><subsubsection titel = "XHTML"/><subsubsection titel = "SVG"/>
Wir haben bisher XML-Dokumente geschrieben, um einen Dokumenttext zu
strukturieren. Die Strukturierungsmöglichkeiten von XML machen es zu
einem geeigneten Format, um beliebige Strukturen von Daten zu
beschreiben. Eine gängige Form von Daten sind Graphiken. 
SVG <em>(scalable vector graphics)</em> sind XML-Dokumente, die
graphische Elemente beschreiben. Zusätzlich kann in SVG ausgedrückt
werden, ob und in welcher Weise Graphiken animiert sind.<p/>

SVG-Dokumente sind XML-Dokumente mit bestimmten festgelegten
Tagnamen. Auch SVG ist dabei ein Standard, der vom W3C definiert wird.   <example>Folgendes kleine SVG-Dokument definiert eine Graphik, die
einen Kreis, ein Viereck und einen Text enthält. <code commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;
 &lt;ellipse cx=&quot;100&quot; cy=&quot;100&quot; rx=&quot;48&quot; ry=&quot;90&quot; fill=&quot;limegreen&quot; /&gt;
 &lt;text x=&quot;20&quot; y=&quot;115&quot;&gt;SVG Textobjekt&lt;/text&gt;
 &lt;rect x=&quot;50&quot; y=&quot;50&quot; width=&quot;50&quot; height=&quot;60&quot; fill=&quot;red&quot;/&gt;
&lt;/svg&gt;</code></example>

Für ausführliche Informationen über die in SVG zur Verfügung stehenden
Elemente sei der interessierte Student auf eines der vielen Tutorials
im Netz oder direkt auf die Seiten des W3C verwiesen.</subsection></section><section titel = "Aufgaben">
      <aufgabe>
Die folgenden Dokumente sind kein wohlgeformetes XML. Begründen Sie, wo
der Fehler liegt, und wie dieser Fehler behoben werden kann.<unteraufgaben>
          <teil>
            <code>&lt;a&gt;to be &lt;/a&gt;&lt;b&gt; or not to be&lt;/b&gt;</code>
          </teil>
          <loesung>Kein top-level Element, das das ganze Dokument umschließt.</loesung>
          <teil>
            <code>&lt;person geburtsjahr=1767&gt;Ferdinand Carulli&lt;/person&gt;</code>
            <loesung>Attributwerte müssen in Anführungszeichen stehen.</loesung>
          </teil>
          <teil>
            <code>&lt;line&gt;lebt wohl&lt;br/&gt;
&lt;b&gt;Gott weiß, wann wir uns wiedersehen&lt;/line&gt;</code>
            <loesung><tt>&lt;b&gt;</tt> wird nicht geschlossen.</loesung>
          </teil>
          <teil>
            <code>&lt;kockrezept&gt;&lt;!--habe ich aus dem Netz
  &lt;name&gt;Saltimbocca&lt;/name&gt;
  &lt;zubereitung&gt;Zutaten aufeinanderlegen 
               und braten.&lt;/zubereitung&gt;
&lt;/kockrezept&gt;</code>
            <loesung>Kommentar wird nicht geschlossen.</loesung>
          </teil>
          <teil>
            <code commandchars = "_~^">&lt;cd&gt;
  &lt;artist&gt;dead&amp;alive&lt;/artist&gt;
  &lt;title&gt;you spin me round&lt;/title&gt;&lt;/cd&gt;</code>
            <loesung>Das Zeichen <latex>\<amp/></latex> muß als character 
entity <tt>&amp;amp;</tt> geschrieben werden.</loesung>
          </teil>
        </unteraufgaben></aufgabe>
      <aufgabe>
Gegeben sind das folgende XML-Dokument:<code class = "TheaterAutoren"
              lang = "xml"
              package = "name/panitz/xml/exercise"
              commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;autoren&gt;
&lt;autor&gt;
  &lt;person&gt;
    &lt;nachname&gt;Shakespeare&lt;/nachname&gt;
    &lt;vorname&gt;William&lt;/vorname&gt;
  &lt;/person&gt;
  &lt;werke&gt;
    &lt;opus&gt;Hamlet&lt;/opus&gt;
    &lt;opus&gt;Macbeth&lt;/opus&gt;
    &lt;opus&gt;King Lear&lt;/opus&gt;
  &lt;/werke&gt;
&lt;/autor&gt;
&lt;autor&gt;
  &lt;person&gt;
    &lt;nachname&gt;Kane&lt;/nachname&gt;
    &lt;vorname&gt;Sarah&lt;/vorname&gt;
  &lt;/person&gt;
  &lt;werke&gt;
    &lt;opus&gt;Gesäubert&lt;/opus&gt;
    &lt;opus&gt;Psychose 4.48&lt;/opus&gt;
    &lt;opus&gt;Gier&lt;/opus&gt;
  &lt;/werke&gt;
&lt;/autor&gt;
&lt;/autoren&gt;</code><unteraufgaben>
          <teil>Schreiben Sie eine DTD, das die Struktur dieses 
Dokuments beschreibt.<loesung>
              <code class = "AutorenType"
                    lang = "dtd"
                    package = "name/panitz/xml/exercise">&lt;!DOCTYPE autoren SYSTEM &quot;AutorenType.dtd&quot; [
&lt;!ELEMENT autoren (autor+)&gt;
&lt;!ELEMENT autor (person,werke)&gt;
&lt;!ELEMENT werke (opus*)&gt;
&lt;!ELEMENT opus (#PCDATA)&gt;
&lt;!ELEMENT person (nachname,vorname)&gt;
&lt;!ELEMENT nachname (#PCDATA)&gt;
&lt;!ELEMENT vorname (#PCDATA)&gt;]&gt;</code>
            </loesung></teil>
          <teil>Entwerfen Sie Java Schnittstellen, die Objekte ihrer DTD beschreiben.<loesung>
              <code class = "Autoren"
                    package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
import java.util.List;
public interface Autoren {
  List&lt;Autor&gt; getAutorList();
}</code>
              <code class = "Autor"
                    package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
public interface Autor {
  Person getPerson();
  Werke  getWerke();
}</code>
              <code class = "Person"
                    package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
public interface Person {
  Nachname getNachname();
  Vorname  getVorname();
}</code>
              <code class = "Werke"
                    package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
import java.util.List;
public interface Werke {
  List&lt;Opus&gt; getOpusList();
}</code>
              <code class = "HasJustTextChild"
                    package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
public interface HasJustTextChild {
  String getText();
}</code>
              <code class = "Opus"
                    package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
public interface Opus extends HasJustTextChild {}</code>
              <code class = "Nachname"
                    package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
public interface Nachname extends HasJustTextChild {}</code>
              <code class = "Vorname"
                    package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
public interface Vorname extends HasJustTextChild {}</code>
            </loesung></teil>
          <teil>Schreiben Sie ein XSLT-Skript, das obige Dokument in eine Html Liste 
der Werke ohne Autorangabe  transformiert.<loesung>
              <code class = "WerkeListe"
                    lang = "xsl"
                    package = "name/panitz/xml/exercise">&lt;xsl:stylesheet version=&quot;1.0&quot;
                xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;

  &lt;xsl:template match=&quot;/&quot;&gt;
     &lt;html&gt;&lt;head&gt;&lt;title&gt;Werke&lt;/title&gt;&lt;/head&gt;
       &lt;body&gt;&lt;xsl:apply-templates /&gt;&lt;/body&gt;
     &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match=&quot;autoren&quot;&gt;
     &lt;ul&gt;&lt;xsl:apply-templates select=&quot;autor/werke/opus&quot;/&gt;&lt;/ul&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match=&quot;opus&quot;&gt;
     &lt;li&gt;&lt;xsl:apply-templates/&gt;&lt;/li&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code>
            </loesung></teil>
          <teil>Schreiben Sie eine Javamethode<br/><tt>List&lt;String&gt; getWerkListe(Autoren autoren);</tt>,<br/> die auf den Objekten Ihrer Schnittstelle
  für <tt>Autoren</tt> eine Liste von Werknamen erzeugt.<loesung>
              <code class = "GetWerke"
                    package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
import java.util.List;
import java.util.ArrayList;

public class GetWerke{
  public List&lt;String&gt; getWerkListe(Autoren autoren){
    List&lt;String&gt; result = new ArrayList&lt;String&gt;();
    for (Autor a:autoren.getAutorList()){
      for (Opus opus: a.getWerke().getOpusList())
        result.add(opus.getText());
    }
    return result;
  }
}</code>
            </loesung></teil>
        </unteraufgaben></aufgabe>
      <aufgabe>Gegeben sei folgendes XML-Dokument:<code class = "Foo"
              lang = "xml"
              package = "name/panitz/xml/exercise"
              commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;x1&gt;&lt;x2&gt;&lt;x5&gt;5&lt;/x5&gt;&lt;x6&gt;6&lt;/x6&gt;&lt;/x2&gt;&lt;x3&gt;&lt;x7&gt;7&lt;/x7&gt;&lt;/x3&gt;
&lt;x4&gt;&lt;x8/&gt;&lt;x9&gt;&lt;x10&gt;&lt;x11&gt;&lt;/x11&gt;&lt;/x10&gt;&lt;/x9&gt;&lt;/x4&gt;&lt;/x1&gt;</code><unteraufgaben>
          <teil>Zeichnen Sie dieses Dokument als Baum.</teil>
          <teil>Welche Dokumente selektieren, die folgenden XPath-Ausdrücke ausgehend
  von der Wurzel dieses Dokuments<itemize>
              <item>
                <tt>//x5/x6</tt>
              </item>
              <item>
                <tt>/descendant-or-self::x5/..</tt>
              </item>
              <item>//x5/ancestor::*</item>
              <item>/x1/x2/following-sibling::*</item>
              <item>/descendant-or-self::text()/parent::node()</item>
            </itemize></teil>
        </unteraufgaben></aufgabe>
      <aufgabe>Schreiben Sie eine Methode<br/><tt>List&lt;Node&gt; getLeaves(Node n);</tt>,<br/> 
die für einen DOM Knoten, die Liste aller seiner Blätter zurückgibt.<loesung>
          <code class = "GetLeaves"
                package = "name/panitz/xml/exercise">package name.panitz.xml.exercise;
import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.*;

public class GetLeaves{
  public List&lt;Node&gt; getLeaves(Node n){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    NodeList ns = n.getChildNodes();
    if (ns.getLength()==0){
      result.add(n); return result;
    }
    for (int i=0;i&lt;ns.getLength();i++){
      result.addAll(getLeaves(ns.item(i)));
    }
    return result;
  }
}</code>
        </loesung></aufgabe>
    </section></kapitel>
  <kapitel titel = "Steuerfäden">
Bisher sind wir nur in der Lage, Programme zu beschreiben, deren
Abarbeitung streng sequentiell nacheinander im Programmtext festgelegt
ist. Insbesondere wenn man graphische Komponenten programmiert, möchte
man Progammteile haben, die nebeneinander her arbeiten. In zwei
Fenstern können graphisch animierte Objekte stehen, und wir wollen
nicht, daß erst das eine und dann, wenn dieses beendet ist, das andere
Fenster seine Animation spielt.<p/>
Trotzdem sollen die beiden Fenster nicht zu unterschiedlichen
Programmen gehören, sondern Bestandteil eines Programms sein, und auch
in der Lage sein, mit denselben Objekten zu arbeiten. <p/>
Um nebenläufige Programmteile zu programmieren, stellt Java das
Konzept der Steuerfäden zur Verfügung. Steuerfäden sind zu
unterscheiden von Prozessen im Betriebssystem. Die Prozesse eines
Betriebssystems haben eine eigene Speicherumgebung, während die
Steuerfäden in Java, alle in derselben virtuellen Maschine laufen und
sich einen Speichbereich für ihre Daten teilen und sich darin auch
Daten teilen können.<section titel = "Schreiben von Steuerfäden">
Es gibt zwei Arten, wie in Java Steuerfäden umgesetzt werden können:<itemize>
        <item>Durch Ableiten von der Klasse <tt>Thread</tt> und
überschreiben der Methode <tt>run</tt>.</item>
        <item>Durch Implementierung der Schnittstelle <tt>Runnable</tt>, die
Methode <tt>run</tt> enthält.</item>
      </itemize>

In der Regel wird man die Klasse <tt>Thread</tt> überschreiben und nur
die Schnittstelle <tt>Runnable</tt> selbst implementieren, wenn das
Verbot der mehrfachen Erbung, verhindert, daß von der 
Klasse <tt>Thread</tt> abgelitten werden kann.<p/>
Java vergibt bei der Erzeugung eines Steuerfadens jedem Steuerfaden
einen Namen, der mit der Methode <tt>getName()</tt> abgefragt werden
kann. Dieser Name kann aber auch im Konstruktor gesetzt werden.<p/>
Für ein Objekt der Klasse <tt>Thread</tt> kann nach seiner Erzeugung
die Methode <tt>start()</tt> aufgerufen werden, die dafür sorgt, daß
der Code der Methode <tt>run()</tt> ausgeführt wird. Wurden mehrere
Steuerfäden gestartet, so wird Java mehr oder weniger zufällig dafür sorgen, daß beide Steuerfäden Gelegenheit bekommen, 
ihre <tt>run</tt>-Methode auszuführen. Es gibt keinerlei Garantie
dafür, wie fair und in welcher Weise Java dafür sorgt, daß alle
Steuerfäden ihre Methode <tt>run</tt> ausführen können. Insbesondere können Programme, die Steuerfäden benutzen, auf unterschiedlichen
Betriebssystem ganz unterschiedliche Verhalten aufweisen.<example>Folgendes Programm definiert einen simplen Steuerfaden, der unendlich oft seinen Namen auf den Bildschirm ausgibt.  In 
der <tt>main</tt>-Methode werden zwei Instanzen dieses Steuerfadens
erzeugt und gestartet. Anhand der Ausgabe des Programms kann verfolgt werden, wie Java zwischen den zwei Steuerfäden umschaltet:<code lang = "java"
              class = "SimpleThread">class SimpleThread extends Thread { 

  public void run(){
    while (true){
      System.out.print(getName());
    }
  }

  public static void main(String [] args){
    new SimpleThread().start();
    new SimpleThread().start();
  }
}</code></example><subsection titel = "Schlafenlegen von Prozessen">
In der Klasse <tt>Thread</tt> gibt es eine statische 
Methode <tt>void sleep(long millis)</tt>. Der Aufruf dieser Methode bewirkt, daß der aktuell laufende Steuerfaden entsprechend seines
Parameters für einen bestimmten Zeitraum nicht weiterarbeitet.
Die Einheit für den Parameter sind tausendstel Sekunden.<example>
Unseren ersten Steuerfaden aus dem letzten Beispiel erweitern wir jetzt
darum, daß er sich jeweils eine bestimmte Zeit zur Ruhe legt, nachdem er seinen Namen ausgedruckt hat: <code lang = "java"
                class = "SleepingThread">class SleepingThread extends Thread {
  public SleepingThread(int s){this.s=s;}
  private int s; 

  public void run(){
    while (true){
      System.out.print(getName());
      try {Thread.sleep(s);}catch (InterruptedException _){}
    }
  }

  public static void main(String [] args){
    new SleepingThread(1000).start();
    new SleepingThread(300).start();
  }
}</code>
Wenn das Programm läuft, sieht man, daß der Steuerfaden, der kürzer schläft, häufiger seinen Namen ausgibt: <scode>sep@swe10:~/fh/internal/beispiele&gt; java SleepingThread
Thread-1Thread-0Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1
Thread-0Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-1
Thread-0Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-0
Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-1Thread-0
Thread-1Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-0Thread-1
Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-1Thread-0Thread-1
Thread-1Thread-1Thread-0Thread-1Thread-1Thread-1Thread-0
sep@swe10:~/fh/internal/beispiele&gt;
</scode></example>
Man beachte, daß die Methode <tt>sleep</tt> eine statische Methode und
keine Objektmethode für die Klasse <tt>Thread</tt> ist. Sie wird also nicht auf den Steuerfadenobjekten ausgeführt, sondern global und gilt für den gerade aktiven Steuerfaden. Das wird dann jeweils der
Steuerfaden sein, in dessen <tt>run</tt>-Methode der Aufruf 
von <tt>sleep</tt> steht.</subsection></section><section titel = "Koordination nebenläufiger Steuerfäden">
Wenn zwei Steuerfäden sich  Daten teilen, dann kann es zu Problemen kommen.<subsection titel = "Benutzung gemeinsamer Objekte">
Wir schreiben ein kleines Objekt, das zwei Zahlen enthält und eine
Methode <tt>swap</tt>, die die beiden Zahlen in dem Objekt vertauscht. Wir machen die Methode <tt>swap</tt> durch 
eine <tt>sleep</tt>-Anweisung künstlich langsam:<code lang = "java"
              class = "TwoNumbers">class TwoNumbers{
   int x;
   int y;

   TwoNumbers(int x, int y) {this.x=x; this.y=y;}

   void swap(){
     int z=x;
     x=y;
     try {Thread.sleep(100);}catch (InterruptedException _){}
     y=z;
   }

   public String toString(){return &quot;(&quot;+x+&quot;,&quot;+y+&quot;)&quot;;}
}</code>
Jetzt können wir zwei Steuerfäden schreiben. Der eine ruft immer wieder
die Methode <tt>swap</tt> auf ein <tt>TwoNumbers</tt>-Objekt auf:<code lang = "java"
              class = "Swap">class Swap extends Thread{

  public Swap(TwoNumbers twoN){this.twoN=twoN;}

  private TwoNumbers twoN;

  public void run(){
    while (true){twoN.swap();}
  }
}</code>
Der andere druckt immer wieder ein  <tt>TwoNumbers</tt>-Objekt aus:<code lang = "java"
              class = "PrintTwoNumbers">class PrintTwoNumbers extends Thread {
  public PrintTwoNumbers(TwoNumbers twoN){this.twoN=twoN;}

  private TwoNumbers twoN;

  public void run(){
    while (true){
      System.out.println(twoN);
      try {Thread.sleep(1000);}catch (InterruptedException _){}
    }
  }

  public static void main(String [] _){
    TwoNumbers twoN = new TwoNumbers(1,2);
    new Swap(twoN).start();
    new PrintTwoNumbers(twoN).start();
  }
}</code>
Wenn wir dieses Programm starten, dann sehen wir, daß wir so gut wie
nie die beiden Zahlen ausdrucken, sondern immer ein Paar zwei gleicher
    Zahlen:<scode>sep@swe10:~/fh/internal/beispiele&gt; java PrintTwoNumbers
(1,2)
(1,1)
(2,2)
(1,1)
(2,2)
(1,1)
(1,1)
(2,2)
(1,1)
(2,2)
(1,1)
(1,1)
(2,2)

sep@swe10:~/fh/internal/beispiele&gt;</scode> 
Hier wird das Objekt der Klasse <tt>TwoNumbers</tt> immer nur ausgedruckt, wenn es inmitten  der Ausführung der 
Methode <tt>swap</tt> ist. In diesem Zwischenzustand sind gerade im
Zuge des Vertauschungsprozesses beide Zahlen gleich. Will man
verhindern, daß andere Steuerfäden einen Zwischenstand einer Operation sehen, also das Objekt in einem Zustand, den es eigentlich nicht haben soll, so kann man in Java das Mittel der Synchronisation anwenden.</subsection><subsection titel = "Synchronisation">
Um bestimmte Programmteile für Steuerfäden zu reservieren, können
diese Programmteile synchronisiert werden.<subsubsection titel = "Synchronisation von Methoden">
Java kennt für Methoden das zusätzliche 
Attribut <tt>synchronized</tt>. Wenn eine Methode das 
Attribut <tt>synchronized</tt> hat, bedeutet das, daß  für ein
bestimmtes Objekt von der Klasse, in der die Methode ist, immer nur
genau einmal zur Zeit eine synchronisierte Methode ausgeführt werden
darf. Soll gerade eine zweite synchronisierte Methode ausgeführt
werden, so muß diese warten, bis der andere Aufruf der
synchronisierten Methode beendet ist. Wollen wir den obigen Effekt in
der Klasse <tt>TwoNumbers</tt> verhindern, nämlich daß die 
Methode <tt>toString</tt> einen temporären Zwischenzustand der 
Methode  <tt>swap</tt> sieht, so können wir die beiden Methoden
synchronisieren. Wir erhalten die folgende Klasse:<code lang = "java"
                class = "SafeTwoNumbers">class SafeTwoNumbers{
  int x;
  int y;

  SafeTwoNumbers(int x, int y) {this.x=x; this.y=y;}

  <redv>synchronized</redv> void swap(){
    int z=x;
    x=y;
    try {Thread.sleep(400);}catch (InterruptedException _){}
    y=z;
  }

  <redv>synchronized</redv> public String toString(){
    return &quot;(&quot;+x+&quot;,&quot;+y+&quot;)&quot;;
  }
}</code>
Wenn wir jetzt das Programm <tt>PrintTwoNumbers</tt> so abändern, daß
    es die synchronisierten Objekte des 
Typs <tt>SafeTwoNumbers</tt> benutzt, so drucken wir tatsächlich immer Objekte, in denen beide Zahlen unterschiedlich sind:<scode>sep@swe10:~/fh/internal/beispiele&gt; java PrintTwoNumbers
(1,2)
(2,1)
(1,2)
(2,1)
(1,2)
(2,1)
(1,2)
(2,1)

sep@swe10:~/fh/internal/beispiele&gt;</scode></subsubsection><subsubsection titel = "Synchronisation von Blöcken">
Java bietet zusätzlich an, daß nicht ganze Methoden, sondern nur
bestimmte Programmsegmente als zu synchronisierender Abschnitt zu
markieren sind. Solche Blöcke von Anweisungen werden hierzu in geschweifte Klammern gesetzt. Zusätzlich ist noch anzugeben, über
welches Objekt synchronisiert wird. Insgesamt hat 
eine <tt>synchronized</tt>-Anweisung die folgende syntaktische Form:<center>
            <fbox>
              <ttt>synchronized (</ttt>
              <em>obj</em>
              <ttt>)<lpar/></ttt>
              <em>stats</em>
              <ttt>
                <rpar/>
              </ttt>
            </fbox>
          </center>

Statt also die Synchronisation an den Methoden vorzunehmen, können wir auch erst bei ihrem Aufruf verlangen, daß dieser synchronisiert ist.<p/>
Hierzu synchronisieren wir über das Objekt <tt>twoN</tt> den Aufruf
der Methode <tt>swap</tt>:<code lang = "java"
                class = "SafeSwap">class SafeSwap extends Thread{

  public SafeSwap(TwoNumbers twoN){this.twoN=twoN;}

  private TwoNumbers twoN;

  public void run(){
    while (true){
      <redv>synchronized(twoN)</redv>{twoN.swap();}
    }
  }
}</code>
Und wir synchronisieren entsprechend auch den Aufruf, der dafür sorgt, daß das Objekt ausgedruckt wird: <code lang = "java"
                class = "SafePrintTwoNumbers">class SafePrintTwoNumbers extends Thread {
  public SafePrintTwoNumbers(TwoNumbers twoN){this.twoN=twoN;}

  private TwoNumbers twoN;

  public void run(){
    while (true){
      <redv>synchronized (twoN)</redv>{System.out.println(twoN);}
      try {Thread.sleep(1000);}catch (InterruptedException _){}
    }
  }

  public static void main(String [] _){
    TwoNumbers twoN = new TwoNumbers(1,2);
    new SafeSwap(twoN).start();
    new SafePrintTwoNumbers(twoN).start();
  }
}</code>
Auch in dieser Version drucken wir immer nur konsistente Zustände des
    Objekts <tt>twoN</tt>. Es wird kein temporärer Zwischenzustand der
    Methode <tt>swap</tt> ausgegeben.</subsubsection></subsection><subsection titel = "Verklemmungen"> Mit der Synchronisation von Operationen über verschiedene Objekte handelt man sich leider ein Problem ein, das unter dem Namen
Verklemmung (eng.<white/>deadlock)<footnote>Im Skript von Herrn 
Grude<cite label = "grudeProg1"/> findet sich die etwas drastischere deutsche Bezeichnung <em>tödliche  Umklammerung</em>.</footnote> bekannt ist. Wenn es zu einer Verklemmung in einem
Programm kommt, friert das Programm ein. Es rechnet nichts mehr,
sondern wartet intern darauf, daß andere Programmteile mit der
Berechnung eines kritischen Abschnitts fertig werden.<p/>
Damit es zu einer Verklemmung kommt, braucht es mindestens zwei Steuerfäden und zwei Objekte, über die diese Steuerfäden
synchronisieren. <subsubsection titel = "Verklemmung bei der Buchausleihe"> Es gibt eine schöne Analogie für Verklemmungen aus dem Alltag. Hierzu
denke man als Steuerfäden zwei Studenten (<em>Hans</em> und <em>Lisa</em>) 
und als Objekte zwei Bücher
in der Bibliothek (<em>Programmieren</em> und <em>Softwaretechnik</em>). 
Hans leiht sich das Buch Programmieren und Lisa das Buch
Softwaretechnik aus. Beide haben sich damit exklusiv je ein Objekt gesichert (es gibt nicht mehrere Exemplare des gleichen Buches in der Bibliothek.). Nun
steht im Buch Programmieren eine Referenz auf das Buch Softwaretechnik und umgekehrt. Um das Buch Programmieren zu Ende durchzustudieren, braucht Hans jetzt auch das Buch Softwaretechnik, und für Lisa gilt
das 
entsprechende umgekehrt. Beide wollen sich jetzt das andere Buch in
der Bibliothek ausleihen, stellen aber fest, daß es verliehen
ist. Jetzt warten sie darauf, daß es zurückgegeben wird. Beide geben
ihr Buch nicht zurück, weil sie ja mit beiden Büchern 
arbeiten wollen. Somit warten beide aufeinander. Dieses Phänomen nennt
man Verklemmung. </subsubsection> <subsubsection titel = "Das 5-Philosophenproblem">
Eine zweite Illustration von Verklemmungen ist das sogenannte  5-Philosophen-Problem. Fünf Philosophen sitzen um einen runden
Tisch. Zwischen ihnen liegen Gabeln. Ein Philosoph kann entweder
denken oder essen. Zum Essen braucht er zwei Gabeln, denken kann er
nur, wenn er keine Gabel in der Hand hat. Nun greifen sich die
Philosophen entweder Gabeln und essen oder lassen die Gabeln liegen
und denken. Problematisch wird es, wenn sich jeder Philosoph erst die
Gabel zu seiner Rechten greift, um dann festzustellen, daß auf der
linken Seite keine Gabel liegt. Wenn jetzt alle darauf warten, daß links wieder eine Gabel hingelegt wird, und die Gabel in ihrer rechten
Hand nicht zurückgeben, so kommt es zu einer Verklemmung. Keiner ißt
und keiner denkt.</subsubsection><subsubsection titel = "Verklemmung im Straßenverkehr">
Auch im Straßenverkehr kann man mitunter Verklemmungen
beobachten. Zwei in entgegengesetzte Richtung fahrende Autos fahren
auf eine Kreuzung zu und wollen dort beide links abbiegen. Sie fahren soweit in die Kreuzung ein, daß sie dem entgegenkommenden Fahrzeug
jeweils die Fläche auf der Fahrbahn, die es zum Linksabbiegen braucht,
blockieren. Beide warten jetzt darauf, daß der andere weiterfährt. Der
Verkehr steht.</subsubsection><subsubsection titel = "Verklemmung in Java"> Mit Steuerfäden und Synchronisation haben wir in Java die Mechanismen zur
Verfügung, die zu einer klassischen Verklemmung führen können. Wir
schreiben eine Steuerfadenklasse, in der es zwei Objekte gibt. In der
Methode <tt>run</tt> wird erst über das eine Objekt synchronisiert und
dann über das andere. Wir erzeugen in der Hauptmethode zwei Objekte dieser Steuerfadenklasse jeweils mit vertauschten Objekten:<code lang = "java"
                class = "Deadlock">class Deadlock extends Thread{

  Object a;
  Object b;

  Deadlock (Object a,Object b){this.a=a;this.b=b;}

  public void run(){
    <redv>synchronized (a)</redv>{
      System.out.println(
        getName()+&quot;jetzt habe ich das erste Objekt: &quot;+a);   
      try {Thread.sleep(1000);}catch (InterruptedException _){}
      <redv>synchronized (b)</redv>{
	  System.out.println(getName()+&quot;jetzt habe ich beide&quot;);   
      }
    }
  }

  public static void main(String [] _){
    String s1 = &quot;hallo&quot;;
    String s2 = &quot;welt&quot;;
    new Deadlock(s1,s2).start();
    new Deadlock(s2,s1).start();
  }
}</code>
Dieses Programm hat zur Folge, daß sich der erste Stuerfaden zunächst
    das Objekt <tt>s1</tt> reserviert und der zweite Steuerfaden das
    Objekt <tt>s2</tt> reserviert. Wenn sie jetzt  jeweils das
    andere Objekt anfordern, müssen sie darauf warten, bis der andere
    Steuerfaden dieses wieder frei gibt. Das Programm
    ist verklemmt, nichts geht mehr:<scode>sep@swe10:~/fh/internal/beispiele&gt; java Deadlock
Thread-0jetzt habe ich das erste Objekt: hallo
Thread-1jetzt habe ich das erste Objekt: welt

</scode></subsubsection></subsection><subsection titel = "Warten und Benachrichtigen">
Über die Synchronisation haben wir sichergestellt, daß bestimmte
Operationen nur ausgeführt werden, wenn man bestimmte Objekte exklusiv
hat. Falls ein anderer Steuerfaden dieses Objekt gesperrt hat, so muß
der Steuerfaden warten, bis das Objekt für ihn zur Verfügung steht.<p/>
Darüberhinaus kann es erwünscht sein, daß ein Steuerfaden warten soll,
bis ein anderer Steuerfaden bestimmte Operationen durchgeführt
hat. Hierzu gibt es in Java die 
Methoden <tt>wait</tt> und <tt>notifyAll</tt>.<p/>
Stellen wir uns vor, wir haben ein Objekt, in dem eine Zahl gespeichert wird. Es gibt eine Methode, diese Zahl zu setzen, und eine 
Methode, um diese auszulesen. Zwei Steuerfäden sollen über dieses
Objekt kommunizieren. Der eine schreibt immer Zahlen hinein, der
andere liest diese wieder aus. Nun soll der lesende Steuerfaden immer
erst so lange warten, bis der schreibende eine neue Zahl gespeichert hat, und der speichernde Steuerfaden soll immer so lange warten, bis der vorherige Wert ausgelesen wurde, damit er nicht überschrieben
wird. <p/>
Ohne Vorkehrungen dafür, daß abwechselnd gelesen und geschrieben wird,
sieht die Klasse wie folgt aus:<code lang = "java"
              class = "GetSet1">class GetSet1 {
  private int i;
  GetSet1(int i){this.i=i;}

  synchronized int get(){return i;}
  synchronized void set(int i){this.i=i;}
}</code>
Unsere beiden Steuerfäden, die auf einem solchen Objekt lesen und
  schreiben, können wir schreiben als:<code lang = "java"
              class = "Set">class Set extends Thread{
  GetSet1 o;
  Set(GetSet1 o){this.o=o;}
  public void run(){
    for (int i=1;i&lt;=1000;i=i+1){
      o.set(i);
    }
  }
}</code>
Der lesende Steuerfaden mit entsprechender Hauptmethode:<code lang = "java"
              class = "Get">class Get extends Thread{
  GetSet1 o;
  Get(GetSet1 o){this.o=o;}
  public void run(){
    for (int i=1;i&lt;=1000;i=i+1){
      System.out.print(o.get()+&quot; &quot;);
    }
  }

  public static void main(String [] _){
    GetSet1 gss = new GetSet1(0);
    new Get(gss).start();
    new Set(gss).start();
  }
}</code>
Starten wir dieses Programm, so werden nicht die Zahlen 0 bis 1000 auf
    dem Bildschirm ausgeben. Es ist nicht garantiert, daß erst nach
    einem Schreiben ein Lesen stattfindet. Wir können dieses durch
    einen internen Merker signalisieren, der angibt, ob eine neue Zahl
    verfügbar ist. Bevor wir eine neue Zahl lesen, können wir uns immer wieder schlafenlegen und dann schauen, ob jetzt die neue Zahl
    verfügbar ist:<code lang = "java"
              class = "GetSet2">class GetSet2 {
  private int i;
  private boolean available= true;
  GetSet2(int i){this.i=i;}

  synchronized int get(){
    while (!available){
      try{Thread.sleep(1000);}catch (Exception _){}
    }    
    available=false;
    return i;
  }

  synchronized void set(int i){
    while (available){
      try{Thread.sleep(1000);}catch (Exception _){}
    }
    this.i=i;
    available=true;
  }
}</code>
Starten wir damit unser Testprogramm, so kommt es zu einer
    Verklemmung. Um dieses zu umgehen, hat Java das Prinzip 
von <tt>wait</tt> und <tt>notifyAll</tt>. 
Statt <tt>sleep</tt> rufen wir die Methode <tt>wait</tt> auf und
erlauben damit anderen Steuerfäden, obwohl wir in einer
    synchronisierten Methode sind, auf demselben Objekt aktiv zu
    werden.  Die <tt>wait</tt>-Anweisung wird aufgehoben, wenn
    irgendwo eine <tt>notifyAll</tt>-Anweisung aufgerufen wird. Dann 
konkurrieren wieder alle Steuerfäden um die Objekte, über die sie
    synchronisieren. <p/>
Unser Programm sieht schließlich wie folgt aus:<code lang = "java"
              class = "GetSet3">class GetSet3 {
  private int i;
  private boolean available= true;
  GetSet3(int i){this.i=i;}

  synchronized int get(){
    while (!available){
      try{wait();}catch (Exception _){}
    }    
    available=false;
    notifyAll();
	 
    return i;
  }

  synchronized void set(int i){
    while (available){
      try{wait();}catch (Exception _){}
    }
    this.i=i;
    available=true;
    notifyAll();
  }
}</code>
Damit ist gewährleistet, daß tatsächlich nur abwechselnd gelesen und
    geschrieben wird. Wie man sieht, kann es relativ kompliziert
    werden, über synchronisierte Methoden und 
der <tt>wait</tt>-Anweisung zu programmieren, und Programme mit
    mehreren Steuerfäden, die untereinander kommunizieren, sind schwer
    auf Korrektheit zu prüfen.</subsection></section></kapitel>
  <kapitel titel = "Swing: Eine Bibliothek für graphische Oberflächen">
Die meisten Programme auf heutigen Rechnersystemen haben eine
graphische Benutzeroberfläche (GUI)<footnote>GUI ist die Abkürzung 
für <em>graphical user interface</em>. Entsprechend wäre GRABO eine 
Abkürzung für das deutsche <em>graphische Benutzeroberfläche</em>. Im
Skript von Herrn Grude wird dieser sehr schöne  Ausdruck für 
GUI verwendet.</footnote>. <p/>
Java stellt Klassen zur
Verfügung, mit denen graphische Objekte erzeugt und in ihrem Verhalten
instrumentalisiert werden können. Leider gibt es 
historisch gewachsen zwei Pakete in Java mit Klassen zur
GUI-Programmierung. Die beiden Pakete überschneiden sich in der
Funktionalität. <itemize>
      <item><tt>java.awt</tt>: Dieses ist das ältere Paket zur
GUI-Programmierung. Es enthält Klassen für viele graphische Objekte
(z.B.<white/>eine Klasse <tt>Button</tt>) und Unterpakete, 
zur Programmierung der Funktionalität der einzelnen
Komponenten. </item>
      <item><tt>javax.swing</tt>: Dieses neuere Paket ist noch universeller
und platformunabhängiger als das <tt>java.awt</tt>-Paket. Auch hier
finden sich Klassen für unterschiedliche GUI-Komponenten. Sie
entsprechen den Klassen aus dem Paket <ttt>java.awt</ttt>. Die Klassen
haben oft den gleichen Klassennamen wie in <tt>java.awt</tt> jedoch
mit einem <tt>J</tt> vorangestellt. So gibt es z.B.<white/>eine
Klasse <tt>JButton</tt>.</item>
    </itemize>

Ein fundamentaler Unterschied dieser beiden Pakete besteht in ihrer Behandlung
von Steuerfäden. Während das <tt>awt</tt>-Paket sicher in Bezug auf
Steuerfäden ist, können im <tt>swing</tt>-Paket Steuerfäden nicht ohne
zusätzlihe Absicherung benutzt werden.<p/>

Zu allem Unglück sind die beiden Pakete nicht ganz unabhängig. Man ist zwar
angehalten, sofern man sich für eine Implementierung seines Guis mit
den Paket <tt>javax.swing</tt> entschieden hat, nur die graphischen
Komponenten aus diesem Paket zu benutzen; die Klassen leiten aber von
Klassen des Pakets <tt>java.awt</tt> ab. Hinzu kommt, daß die
Ereignissklassen, die die Funktionalität graphischer Objekte
bestimmen, nur in <tt>java.awt</tt> existieren und nicht noch einmal
für <tt>javax.swing</tt> extra umgesetzt wurden.<p/>
Sind Sie verwirrt. Sie werden es hoffentlich nicht mehr sein, nachdem
Sie die Beispiele dieses Kapitels durchgespielt haben.<section titel = "Graphische Benutzeroberflächen">
Zur Programmierung eines GUIs bedarf es graphischer Objekte, einer
Möglichkeit, graphische Objekte zu gruppieren, und schließlich eine
Möglichkeit zu bestimmen, wie die Objekte auf bestimmte Ereignisse
reagieren (z.B.<white/>was passiert, wenn ein Knopf gedrückt
wird). Java kennt für diese Aufgaben jeweils eigene Klassen:<itemize>
        <item>Komponenten</item>
        <item>Ereignisbehandlung</item>
        <item>Layoutsteuerung</item>
      </itemize>


In den folgenden Abschnitten, werden wir an ausgewählten Beispielen
Klassen für diese drei wichtigen Schritte der GUI-Programmierung
kennenlernen.<subsection titel = "Graphische Komponenten">
Javas <tt>swing</tt>-Paket kennt drei Arten von Komponenten. <itemize>
          <item>Top-Level Komponenten</item>
          <item>Zwischenkomponenten</item>
          <item>Atomare Komponenten</item>
        </itemize>

Leider spiegelt sich diese Unterscheidung nicht in der
Ableitungshierarchie wider. Alle Komponenten leiten schließlich von
der Klasse <tt>java.awt.Component</tt> ab. Es gibt keine
Schnittmengen, die Beschreiben, daß bestimmte Komponenten atomar oder
top-level sind.<p/>
Komponenten können Unterkomponenten enthalten; ein Fenster kann
z.B.<white/>verschiedene Knöpfe und Textflächen als
Unterkomponenten enthalten.<subsubsection titel = "Top-Level Komponenten">
Eine top-level Komponenten ist ein GUI-Objekt, das weitere graphische
Objekte enthalten kann, selbst aber kein graphisches Objekt hat, in
dem es enthalten ist. Somit sind top-level Komponenten in der Regel
Fenster, die weitere Komponenten als Fensterinhalt haben.
Swing top-level Komponenten sind Fenster und
Dialogfenster. Hierfür stellt Swing entsprechende Klassen zur
Verfügung: <tt>JFrame, JDialog</tt><p/>
Eine weitere top-level Komponente steht für <em>Applets</em> zur
Verfügung: <tt>JApplet</tt>.<p/>
Graphische Komponenten haben Konstruktoren, mit denen sie erzeugt
werden. Für die Klasse <tt>JFrame</tt> existiert ein parameterloser
Konstruktor. <example>
Das minimalste GUI-Programm ist wahrscheinlich folgendes
Programm, das ein Fensterobjekt erzeugt und dieses sichtbar macht.<code lang = "java"
                  class = "Window1"
                  package = "name/panitz/simpleGui">package name.panitz.simpleGui;
import javax.swing.*;

public class Window1{
  public static void main(String [] _){
    new JFrame(&quot;erstes Fenster&quot;).setVisible(true);
  }
}</code>

Dieses Programm erzeugt ein leeres Fenster und gibt das auf dem
Bildschirm aus. 
Der Fenstertitel kann als Argument dem Konstruktor der 
Klasse <tt>JFrame</tt> als <tt>String</tt> übergeben werden.
Die optische Ausprägung des Fensters kann vom Betriebssystem
abhängen. In Abbildung <ref name = "erstesFenster"/> ist dieses Fenster
beispielhaft in einer Suse Linux Umgebung mit KDE zu bewundern.<bild name = "erstesFenster"
                  pdfscale = "0.8"
                  psscale = "0.6"
                  caption = "Ein erstes Fenster."/></example></subsubsection><subsubsection titel = "Zwischenkomponenten">
Graphische Zwischenkomponenten haben primär die Aufgabe andere
Komponenten als Unterkomponenten zu haben und diese in einer
bestimmten Weise anzuordnen. Zwischenkomponenten haben oft keine
eigene visuelle Ausprägung. Sie sind dann unsichtbare Komponenten, die
als Behälter weiterer Komponenten dienen. <p/>
Die gebräuchlichste Zwischenkomponenten ist von der 
Klasse <tt>JPanel</tt>. Weitere Zwischenkomponenten sind<tt>JScrollPane</tt> und <tt>JTabbedPane</tt>. Diese haben auch eine
eigene visuelle Ausprägung.<p/>
Die Objekte der Klasse <tt>JFrame</tt> enthalten bereits eine
Zwischenkomponente. Diese kann mit der 
Methode <tt>getContentPane</tt> erhalten werden, um dieser
Zwischenkomponenten schließlich weitere Unterkomponenten, den Inhalt
des Fensters, hinzufügen zu können.</subsubsection><subsubsection titel = "Atomare Komponenten">
Die atomaren Komponenten sind schließlich Komponenten, die ein
konkretes graphisches Objekt darstellen, das keine weiteren
Unterkomponenten enthalten kann. 
Solche Komponenten sind z.B.<br/><tt>JButton, JTextField, JTable</tt> und <tt> JComBox</tt>.<p/>
Diese Komponenten lassen sich über ihre Konstruktoren instanziieren,
um sie dann einer Zwischenkomponenten über deren 
Methode <tt>add</tt> als Unterkomponente hinzuzufügen.
Sind alle gewünschten graphischen Objekte einer Zwischenkomponente
hinzugefügt worden, so kann auf der zugehörigen top-level Komponenten
die Methode <tt>pack</tt> aufgerufen wurden. Diese berechnet die
notwendige Größe und das Layout des Fensters, welches schließlich
sichtbar gemacht wird. <example>
Das folgende Programm erzeugt ein Fenster mit einer Textfläche. <code lang = "java"
                  class = "JT"
                  package = "name/panitz/simpleGui">package name.panitz.simpleGui;
import javax.swing.*;

class JT {
  public static void main(String [] _){
    JFrame frame = new JFrame();
    JTextArea textArea = new JTextArea();
    textArea.setText(&quot;hallo da draußen&quot;);
    frame.getContentPane().add(textArea);
    frame.pack();
    frame.setVisible(true);
  }
}</code>
Das Programm erzeugt das folgende Fenster:<p/><bild name = "JT"
                  pdfscale = "0.8"
                  psscale = "0.4"
                  caption = "Fenster mit Textfläche"/></example>

In der Regel wird man nicht die Fenster des Programms nacheinander in
der Hauptmethode definieren, sondern die gebrauchten Fenster werden
als eigene Objekte definiert. Hierzu leitet man eine spezifische
Fensterklasse  von der Klasse <tt>JFrame</tt> ab und fügt bereits im
Konstruktor die entsprechenden Unterkomponenten hinzu.<example>
Die folgende Klasse definiert ein Fenster, das einen Knopf und eine
Textfläche enthält. In der Hauptmethode wird das Objekt instanziiert: <code lang = "java"
                  class = "JTB"
                  package = "name/panitz/simpleGui">package name.panitz.simpleGui;
import javax.swing.*;

class JTB extends JFrame {
  JPanel pane = new JPanel();
  JTextArea textArea = new JTextArea();
  JButton button = new JButton(&quot;ein Knopf&quot;);

  public JTB(){
    textArea.setText(&quot;hallo da draußen&quot;);
    pane.add(textArea);
    pane.add(button);
    getContentPane().add(pane);
    pack();
    setVisible(true);
  }

  public static void main(String [] _){
    new JTB();
  }
}</code>
Das Programm erzeugt folgendes Fenster:<p/><bild name = "JTB"
                  pdfscale = "0.8"
                  psscale = "0.6"
                  caption = "Fenster mit Textfläche und Knopf"/></example></subsubsection></subsection><subsection titel = "Ereignisbehandlung">
Wir haben es bisher schon geschafft ein Fenster zu definieren, in dem mehrere
graphische Komponenten dargestellt werden. Für ein funktionierendes GUI ist es
nun notwendig, für einzelne Komponenten eine Funktionalität zu
definieren. Hierzu kennt Swing das Konzept der Ereignisbehandlung. Graphischen
Komponenten kann ein Ereignisbehandlungsobjekt angehänt werden. Objekte zur
Ereignisbehandlung müssen dabei bestimmte Schnittstellen implementieren, die
sogenannten <tt>Listener</tt>.<p/>

Ereignisarten  gibt es eine ganze Reihe auf den unterschiedlichsten
graphischen Komponenten: ein Knöpf kann gedrückt werden, ein Fenster
minimiert, mit der Maus auf eine Komponente gezeigt werden, ein Menupunkt
gewählt werden etc. Für die unterschiedlichen Ereignisarten gibt es
unterschiedliche Schnittstellen, die beschreiben, wie auf solche Ereignisse
reagiert werden soll. Die Schnittstellen für Ereignisse befinden sich im
Paket: <tt>java.awt.event.*</tt>.<example>
Als erstes Beispiel für eine Ereignisbehandlung betrachten wir die vielleicht
elementarste Art eines Ereignisses: ein Knopf wird gedrückt. Hierzu gibt es
die elementare 
Ereignisbehandlungsschnittstelle: <tt>java.awt.event.ActionListener</tt>. 
Diese Schnittstelle enthält nur eine Methode: <tt>actionPerformed</tt><p/>

Wir implementieren diese Schnittstelle. Unsere Klasse zur Ereignisbehandlung
bekommt dabei ein Textfeld übergeben. Intern enthalte die
Klasse einen Zähler. Wann immer das Ereignis eintritt, soll der Zähler um eins
erhöht werden und das neue Ergebnis des Zählers im Textfeld angezeigt werden.<code lang = "java"
                class = "CounterListener"
                package = "name/panitz/simpleGui">package name.panitz.simpleGui;
import java.awt.event.*;
import javax.swing.*;

public class CounterListener implements ActionListener{
  private final JTextArea textArea;
  private int counter = 0;
  public CounterListener(JTextArea ta){textArea=ta;}

  public void actionPerformed(ActionEvent _){
    counter = counter+1;
    textArea.setText(counter+&quot;&quot;);
  } 
}</code>
 
Jetzt können wir eine Unterklasse unserer letzten  kleinen 
Gui-Klasse <tt>JTB</tt> schreiben, in der diese Ereignisbehandlung dem Knopf
hinzugefügt wird. Hierzu gibt es für Knöpfe die 
Methode <tt>addActionListener</tt>.<code lang = "java"
                class = "Counter"
                package = "name/panitz/simpleGui">package name.panitz.simpleGui;
import javax.swing.*;

class Counter extends JTB {
  public Counter(){
    super();
    <redv>button.addActionListener(new CounterListener(textArea));</redv>
  }

  public static void main(String [] _){new Counter();}
}</code>

Und tatsächlich, wenn wir dieses Programm starten, so bewirkt, daß ein Drücken
des Knopfes mit der Maus bewirkt, daß im Textfeld angezeigt wird, wie oft
bisher der Knopf gedrückt wurde.</example><aufgabe>
Die Methode <tt>actionPerformed</tt> der 
Schnittstelle <tt>ActionListener</tt> bekommt ein Objekt der 
Klasse <tt>ActionEvent</tt> übergeben. In dieser gibt es eine 
Methode <tt>getWhen</tt>, die den Zeitpunkt, zu dem das Ereignis aufgetreten
ist als eine Zahl kodiert zurückgibt. Mit dieser Zahl können Sie die 
Klasse <tt>java.util.Date</tt> instanziieren, um ein Objekt zu bekommen, das
Datum und Uhrzeit enthält.<p/>
Schreiben Sie jetzt eine Unterklasse von <tt>JTB</tt>, so daß beim Drücken des
Knopfes, jetzt die aktuelle Uhrzeit im Textfeld erscheint.</aufgabe><aufgabe>Schreiben Sie eine kleine Guianwendung mit einer Textfläche und drei
Knöpfen, die einen erweiterten Zähler darstellt:<itemize>
            <item>einen Knopf zum Erhöhen eines Zählers.</item>
            <item>einen Knopf zum Verringern des Zählers um 1.</item>
            <item>einen Knopf zum Zurücksetzen des Zählers auf 0.</item>
          </itemize></aufgabe></subsection><subsection titel = "Setzen des Layouts">
Bisher haben wir Unterkomponenten weitere Komponenten mit der 
Methode <tt>add</tt> hinzugefügt, ohne uns Gedanken über die
Plazierung der Komponenten zu machen. Wir haben einfach auf das
Standardverhalten zur Plazierung von Komponenten vertraut.
Ob die Komponenten schließlich nebeneinander, übereinander oder irgendwie
anders Gruppiert im Fenster erschienen, haben wir nicht spezifiziert. <p/>


Um das Layout von graphischen Komponenten zu steuern, steht das Konzept
der sogenannten <em>Layout-Manager</em> zur Verfügung. Ein
Layout-Manager ist ein Objekt, das einer Komponente hinzugefügt
wird. Der Layout-Manager steuert dann, in welcher Weise die
Unterkomponenten gruppiert werden. <p/><tt>LayoutManager</tt> ist eine Schnittstelle. Es gibt mehrere
Implementierungen dieser Schnittstelle. Wir werden in den nächsten
Abschnitten drei davon kennenlernen. Es steht einem natürlich frei,
eigene Layout-Manager durch Implementierung dieser Schnittstelle zu
schreiben. Es wird aber davon abgeraten, weil dieses notorisch
schwierig ist und die in Java bereits vorhandenen Layout-Manager
bereits sehr mächtig und ausdrucksstark sind. <p/>
Zum Hinzufügen eines Layout-Manager gibt es die Methode <tt>setLayout</tt>.<subsubsection titel = "Flow Layout">
Der vielleicht einfachste Layout-Manager nennt 
sich <tt>FlowLayout</tt>. Hier werden die Unterkomponenten einfach der
Reihe nach in einer Zeile angeordnet. Erst wenn das Fenster zu schmal
hierzu ist, werden weitere Komponenten in eine neue Zeile gruppiert.<example>
Die folgende Klasse definiert ein Fenster, dessen Layout über ein
Objekt der Klasse <tt>FlowLayout</tt> gesteuert wird. Dem Fenster
werden fünf Knöpfe hinzugefügt:<code lang = "java"
                  class = "FlowLayoutTest"
                  package = "name/panitz/gui/layoutTest">package name.panitz.gui.layoutTest;

import java.awt.*;
import javax.swing.*;

class FlowLayoutTest extends JFrame {

  public FlowLayoutTest(){
    Container pane = getContentPane();
    <redv>pane.setLayout(new FlowLayout());</redv>
    pane.add(new JButton(&quot;eins&quot;));
    pane.add(new JButton(&quot;zwei&quot;));
    pane.add(new JButton(&quot;drei (ein langer Knopf)&quot;));
    pane.add(new JButton(&quot;vier&quot;));
    pane.add(new JButton(&quot;fuenf&quot;));
    pack();
    setVisible(true);
  }

  public static void main(String [] _){new FlowLayoutTest();}
}</code>
Das Fenster hat folgende optische Ausprägung.<p/><bild name = "FlowLayoutTest"
                  pdfscale = "0.8"
                  psscale = "0.99"/>
Verändert man mit der Maus die Fenstergröße, macht es
z.B.<white/>schmal und hoch, so werden die Knöpfe nicht mehr
nebeneinander sonder übereinander angeordnet.</example></subsubsection><subsubsection titel = "Border Layout">
Die Klasse <tt>BorderLayout</tt> definiert einen Layout Manager, der
fünf feste Positionen kennt: eine Zentralposition, und jeweils
links/rechts und oberhalb/unterhalb der Zentralposition  eine Position
für Unterkomponenten. Die Methode <tt>add</tt> kann in diesem Layout
auch noch mit einem zweitem Argument aufgerufen werden, das eine
dieser fünf Positionen angibt. Hierzu bedient man sich der konstanten
Felder der Klasse <tt>BorderLayout</tt>.<example>
In dieser Klasse wird die Klasse <tt>BorderLayout</tt> zur Steuerung
des Layoout benutzt. Die fünf Knöpfe werden an jeweils eine der fünf
Positionen hinzugefügt:<code lang = "java"
                  class = "BorderLayoutTest"
                  package = "name/panitz/gui/layoutTest">package name.panitz.gui.layoutTest;

import java.awt.*;
import javax.swing.*;

class BorderLayoutTest extends JFrame {

  public BorderLayoutTest(){
    Container pane = getContentPane();
    <redv>pane.setLayout(new BorderLayout());</redv>
    pane.add(new JButton(&quot;eins&quot;),BorderLayout.NORTH);
    pane.add(new JButton(&quot;zwei&quot;),BorderLayout.SOUTH);
    pane.add(new JButton(&quot;drei (ein langer Knopf)&quot;)
                                ,BorderLayout.CENTER);
    pane.add(new JButton(&quot;vier&quot;),BorderLayout.WEST);
    pane.add(new JButton(&quot;fuenf&quot;),BorderLayout.EAST);
    pack();
    setVisible(true);
  }

  public static void main(String [] _){new BorderLayoutTest();}
}</code>

Die Klasse erzeugt das folgende Fenster.<p/><bild name = "BorderLayoutTest"
                  pdfscale = "0.8"
                  psscale = "0.7"/>
Das Layout ändert sich nicht, wenn man mit der Maus die Größe und das
Format des Fensters verändert. </example></subsubsection><subsubsection titel = "Grid Layout">
Die Klasse <tt>GridLayout</tt> ordnet die Unterkomponenten
tabellarisch an. Jede Komponente wird dabei gleich groß
ausgerichtet. Die Größe richtet sich also nach dem größten Element. <example>
Folgende Klasse benutzt ein Grid-Layout mit zwei Zeilen zu je drei
Spalten. <code lang = "java"
                  class = "GridLayoutTest"
                  package = "name/panitz/gui/layoutTest">package name.panitz.gui.layoutTest;

import java.awt.*;
import javax.swing.*;

class GridLayoutTest extends JFrame {
  public GridLayoutTest(){
    Container pane = getContentPane();
    <redv>pane.setLayout(new GridLayout(2,3));</redv>
    pane.add(new JButton(&quot;eins&quot;));
    pane.add(new JButton(&quot;zwei&quot;));
    pane.add(new JButton(&quot;drei (ein langer Knopf)&quot;));
    pane.add(new JButton(&quot;vier&quot;));
    pane.add(new JButton(&quot;fünf&quot;));
    pack();
    setVisible(true);
  }

  public static void main(String [] _){new GridLayoutTest();}
}</code>
Folgendes Fensters wird durch dieses Programm geöffnet.<p/><bild name = "GridLayoutTest"
                  pdfscale = "0.8"
                  psscale = "0.99"/>
Auch hier ändert sich das Layout nicht, wenn man mit der Maus die
Größe und das 
Format des Fensters verändert. </example></subsubsection></subsection></section><section titel = "Exkurs: verschachtelte Klassen">
Bisher haben wir gelernt, daß jede Java Quelltextdatei genau eine Klasse
enthält und Klassen Eigenschaften in Form von Feldern und Methoden
enthalten. In den ersten GUI-Beispielen und Aufgaben haben wir schon gesehen,
daß es insbesondere für die Ereignisbehandlung oft zu sehr kleinen Klassen
kommt, die lediglich für eine ganz spezielle Funktionalität innerhalb einer
GUI-Klasse benötigt werden. Um in solchen Situationen den Code etwas
struktuierter zu schreiben, so daß ein Ereignisbehandler direkt im Quelltext
bei dem GUI-Objekt zu finden ist, gibt es in Java die Möglichkeit, innerhalb
einer Klasse ein interne Klasse zu schreiben. Hierbei spricht man von
verschachtelten Klassen. Verschachtelte Klassen können statisch sein, oder als
nicht-statische Eigenschaft an konkrete Objekte gebunden sein. In diesem Fall
heißen sie: <em>innere Klassen</em>. Tatsächlich können verschachtelte
überall im Code auftauchen: sie können auf obere Ebene parallel zu Feldern und
Methoden in einer Klasse definiert werden, aber auch an beliebiger Stelle
innerhalb eines Methodenrumpfes. <subsection titel = "Innere Klassen">
Eine innere Klasse wird gechrieben wie jede andere Klasse auch, nur daß sie
eben im Rumpf einer äußeren Klasse auftauchen kann. Die innere Klasse hat das
Privilig auf die Eigenschaften der äußeren Klasse zuzugreifen, sogar auf die
als privat markierten Eigenschaften. Das  Attribut privat soll lediglich
verhindern, daß eine Eigenschaft von außerhalb der Klasse benutzt wird. Innere
Klasse befinden sich aber innerhalb der Klasse.<example>
Unser erstes GUI mit einer Funktionalität läßt sich jetzt mit Hilfe einer
inneren Klasse in einer Datei schreiben. Das Feld <tt>counter</tt>, das wir in
der vorherigen Implementierung als privates Feld der 
Klass <tt>CounterListener</tt> definiert hatten, haben wir hier als Feld der
GUI-Klasse modelliert. Trotzdem kann die 
Klasse <tt>CounterListener</tt> weiterhin darauf zugreifen. Ebenso brauch die
Textfläche nicht der Klasse <tt>CounterListener</tt> im Konstruktor übergeben
werden. Als innere Klasse kann in <tt>CounterListener</tt> auf dieses Feld der
äußeren Klasse zugegriffen werden.<code lang = "java"
                class = "InnerCounter"
                package = "name/panitz/simpleGui">package name.panitz.simpleGui;
import javax.swing.*;
import java.awt.event.*;

class InnerCounter extends JTB {
  private int counter = 0;

  <redv>class CounterListener implements ActionListener</redv>{
    public void actionPerformed(ActionEvent _){
      counter = counter+1;
      textArea.setText(counter+&quot;&quot;);
    } 
  }

  public InnerCounter(){
    button.addActionListener(new CounterListener());
  }

  public static void main(String [] _){new InnerCounter();}
}</code>
Tatsächlich ist die Implementierung kürzer und etwas übersichtlicher
geworden. </example>

Beim Übersetzen einer Klasse mit inneren Klassen, erzeugt der Javaübersetzer
für jede innere Klasse eine eigene Klassendatei:<scode>sep@linux:~/fh/prog2/examples/classes/name/panitz/simpleGui&gt; ll *.class
-rw-r--r--    1 sep      users        1082 2004-03-29 11:36 InnerCounter$CounterListener.class
-rw-r--r--    1 sep      users         892 2004-03-29 11:36 InnerCounter.class</scode>

Der Javaübersetzer schreibt intern den Code um in eine Menge von Klassen ohne
innere Klassendefinition und erzeugt für diese den entsprechenden Code.
Für die innere Klasse generiert der Javaübersetzer einen Namen, der sich aus
äußeren und inneren Klassenamen durch ein Dollarzeichen getrennt zusammensetzt.<aufgabe>
Schreiben Sie Ihr Programm eines Zählers mit drei Knöpfen jetzt so, daß sie
innere Klassen benutzen.</aufgabe></subsection><subsection titel = "Anonyme Klassen">
Im letzten Abschnitt hatten wir bereits das Beispiel einer inneren Klasse, für
die wir genau einmal ein Objekt erzeugen. In diesem Fall wäre es eigentlich
unnötig für eine solche Klasse einen Namen zu erfinden, wenn man an genau
dieser einen Stelle, an der das Objekt erzeugt wird, die entsprechende Klasse
spezifizieren könnte. Genau hierzu dienen anonyme Klassen in Java. Sie
ermöglichen, Klassen ohne Namen zu instanziieren. Hierzu ist nach dem 
Schlüsselwort <tt>new</tt> anzugeben, von
welcher Oberklasse namenlose Klasse ableiten soll, oder welche Schnittstelle
mit der namenlosen Klasse implementiert werden soll. Dann folgt nach dem
leeren Klammerpaar für dem Konstruktoraufruf in geschweiften Klammern der
Rumpf der namenlosen Klasse.<example>
Wir schreiben ein drittes Mal die Klasse <tt>Counter</tt>. Diesmal wird statt
der nur einmal instanziierten inneren Klasse eine anonyme Implementierung der
Schnittstelle <tt>ActionListener</tt> Instanziiert.<code lang = "java"
                class = "AnonymousCounter"
                package = "name/panitz/simpleGui">package name.panitz.simpleGui;
import javax.swing.*;
import java.awt.event.*;

class AnonymousCounter extends JTB {
  private int counter = 0;

  public AnonymousCounter(){
    button.addActionListener(
      <redv>new ActionListener(){</redv>
        public void actionPerformed(ActionEvent _){
          counter = counter+1;
          textArea.setText(counter+&quot;&quot;);
        } 
      <redv>}</redv>);
  }

  public static void main(String [] _){new AnonymousCounter();}
}</code></example>

Auch für anonyme Klassen generiert der Javaübersetzer eigene
Klassendateien. Mangels eines Names, numeriert der Javaübersetzer hierbei die
inneren Klassen einfach durch.<scode>sep@linux:~/fh/prog2/examples/classes/name/panitz/simpleGui&gt; ll *.class
-rw-r--r--    1 sep      users        1106 2004-03-29 11:59 AnonymousCounter$1.class
-rw-r--r--    1 sep      users         887 2004-03-29 11:59 AnonymousCounter.class
sep@linux:~/fh/prog2/examples/classes/name/panitz/simpleGui&gt;</scode></subsection><subsection titel = "Statische verschachtelte Klassen">
Selten benutzt gibt es auch statische verschachtelte Klassen. Diese können
entsprechend auch nur auf statische Eigenschaften der äußeren Klasse
zugreifen. </subsection></section><section titel = "Applets">
Ältere Einführung in Java  begannen gerne mit der Programmierung von
sogenannten  <em>applets</em>. <em>Applet</em> ist der englische Diminutiv 
für Applikation; es handelt sich also bei einem <em>Applet</em> um eine kleine
oft auch niedliche Applikation. Applets werden im  Webbrowser
ausgeführt. Auf einer Webseite ist hierzu 
ein <em>Tag</em><w/><tt>&lt;applet&gt;</tt> einzufügen. In diesem ist eine
Javaklasse anzugeben, die der Browser an dieser Stelle der Webseite ausführen
soll. <p/>

Applets waren ursprünglich tatsächlich die Killerapplikation von Java, denn
damit verfügte Java über eine Technik, die weder eine andere
Programmiersprache angeboten hat, noch auf andere Weise umgesetzt werden
konnte. Mitte der 90er Jahre waren Webseite noch recht nüchterne
Angelegenheiten. Es gab vor allen Dingen kaum bewegte Bilder oder
Lauftexte. Javas virtuelle Maschine konnte in den 
Webbrowsern <em>mosaic</em> und später <em>netscape</em> integriert werden, so
daß sich Javaapplikationen auf Webseiten laufen ließen, die bewegte Bilder und
ähnliches realisierten. Eine der häufigsten kleinen Demonstrationsprogramme
war das Javamännchen, das den Betrachter zuwinkte. Dieses animierte Männchen
war als Applet realisiert.<footnote>Wohingehend, wenn man heute das winkende
Männchen sieht, es sich meistens um eine animierte gif-Datei handelt. Animiert
hinjtereinander zu spielende Bilder kannte auch damals bereits das gif-Format,
wurde allerdings nur von wenigen Werkzeugen unterstützt.</footnote> Aufgrund
der Applets brach ein regelrechter Hype um Java aus. Es gab sogar die
Vorstellung, daß dereinst komplette Office-Pakete als Applets realisiert
werden und Arbeitsplatzrechner kaum noch eine eigene Festplatte brauchen,
sondern alle Programme als Applets übers Netz holen.<p/>

Wer heutzutage mit einem nicht javafähigen Browser durchs Netz surft, wird
feststellen, daß es so gut wie keine Webseite gibt, auf der sich ein Applet
befindet. In dieser Hinsicht sind Applets als Technologie mehr oder weniger
tot. Java hingegen hatte noch Jahre mit dem Vorurteil zu kämpfen, es sei
lediglich eine Sprache um kleine Programme für den Browser zu schreiben und
für große Programme nicht ernsthaft einzusetzen. Wie man sieht, hat sich
mitlerweile Java als Programmiersprache etabliert, jedoch der ursprüngliche
Türöffner, die Applets spielen keinerlei Rolle mehr.<p/>

Trotzdem  soll in diesem Abschnitt einmal gezeigt werden, wie sich eine
Applikation als Applet schreiben läßt.<subsection titel = "Die Klasse JApplet">
Um eine im Browser auszführbare Klasse zu schreiben, muß diese von der 
Klasse <tt>java.applet.Applet</tt>  ableiten. Im Swingpaket gibt es die
Klasse <tt>javax.swing.JApplet</tt>, die eine Unterklasse 
von <tt>Applet</tt> ist. Um also eine Klasse, die der Browser ausführen kann
zu schreiben, sollte man von einer dieser Klassen ableiten. Da es sich 
bei <tt>Applet</tt> um eine Unterklasse von <tt>Panel</tt> handelt, können wir
mit der bereits gewohnten Methode <tt>add</tt> weitere graphische Komponenten 
zu einem Applet hinzufügen.<p/>


Als Beispiel schreiben wir hierzu wieder die nun schon hinglänglich 
bekannte Klasse <tt>Counter</tt>. Dieses mal allerdings nicht direkt 
als <tt>JFrame</tt>, sondern als ein <tt>JPanel</tt>, das dann je nach Bedarf 
einem <tt>JFrame</tt>, einem <tt>JApplet</tt> oder einer anderen Komponente
hinzugefügt werden kann.<code class = "CounterPanel"
              lang = "java">
import javax.swing.*;
import java.awt.event.*;
public class  CounterPanel extends JPanel{
  int i=0;
  JButton b=new JButton(&quot;just Push&quot;);
  JLabel l=new JLabel(&quot;  &quot;);
  public CounterPanel(){
    b.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent e){
        i=i+1;
	l.setText(i+&quot;&quot;);
	repaint();
      }
    });
    add(b);
    add(l);
  }
}</code>

Diese Komponente soll jetzt einer <tt>JApplet</tt>-Klasse zugefügt
werden. Hierzu kann die <tt>add</tt>-Methode von <tt>JApplet</tt> benutzt 
werden:<code class = "CountApplet"
              lang = "java">import javax.swing.*;
public class CountApplet extends JApplet{
  public CountApplet(){add(new CounterPanel());}
}</code>

Es bleibt eine Webseite zu schreiben, in der diese Appletklasse gestartet
wird. In dieser HTML-Seite ist der Tag <tt>applet</tt> einzufügen. Im 
Attribut <tt>code</tt> dieses Tags ist die Javaklasse anzugeben, welche das
Applet enthält. Weitere Attribute definieren die Größe des Bereichs, den der
Browser für das Applet vorsehen soll. Zusätzlich läßt sich noch definieren, 
in welchem Verzeichnis auf dem Webserver die Klassen zu finden sind. Folgende
HTML-Seite startet schließlich obiges Applet.<code class = "ViewApplet"
              lang = "html">&lt;html&gt;&lt;body&gt;
&lt;h1&gt;Ein erstes Applet&lt;/h1&gt;
Dieses Applet zählt einen internen Zähler hoch, wenn der Knopf gedrückt wird.
&lt;applet code=&quot;CountApplet.class&quot; 
        codebase=&quot;../classes/&quot;
        width=&quot;600&quot; height=&quot;60&quot;&gt;
    &lt;param name=&quot;maxwidth&quot; value=&quot;120&quot;&gt;
    &lt;param name=&quot;nimgs&quot; value=&quot;17&quot;&gt;
    &lt;param name=&quot;offset&quot; value=&quot;-57&quot;&gt;
Your browser is completely ignoring the &amp;lt;APPLET&amp;gt; tag!
&lt;/applet&gt;
&lt;/body&gt;&lt;/html&gt;</code></subsection><subsection titel = "Methoden eines Applets"/><subsection titel = "Sicherheit"/><subsection titel = "Laden von weiteren Resourcen"/></section><section titel = "Selbstdefinierte graphische Komponenten">
Bisher graphische Komponenten unter Verwendung der fertigen
GUI-Komponente  aus der Swing-Bibliothek zusammengesetzt.
Oft will man graphische Komponenten schreiben, für die  
 es keine fertige
GUI-Komponente in der Swing-Bibliothek gibt. Wir müssen wir eine
entsprechende Komponente selbst schreiben.<subsection titel = "Graphics Objekte">
Um eine eigene GUI-Komponente zu schreiben, schreibt man eine Klasse,
die von der GUI-Klasse ableitet. Dieses haben wir
bereits in den letzten Beispielen getan, indem wir von der 
Klasse <tt>JFrame</tt> abgelitten haben. Die dort geschriebenen
Unterklassen der Klasse <tt>JFrame</tt> zeichneten sich dadurch aus,
daß  sie eine Menge von graphischen Objekten (Knöpfe, 
Textfelder<dots/>) in einer Komponente zusammengefasst haben. In
diesem Abschnitt werden wir eine neue Komponente definieren, die keine
der bestehenden fertigen Komponenten benutzt, sondern selbst alles 
zeichnet, was zu ihrer Darstellung notwendig ist.<p/> 

Hierzu betrachten wir eine der entscheidenen Methoden  der 
Klasse <tt>JComponent</tt>, die 
Methode <tt>paintComponent</tt>.
In 
dieser Methode wird festgelegt, was zu zeichnen ist, wenn die
graphische Komponente darzustellen ist. Die 
Methode <tt>paintComponent</tt> hat folgende Signatur:<code>public void paintComponent(java.awt.Graphics g)</code>

Java ruft diese Methode immer auf, wenn die graphische Komponente aus
irgendeinen Grund zu zeichnen ist. Dabei bekommt die Methode das
Objekt übergeben, auf dem gezeichnet wird. Dieses Objekt ist vom 
Typ <tt>java.awt.Graphics</tt>. Es stellt ein zweidimensionales
Koordinatensystem dar, in dem zweidimensionale Graphiken gezeichnet
werden können. Der Nullpunkt dieses Koordinatensystems ist oben links
und nicht unten links, wie wir es vielleicht aus der Mathematik
erwartet hätten.<p/>

In der Klasse <tt>Graphics</tt> sind eine Reihe von Methoden
definiert, die es erlauben graphische Objekte zu zeichnen. Es gibt
Methoden zum Zeichnen von Geraden, Vierecken, Ovalen, beliebigen
Polygonzügen, Texten etc.<p/>

Wollen wir eine eigene graphische Komponente definieren, so können wir
die Methode <tt>paintComponent</tt>  überschreiben und auf dem übergebenen
Objekt des Typs <tt>Graphics</tt> entsprechende Methoden zum Zeichnen
aufrufen. Um eine eigene graphische Komponente zu definieren, wird empfohlen
die Klasse <tt>JPanel</tt> zu erweitern und in ihr die 
Methode <tt>paintComponent</tt>  zu überschreiben.<example>Folgende Klasse definiert eine neue graphische Komponente,
die zwei Linien, einen Text, ein Rechteck, ein Oval und ein gefülltes
Kreissegment enthält.<code lang = "java"
                class = "SimpleGraphics"
                package = "name/panitz/gui/graphicsTest">package name.panitz.gui.graphicsTest;

import javax.swing.JPanel;
import javax.swing.JFrame;
import java.awt.Graphics;

class SimpleGraphics extends JPanel{
  public void paintComponent(Graphics g){
    g.drawLine(0,0,100,200);
    g.drawLine(0,50,100,50);
    g.drawString(&quot;hallo&quot;,10,20);
    g.drawRect(10, 10, 60,130); 
    g.drawOval( 50,  100, 30, 80); 
    g.fillArc(-20, 150, 80, 80, 0, 50); 
  } 
}</code>

Diese Komponente können wir wie jede andere Komponente auch einem
Fenster hinzufügen, so daß sie auf dem Bildschirm angezeigt werden
kann. <code lang = "java"
                class = "UseSimpleGraphics"
                package = "name/panitz/gui/graphicsTest">package name.panitz.gui.graphicsTest;
 
import javax.swing.JFrame;

class UseSimpleGraphics {
  public static void main(String [] args){
    JFrame frame = new JFrame();
    frame.getContentPane().add(<redv>new SimpleGraphics()</redv>);

    frame.pack();
    frame.setVisible(true);
  }
}</code>

Wird dieses Programm gestartet, so öfnet Java das  Fenster 
aus Abbildung<white/><ref name = "graphics1"/> auf dem Bildschirm. <bild name = "graphics1"
                pdfscale = "0.9"
                psscale = "0.2"
                caption = "Einfache graphische Komponente."/><p/> 

Erst wenn wir das Fenster mit der Maus größer
ziehen, können wir das ganze Bild sehen. </example></subsection><subsection titel = "Dimensionen">
Ärgerlich in unserem letzten Beispiel war, daß Java zunächst ein zu
kleines Fenster für unsere Komponente geöffnet hat, und wir dieses
Fenster mit Maus erst größer ziehen mußten. Die 
Klasse <tt>JComponent</tt> enthält Methoden, in denen die Objekte
angeben können, welches ihre bevorzugte Größe bei ihrere Darstellung
ist. Wenn wir diese Methode überschreiben, so daß sie eine Dimension
zurückgibt, in der das ganze zu zeichnende Bild passt, so wird von
Java auch ein entsprechend großes Fenster geöffnet.  Wir fügen der
Klasse  <tt>SimpleGraphics</tt> folgende zusätzliche Methode hinzu.<code>  public java.awt.Dimension getPreferredSize() {
    return new java.awt.Dimension(100,200);
  }</code>

Jetzt öffnet Java ein Fenster, in dem das ganze Bild dargestellt
werden kann.<aufgabe> Schreiben Sie eine
GUI-Komponente <tt>StrichKreis</tt>, die mit geraden Linien einen Kreis 
entsprechend untenstehender Abbildung malt. Der Radius des Kreises 
soll dabei dem Konstruktor der 
Klasse <tt>StrichKreis</tt> als <tt>int</tt>-Wert 
übergeben werden. <p/>
Testen Sie Ihre Klasse mit folgender Hauptmethode: <code>public static void main(String [] args) {
  StrichKreis k = new StrichKreis(120);
  JFrame f = new JFrame();
  JPanel p = new JPanel();
  p.add(new StrichKreis(120));
  p.add(new StrichKreis(10));
  p.add(new StrichKreis(60));
  p.add(new StrichKreis(50));
  p.add(new StrichKreis(70));
  f.getContentPane().add(p);

  f.pack();
  f.setVisible(true);
}</code><p/><b>Hinweis:</b> In der Klasse <tt>java.lang.Math</tt> finden Sie Methoden 
trigeometrischer Funktionen. 
Insbesondere <tt>toRadians</tt> zum Umrechnen von Gardwinkel in Bogenmaß 
sowie <tt>sin</tt> und <tt>cos</tt>. <bild name = "StrichKreis"
                pdfscale = "0.7"
                psscale = "0.5"
                caption = "Kreis mit Durchmesserlinien."/><p/></aufgabe></subsection><subsection titel = "Farben">
In der graphische Komponente aus dem letzten Abschnitt  haben wir uns
noch keine Gedanken über die Farbe der gezeichneten Grafik
gemacht. Die Klasse <tt>Graphics</tt> stellt eine Methode bereit, die
es erlaubt die Farbe des Stiftes für die Grafik auf einen bestimmten
Wert zu setzen. Alle anschließenden Zeichenbefehle auf das Objekt des
Typs <tt>Graphics</tt> werden dann mit dieser Farbe vorgenommen,
solange bis die Methode zum Setzen der Farbe ein weiteres Mal
aufgerufen wird. Die Methode zum Setzen der Farbe auf einem Objekt der
Klasse <tt>Graphics</tt> hat folgende Signatur:<code>public abstract void setColor(java.awt.Color c)</code><p/>
Zusätzlich gibt es für Komponenten noch eine Methode, die die
Hintergrundfarbe der Komponente beschreibt.<p/>


Farben werden mit der Klasse <tt>java.awt.Color</tt> beschrieben. Hier
gibt es mehrere Konstruktoren, um eine Farbe zu spezifizieren, 
z.B.<white/>einen Konstruktor, der Intensität der drei
Grundfarben in einen Wert zwischen 0 und 255 festlegt.<p/>

Für bestimmte gängige Farben stellt die
Klasse <tt>Color</tt> Konstanten zur Verfügung, die wir benutzen
können, wie z.B.: <tt>Color.RED</tt> oder <tt>Color.GREEN</tt>.<example>
Wir können eine kleine Klasse schreiben, in der wir ein wenig
mit Farben spielen. Wir setzen die Hintergrundfarbe des Objekts
auf einen dunklen Grauwert, zeichnen darin ein dunkelgrünes Rechteck, 
ein rotes Oval und ein gelbes Oval.<code lang = "java"
                class = "ColorTest"
                package = "name/panitz/gui/graphicsTest">package name.panitz.gui.graphicsTest;

import javax.swing.JPanel;
import javax.swing.JFrame;

public class ColorTest extends JPanel{
  public ColorTest(){
    <bluev>//Hintergrundfarbe auf einen dunklen Grauton setzen</bluev>
    setBackground(new java.awt.Color(100,100,100));
  }  

  public void paintComponent(java.awt.Graphics g){
    <bluev>//Farbe auf einen dunklen Grünton setzen</bluev>
    g.setColor(new java.awt.Color(22,178,100));
    <bluev>//Rechteck zeichnen</bluev>
    g.fillRect(25,50,50,100);
    <bluev>//Farbe auf rot setzen</bluev>
    g.setColor(java.awt.Color.RED);
    g.fillOval(25,50,50,100);
    <bluev>//Farbe auf gelb setzen</bluev>
    g.setColor(java.awt.Color.YELLOW);
    g.fillOval(37,75,25,50);
  }

  public java.awt.Dimension getPreferredSize() {
    return new java.awt.Dimension(100,200);
  }

  public static void main(String [] _){
    javax.swing.JFrame f = new JFrame(&quot;Farben&quot;);
    f.getContentPane().add(new ColorTest());
    f.pack();f.setVisible(true);
  }
} </code>

Das Programm ergibt das Bild aus Abbildung <ref name = "ColorTest"/>.<bild name = "ColorTest"
                pdfscale = "0.7"
                psscale = "0.3"
                caption = "Erste farbige Graphik."/><p/></example><aufgabe>Erweitern Sie die Strichkreisklasse aus der letzten Aufgabe, so daß
jeder Strich in einer anderen Farbe gezeichnet wird.</aufgabe><subsubsection titel = "Fraktale">
Um noch ein wenig mit Farben zu spielen, zeichnen wir in diesem
Abschnitt die berühmten Apfelmännchen. Apfelmännchen werden definiert
über eine Funktion auf komplexen Zahlen. Die aus der Mathematik
bekannten komplexen Zahlen sind Zahlen mit zwei reellen Zahlen als
Bestandteil, den sogenannten Imaginärteil und den sogenannten
Realteil. Wir schreiben zunächst eine rudimentäre Klasse zur
Darstellung von komplexen Zahlen:<code lang = "java"
                class = "Complex"
                package = "name/panitz/crempel/tool/apfel">package name.panitz.crempel.tool.apfel;

public class Complex{</code>
Diese Klasse braucht zwei Felder um Real- und Imaginärteil zu speichern:<code lang = "java"
                class = "Complex"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  public double re;
  public double im;</code>
Ein naheliegender Konstruktor für komplexe Zahlen füllt diese beiden
  Felder. <code lang = "java"
                class = "Complex"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel"> public Complex(double re,double im){
  this.re=re;this.im=im;
}</code>
Im Mathematikbuch schauen wir nach, wie Addition und Multiplikation
für komplexe Zahlen definiert sind, und schreiben entsprechende Methoden:<code lang = "java"
                class = "Complex"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  public Complex add(Complex other){
    return new Complex(re+other.re,im+other.im);
  }

  public Complex mult(Complex other){
    return new Complex
      (re*other.re-im*other.im,re*other.im+im*other.re);
  }</code>
Zusätzlich finden wir in Mathematik noch die Definition der Norm einer
    komplexen Zahl und setzen auch diese Definition in eine Methode
    um. Zum Quadrat des Realteils wird das Quadrat des Imaginärteils
    addiert. <code lang = "java"
                class = "Complex"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  public double norm(){return re*re+im*im;}
}</code>

Soweit komplexe Zahlen, wie wir sie für Apfelmännchen brauchen.<p/>

Grundlage zum Zeichnen von Apfelmännchen ist folgende
Iterationsgleichung auf komplexen Zahlen: <m>z_{n+1} = z_n^2 + c</m>. 
Wobei <m>z_0</m> die komplexe Zahl <m>0+0i</m> mit dem Real-
und Imaginärteil <m>0</m> ist.<p/>

Zum Zeichnen der Apfelmännchen wird ein Koordinatensystem so
interpretiert, daß die Achsen jeweils Real- und Imaginärteil von
komplexen Zahlen darstellen. Jeder Punkt in diesem Koordinatensystem
steht jetzt für die Konstante <m>c</m> in obiger Gleichung. Nun wir
geprüft ob und für welches <m>n</m> die Norm von <m>z_n</m> größer
eines bestimmten Schwellwertes ist. Je nach der Größe von <m>n</m>wird der Punkt im Koordinatensystem mit einer anderen Farbe eingefärbt.<p/>

Mit diesem Wissen können wir nun versuchen die Apfelmännchen zu
zeichnen. Wir müssen nur geeignete Werte für die einzelnen Parameter
finden. Wir schreiben eine eigene Klasse für das graphische Objekt, in
dem ein Apfelmännchen gezeichnet wird. Wir deklarieren die Imports der
benötigten Klassen:<code lang = "java"
                class = "Apfelmaennchen"
                package = "name/panitz/crempel/tool/apfel">package name.panitz.crempel.tool.apfel;

import java.awt.Graphics;
import java.awt.Color;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Apfelmaennchen extends JPanel {</code>
Als erstes deklarieren wir Konstanten für die Größe des
Apfelmännchens. <code lang = "java"
                class = "Apfelmaennchen"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  final int width = 480;
  final int height = 430;</code>
Eine weitere wichtige Konstante ist der Faktor, der angibt, welcher
  reellen Zahl ein Pixel entspricht:<code lang = "java"
                class = "Apfelmaennchen"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  double zelle=0.00625;</code>
Eine weitere Konstanten legt die Farbe fest, mit der die Punkte, die
nicht über einen bestimmten Schwellwert konvergieren, eingefärbt
werden sollen:<code lang = "java"
                class = "Apfelmaennchen"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  final Color colAppleman = new Color(0,129,190);</code>
Weitere Konstanten legen fest welche komplexe Zahl der Nullpunkt
unseres <tt>Graphics</tt>-Objekts darstellt.<code lang = "java"
                class = "Apfelmaennchen"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  double startX = -2;
  double startY = -1.35;</code>
Weitere Konstanten sind der Schwellwert und die maximale
Rekursionstiefe <m>n</m>, für die wir jeweils <m>z_n</m> berechnen: <code lang = "java"
                class = "Apfelmaennchen"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  final int recDepth = 50;
  final int schwellwert = 4;</code>
Die wichtigste Methode berechnet die Werte für die 
Gleichung <m>z_{n+1} = z_n^2 + c</m>. 
Der Eingabeparameter ist die komplexe Zahl <m>c</m>.
Das Ergebnis dieser Methode 
ist das <m>n</m>, für das <m>z_n</m> größer als der Schwellwert ist:<code lang = "java"
                class = "Apfelmaennchen"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  //C-Werte checken nach zn+1 = zn*zn + c, 
  public int checkC(Complex c) {        
    Complex zn = new Complex(0,0);

    for (int n=0;n&lt;recDepth;n=n+1) {
      final Complex znp1 = zn.mult(zn).add(c);
      if (znp1.norm() &gt; schwellwert) return n;
      zn=znp1;
    }
    return recDepth;
  }</code>
Jetzt gehen wir zum Zeichnen jedes Pixel 
unseres <tt>Graphics</tt>-Objekts durch, berechnen welche komplexe
      Zahl an dieser Stelle steht und benutzen dann die 
Methode  <m>checkC</m>, um zu berechnen ob und nach wieviel
      Iterationen die Norm von <m>z_n</m> größer als der Schwellwert
      wird. Abhängig von dieser Zahl, färben wir den Punkt mit einer
      Farbe ein. <code lang = "java"
                class = "Apfelmaennchen"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  public void paint(Graphics g) {
    for (int y=0;y&lt;height;y=y+1) {
      for (int x=0;x&lt;width;x=x+1) {

        final Complex current
          =new Complex(startX+x*zelle,startY+y*zelle);  

        final int iterationenC = checkC(current);

        paintColorPoint(x,y,iterationenC,g);
      }
    }
  }</code>
Zur Auswahl der Farbe benutzen wir folgende kleine Methode, die
      Abhängig von ihrem Parameter <tt>it</tt> an der 
Stelle <tt>(x,y)</tt> einen Punkt in einer bestimmten Farbe zeichnet.<code lang = "java"
                commandchars = "|~^"
                class = "Apfelmaennchen"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  private void paintColorPoint
                 (int x,int y,int it,Graphics g){
    final Color col
      = it==recDepth
        ?colAppleman   
        :new Color(255-5*it%1,255-it%5*30,255-it%5* 50);
    g.setColor(col); 
    g.drawLine(x,y,x,y);
  }</code>
Schließlich können wir noch die Größe festlegen und das Ganze in einer
Hauptmethode starten:<code lang = "java"
                class = "Apfelmaennchen"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  public Dimension getPreferredSize(){
    return new Dimension(width,height);
  }

  public static void main(String [] args){
    JFrame f = new JFrame();
    f.getContentPane().add(new Apfelmaennchen());
    f.pack();
    f.setVisible(true);
  }
}</code>

Das Programm ergibt das Bild aus Abbildung <ref name = "apfel"/>.<bild name = "apfel"
                pdfscale = "0.7"
                psscale = "0.9"
                caption = "Apfelmännchen."/></subsubsection></subsection><subsection titel = "Fonts und ihre Metrik">
Ähnlich wie für Farben hat ein Objekt des 
Typs <tt>Graphics</tt> auch einen aktuellen Font. Dieser ist vom 
Typ <tt>java.awt.Font</tt>. Ebenso wie es die 
Methoden <tt>getColor</tt>  und <tt>setColor</tt> in der 
Klasse <tt>Graphics</tt> gibt, gibt es dort auch 
Methoden <tt>getFont</tt> und <tt>setFont</tt>. <p/>

Eine wichtige Information zu einem Font ist beim Zeichnen, wieviel
Platz ein bestimmter Text für in diesem Font benötigt. Hierzu
existiert eine Klasse <tt>java.awt.FontMetrics</tt>. Entsprechend gibt
es Methoden, die für ein <tt>Graphics</tt>-Objekt ein Objekt mit den
aktuellen <tt>FontMetrics</tt>-Objekt zurückgibt. <example>
Folgende Kleine Klasse vergrößert nach und nach den Font, und
malt in verschiedenen Größen einen Text in ein Fenster.<code lang = "java"
                class = "FontTest"
                package = "name/panitz/gui/graphicsTest">package name.panitz.gui.graphicsTest;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Dimension;
import javax.swing.JPanel;
import javax.swing.JFrame;


class FontTest extends JPanel {

  public Dimension getPreferredSize(){
    return new Dimension(250,650);
  }
  
  public void paintComponent(Graphics g){
    <bluev>//die y-Koordinate für einen Text</bluev>
    int where = 0;

    <bluev>//25 mal</bluev>
    for (int i=1; i&lt;=25;i=i+1){
      <bluev>//nimm aktuellen Font und seine Maße</bluev>
      final Font f = g.getFont();
      final FontMetrics fm = g.getFontMetrics(f);

      <bluev>//gehe die Höhe des Fonts weiter in Richtung x</bluev>
      where = where + (f.getSize()) ;

      <bluev>//male &quot;hallo&quot;</bluev>
      g.drawString(&quot;hallo&quot;,0,where);      

      <bluev>//berechne wo der gerade gemalte String endet</bluev>
      //<bluev>und male dort &quot;welt&quot;</bluev>
      g.drawString
        (&quot;welt!&quot;,fm.stringWidth(&quot;hallo &quot;),where);      

      <bluev>//verändere die Fontgröße. Erhöhe sie um 1.</bluev>
      g.setFont(getFont().deriveFont(f.getSize2D()+1));
    }
  } 

  public static void main(String [] _){
    JFrame f = new JFrame(&quot;Fonts&quot;);
    f.getContentPane().add(new FontTest());
    f.pack();
    f.setVisible(true); 
  }
}</code>

Das Programm ergibt das Bild aus Abbildung <ref name = "FontTest"/>.<bild name = "FontTest"
                pdfscale = "0.7"
                psscale = "0.5"
                caption = "Verschiedene Fontgrößen."/></example></subsection><subsection titel = "Erzeugen graphischer Dateien">
Bisher haben wir alles auf dem Bildschirm in irgendeinen Fenster
gezeichnet. Das Schöne ist, daß wir die gleichen graphischen Objekte
jetzt benutzen können, um Graphiken in eine Datei zu schreiben. <p/>

Hierzu stellt Java die Klasse <tt>java.awt.image.RenderedImage</tt> zur Verfügung.  Für Objekte dieser Klasse gibt es ein Objekt des
Typs <tt>Graphics</tt>. Man kann also ein <tt>RenderedImage</tt>-Objekt erzeugen und mit beliebige <tt>paint</tt>-Methoden auf 
dessen <tt>Graphics</tt>-Objekt anwenden.<p/>
In der Klasse <tt>javax.imageio.ImageIO</tt> gibt
es schließlich Methoden, die es erlauben ein <tt>RenderedImage</tt>in eine Datei zu schreiben. <example>
Wir schreiben eine kleine Klasse mit Methoden, 
um das Bild einer graphischen Komponente in eine
Datei zu speichern.<p/>

Zunächst brauchen wir eine ganze Reihe von Klassen, die wir importieren:<code lang = "java"
                class = "ComponentToFile"
                package = "name/panitz/gui/graphicsFile">package name.panitz.gui.graphicsFile;

import name.panitz.crempel.tool.apfel.Apfelmaennchen;
import java.awt.image.BufferedImage;
import java.awt.image.RenderedImage;
import java.awt.Dimension;
import java.awt.Graphics;

import javax.imageio.ImageIO; 
import javax.swing.JComponent; 

import java.io.File;
import java.io.IOException;</code>

Wir schreiben eine Hauptmethode, die als Kommandozeilenparameter den
Namen der zu schreibenen Bilddatei übergeben bekommt:<code lang = "java"
                class = "ComponentToFile"
                sequel = "true"
                package = "name/panitz/gui/graphicsFile">public class ComponentToFile {
  public static void main(String [] args){</code>
Zu Testzwecken schreiben wir je eine <tt>png</tt>- und 
eine <tt>jpg</tt>-Datei, in die wir die Komponente zeichnen wollen:<code lang = "java"
                class = "ComponentToFile"
                sequel = "true"
                package = "name/panitz/gui/graphicsFile">   try {
     final JComponent component = new Apfelmaennchen();
     final RenderedImage image = createComponentImage(component);
     ImageIO.write(image,&quot;png&quot;, new File(args[0]+&quot;.png&quot;));
     ImageIO.write(image,&quot;jpg&quot;, new File(args[0]+&quot;.jpg&quot;));
    }catch (IOException e) {System.out.println(e);}
  }</code>

Die folgende Methode erzeugt das eigentliche Bild der Komponente:<code lang = "java"
                class = "ComponentToFile"
                sequel = "true"
                package = "name/panitz/gui/graphicsFile">  static public RenderedImage createComponentImage
                                (JComponent component) {</code>
Wir erzeugen ein Bildobjekt in der für die Komponente benötigten Größe.<code lang = "java"
                class = "ComponentToFile"
                sequel = "true"
                package = "name/panitz/gui/graphicsFile">     Dimension d = component.getPreferredSize();
     BufferedImage bufferedImage 
      = new BufferedImage((int)d.getWidth(),(int)d.getHeight()
                         ,BufferedImage.TYPE_INT_RGB);</code>
Nun besorgen wir dessen <tt>Graphics</tt>-Umgebung:<code lang = "java"
                class = "ComponentToFile"
                sequel = "true"
                package = "name/panitz/gui/graphicsFile">    Graphics g = bufferedImage.createGraphics();</code>

Darin läßt sich  unsere Komponente zeichnen:<code lang = "java"
                class = "ComponentToFile"
                sequel = "true"
                package = "name/panitz/gui/graphicsFile">   component.paint(g);</code>
Die Methode kann das fertig gezeichnete Bild als Ergebnis zurückgeben: <code lang = "java"
                class = "ComponentToFile"
                sequel = "true"
                package = "name/panitz/gui/graphicsFile">    return bufferedImage;
  }
}</code></example></subsection><subsection titel = "Graphics2D">
Seit Java 1.2 existiert eine Unterklasse der 
Klasse <tt>Graphics</tt> mit wesentlich mächtigeren Mehoden zum Zeichnen von
2-Dimenionalen Graphiken, die Klasse <tt>java.awt.Graphics2D</tt>. Leider
konnten nicht die Signaturen der entsprechenden Methoden <tt>paint</tt> in den
Komponentenklassen geändert werden, so daß dem
übergebene <tt>Graphics</tt>-Objekt zunächst zugesichert werden muß, daß es
sich um ein <tt>Graphics2D</tt>-Objekt handelt:<code>public void paint(Graphics g) {
    Graphics2D g2 = (Graphics2D) g;
    ...
}</code><tt>Graphics2D</tt> enthält Methoden zum Darstellen verschiedener Formen,
wahlweise umrandet oder gefüllt. Auf geometrische Formen können
Transformationen angewendet werden, einzelne Formen können kombiniert werden
zu komplexeren Figuren, Farbverläufe können definiert werden. Auch Text stellt
sich hierbei als geometrische Form dar.<example>Folgende Klasse benutzt willkürlich ein paar Eigenschaften 
der <tt>Graphics2D</tt>-Klasse, um einen Eindruck über die Arbeitsweise dieser
Klasse zu geben. Eine systematische Behandlung aller graphischen 
Methoden
ist nicht
Gegenstand dieser Vorlesung. <code class = "G2DTest"
                package = "name/panitz/gui/g2d"
                lang = "java">package name.panitz.gui.g2d;
import javax.swing.JPanel;
import javax.swing.JFrame;

import java.awt.font.*;
import java.awt.*;
import java.awt.geom.*;

public class G2DTest extends JPanel{
  int w = 550;
  int h = 650;

  public Dimension getPreferredSize(){
    return new Dimension(w,h);}

  public void paintComponent(Graphics g){
    Graphics2D g2 = (Graphics2D) g;
    TextLayout textTl 
     = new TextLayout
             (&quot;Kommunismus&quot;, new Font(&quot;Helvetica&quot;, 1, 96)
             , new FontRenderContext(null, false, false));

    AffineTransform textAt = new AffineTransform();
    textAt.translate(0,(float)textTl.getBounds().getHeight());
    Shape shape = textTl.getOutline(textAt);

    AffineTransform at = new AffineTransform();
    at.rotate(Math.toRadians(45));
    at.shear(1.5, 0.0);

    g2.transform(at);

    float dash[] = {10.0f};
    g2.setStroke(
      new BasicStroke
           (3.0f, BasicStroke.CAP_BUTT
           ,BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f)
    );

    g2.setPaint(
      new GradientPaint(0,0,Color.black,w,h
                       ,new Color(255,100,100),false)
    );

    g2.fill(shape);
    g2.setColor(Color.darkGray);
    g2.draw(shape);
  }
  
  public static void main(String [] _){
    JFrame f = new JFrame(&quot;G2&quot;);
    f.getContentPane().add(new G2DTest());
    f.pack();
    f.setVisible(true);
  }
}</code>

Das Programm öffnet das Fenster aus 
Abbildung<white/><ref name = "G2DTest"/> auf dem Bildschirm. <bild name = "G2DTest"
                pdfscale = "0.6"
                psscale = "0.9"
                caption = "Transformationen auf Text in Graphics2D."/></example></subsection></section><section titel = "Bäume graphisch darstellen">
      <subsection titel = "Bäume mit JTree graphisch darstellen">
Wir haben uns in dieser Vorlesung ausgiebig mit Bäumen beschäftigt,
sie aber bisher nicht graphisch sondern lediglich textuell
dargestellt. In diesem Kapitel sollen zwei Möglichkeiten zur
graphischen Darstellung von Bäumen in Java untersucht werden.
Zunächst benutzen wir eine bereits in der <tt>swing</tt>-Bibliothek
angebotene Komponente zur Baumdarstellung, anschließend definieren wir
eine eigene neue Komponente zur Baumdarstellung.<p/>


Im Paket <tt>javax.swing</tt> gibt es eine Klasse, die es erlaubt
beliebige Baumstrukturen graphisch darzustellen, die 
Klasse <tt>JTree</tt>. Diese Klasse übernimmt die graphische
Darstellung eines Baumes. Der darzustellende Baum ist dieser Klasse zu
übergeben. Hierzu hat sie einen Konstruktor, der einen Baum 
erhält: <tt>JTree(TreeNode root)</tt>.<p/>
Um entsprechend die Klasse <tt>JTree</tt> benutzen zu können, so daß
sie uns einen Baum darstellt, müssen wir einen Baum, der die
Schnittstelle <tt>javax.swing.tree.TreeNode</tt> implementiert, zur
Verfügung stellen. Diese Schnittstelle hat 7 relativ naheliegende
Methoden, die sich in ähnlicher Form fast alle in unserer 
Klasse <tt>Tree</tt> auch schon befinden:<code>package javax.swing.tree;
interface TreeNode{
  Enumeration children();
  int getChildCount(); 
  TreeNode getParent(); 
  boolean isLeaf(); 
  TreeNode getChildAt(int childIndex); 

  boolean getAllowsChildren(); 
  int getIndex(TreeNode node);
}</code>

Wir können unsere Klasse <tt>Tree</tt> entsprechend modifizieren,
damit sie diese Schnittstelle implementiert. Hierzu fügen wir
Implementierungen der in der Schnittstelle verlangten Methoden der
Klasse <tt>Tree</tt> hinzu und sorgen so dafür, daß unsere Bäume alle
Eigenschaften haben, so daß die Klasse <tt>JTree</tt> sie graphisch
darstellen können.<code>public class Tree&lt;a&gt;<redv>implements TreeNode</redv>{</code>

Entscheidend ist natürlich die Methode <tt>children</tt>, die inhaltlich
unserer Methode <tt>theChildren</tt> entspricht.
Leider benutzt die
Schnittstelle als Rückgabetyp eine weitere Klasse aus dem 
Paket <tt>java.util</tt>. Dieses ist die 
Schnittstelle <tt>Enumeration</tt>. Logisch ist sie fast
funktionsgleich mit der Schnittstelle <tt>Iterator</tt>. Die Existenz
dieser zwei sehr ähnlichen Schnittstellen hat historische Gründe. Mit
einer anonymen inneren Klassen können wir recht einfach ein
Rückgabeobjekt der Schnittstelle erzeugen.<code class = "Tree"
              package = "name/panitz/data/tree"
              sequel = "true"
              lang = "java">  public Enumeration&lt;TreeNode&gt; children() {
    final Iterator&lt;Tree&lt;a&gt;&gt; it = theChildren().iterator();

    return new Enumeration&lt;TreeNode&gt;(){
      public boolean hasMoreElements(){return it.hasNext();} 
      public Tree&lt;a&gt; nextElement() {return it.next();}
    };
  }</code>


Die Methoden  <tt>getChildCount</tt>,<white/><tt>getParent</tt>,<white/><tt>isLeaf</tt><white/><tt>getChildAt</tt> existieren bereits
oder sind einfach aus der bestehenden Klasse ableitbar.<code class = "Tree"
              package = "name/panitz/data/tree"
              sequel = "true"
              lang = "java">  public TreeNode getChildAt(int childIndex) {
    return theChildren().get(childIndex);
  }

  public int getChildCount(){return theChildren().size();}

  public TreeNode getParent(){return parent;}</code>

Die übrigen zwei Methoden aus der 
Schnittstelle <tt>TreeNode</tt> sind für unsere Zwecke
unerheblich. Wir implementieren sie so, daß sie eine Ausnahme werfen.<code class = "Tree"
              package = "name/panitz/data/tree"
              sequel = "true"
              lang = "java">  public boolean getAllowsChildren(){
    throw new UnsupportedOperationException();
  } 

  public int getIndex(TreeNode node) {
    throw new UnsupportedOperationException();
  }</code>

Schließlich ändern wir die Methode <tt>toString</tt> so ab, daß sie
nicht mehr eine <tt>String</tt>-Repräsentation des ganzen Baumes
ausgibt, sondern nur des aktuellen Knotens:<code class = "Tree"
              package = "name/panitz/data/tree"
              sequel = "true"
              lang = "java">  public String toString(){return mark().toString();}}</code>

Somit haben wir unsere Klasse <tt>Tree</tt> soweit 
massiert, daß sie
von der Klasse <tt>JTree</tt> als Baummodell genutzt werden kann. <example>
Wir können jetzt ein beliebiges Objekt der 
Klasse <tt>Tree</tt> der 
Klasse <tt>JTree</tt> übergeben, um es graphisch darzustellen.
Der Code hierzu ist denkbar einfach. <code class = "JTreeTest"
                package = "name/panitz/data/tree/example"
                lang = "java">package name.panitz.data.tree.example;

import javax.swing.JFrame;
import javax.swing.JTree;

public class JTreeTest {
  public static void main(String [] args){
    JFrame frame = new JFrame(&quot;Baumtest Fenster&quot;);
    frame.getContentPane()
         .<redv>add(new JTree(SkriptTree.getSkript()))</redv>;

    frame.pack();
    frame.setVisible(true);
  }
}</code>
Diese Methode erzeugt die graphische Baumdarstellung aus 
Abbildung<white/><ref name = "SkriptBaum"/>.<bild name = "SkriptBaum"
                pdfscale = "0.7"
                psscale = "0.8"
                caption = "Baumdarstellung mit JTree."/>

Dieser Baum reagiert dabei sogar auf Mausaktionen, in dem durch
  Klicken auf Baumknoten deren Kinder ein- und ausgeblendet werden
  können.  </example>


Die Klasse <tt>JTree</tt> verfügt noch über eine große Anzahl weiterer
Funktionalitäten, die wir hier nicht im Detail betrachten wollen.</subsection>
      <subsection titel = "Bäume zeichnen">
Im letzem Unterkapitel haben wir eine fertige Swingkomponente benutzt um Bäume
darzustellen. In diesem Abschnitt werden wir eine eigene Komponente schreiben,
die Bäume graphisch darstellt. Dabei soll ein Baum in der Weise gezeichnet
werden, wir wir es handschriftlich gerne machen: oben zentriert liegt die
Wurzel und Linien führen zu den weiter unten hingeschriebenen Kindern.<p/>

Die Hauptschwierigkeit hierbei wird sein, die einzelnen Positionen der
Baumknoten zu berechnen.<code class = "DisplayTree"
              package = "name/panitz/data/tree"
              lang = "java">package name.panitz.data.tree;

import java.util.Enumeration;

import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.tree.TreeNode;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Dimension;

public class DisplayTree extends JPanel{</code>
Ähnlich wie in der Klasse <tt>JTree</tt> enthält das Objekt, das einen
Baum graphisch darstellt, ein Baummodell:<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">  private TreeNode treeModell;</code>
In zwei Konstanten sei spezifiziert, wieviel Zwischenraum horizontal
zwischen Geschwistern und vertikal zwischen Eltern und Kindern liegen
soll. <code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">  static final public int VERTICAL_SPACE = 50;  
  static final public int HORIZONTAL_SPACE = 20;</code>
In einem Feld werden wir uns die Maße des benutzten Fonts vermerken.
Dieses ist wichtig, um die Größe eines Baumknotens zu errechnen.<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">    private FontMetrics fontMetrics = null;</code>
Die Felder für Höhe und Breite werden die Maße der Baumzeichnung
wiederspiegeln. <code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">  private int height=0;
  private int width=0;</code>
Diese Maße sind zu berechnen, abhängig vom Font der benutzt wird. Eine
bool&#39;scher Wert wird uns jeweils angeben, ob die Maße bereits
berechnet wurden.<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">  private boolean dimensionCalculated = false;</code>
Es folgen zwei naheliegende Konstruktoren.<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">  public DisplayTree(TreeNode tree){treeModell=tree;}

  public DisplayTree(TreeNode t,FontMetrics fm){
    treeModell=t;fontMetrics=fm;
  }</code>
Die schwierigste Methode berechnet, wie groß der zu 
zeichnende Baum wird:<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">  private void calculateDimension(){</code>
Zunächst stellen wir sicher, daß die Fontmaße bekannt sind:<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">
    if (fontMetrics==null){
      final Font font = getFont();
      fontMetrics = getFontMetrics(font);
    }</code>
Die Breite der Knotenmarkierung wird berechnet. Dieses ist die
    minimale Breite des Gesamtbaums. Zunächst berechnen wir die Breite
    des Wurzelknotens:<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">    final int x
      = fontMetrics.stringWidth(treeModell.toString());</code>
Für jedes Kind berechnen wir nun die Breite und Höhe. Die maximale
Höhe der Kinder bestimmt die Höhe des Gesamtbaums, die Summe aller
Breiten der Kinder, bestimmt die Breite des Gesamtbaums.<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">    final Dimension childrenDim = childrenSize();
    final int childrenX = (int)childrenDim.getWidth();
    final int childrenY = (int)childrenDim.getHeight();</code>
Mit der Höhe und Breite der Kinder, läßt sich die Höhe und Breite des
    Gesamtbaums berechnen:<code class = "DisplayTree"
              package = "name/panitz/data/tree"
              lang = "java"
              sequel = "true"
              commandchars = "|~^">    width=x&gt;childrenX?x:childrenX;

    height
      =  childrenY == 0
        ?fontMetrics.getHeight()
        :VERTICAL_SPACE+childrenY;

    dimensionCalculated = true;
  }</code>
Zum Berechnen der Größe aller Kinder haben wir oben eine Methode
  angenommen, die wir hier implementieren.<code class = "DisplayTree"
              package = "name/panitz/data/tree"
              lang = "java"
              sequel = "true"
              commandchars = "|~^">  Dimension childrenSize(){
    int x = 0;
    int y = 0;

    final Enumeration&lt;TreeNode&gt; it=treeModell.children();
    while (it.hasMoreElements()){
      final DisplayTree t
       = new DisplayTree(it.nextElement(),fontMetrics);

      y =  y &gt; t.getHeight()?y:t.getHeight();

      x=x+t.getWidth();

      if (it.hasMoreElements())  x=x+HORIZONTAL_SPACE;
    }
    return new Dimension(x,y);
  }</code>


Mehrere Methoden geben die entsprechende Größe aus, nachdem sie
 gegebenenfalls vorher ihre Berechnung angestoßen haben:<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">  public int getHeight(){
    if (!dimensionCalculated) calculateDimension();
    return height;
  }

  public int getWidth(){
    if (!dimensionCalculated) calculateDimension();
    return width;
  }

  public Dimension getSize(){
    if (!dimensionCalculated) calculateDimension();
    return new Dimension(width,height);
  }

  public Dimension getMinimumSize(){
    return getSize();
  }

  public Dimension getPreferredSize(){
    return getSize();
  }</code>
Schließlich die eigentliche Methode zum Zeichnen des Baumes. Hierbei
benutzen wir eine Hilfsmethode, die den Baum an eine bestimmte
    Position auf der Leinwand plaziert: <code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">  public void paintComponent(Graphics g){paintAt(g,0,0);}

  public void paintAt(Graphics g,int x,int y){
    fontMetrics = g.getFontMetrics();
    final String marks =treeModell.toString();</code>
Zunächst zeichne die Baummarkierung für die Wurzel des
    Knotens. Zentriere diese in bezug auf die Breite des zu
    zeichnenden Baumes:<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">    g.drawString
     (marks
     ,x+(getWidth()/2-fontMetrics.stringWidth(marks)/2)
     ,y+10);</code>
Jetzt sind die Kinder zu zeichenen. Hierzu ist  zu berechnen, wo ein
     Kind zu positionieren ist. Zusätzlich ist die Kante von
     Elternknoten zu Kind zu zeichnen. Hierzu merken wir uns den
     Startpunkt der Kanten beim Elternknoten. Auch dieser ist auf der
     Breite zentriert:<code class = "DisplayTree"
              sequel = "true"
              package = "name/panitz/data/tree"
              lang = "java">    final int startLineX = x+getWidth()/2;
    final int startLineY = y+10;</code>
Für jedes Kind ist jetzt die x-Position zu berechnen, das Kind zu
    zeichnen, und die Kante zum Kind zu zeichenen:<code class = "DisplayTree"
              package = "name/panitz/data/tree"
              lang = "java"
              sequel = "true"
              commandchars = "|~^">    final Enumeration it=treeModell.children();

    final int childrenWidth = (int)childrenSize().getWidth();

    //wieviel nach rechts zu rücken ist
    int newX
      = getWidth()&gt;childrenWidth?(getWidth()-childrenWidth)/2:0;

    //die y-Koordinate der Kinder
    final int nextY = y+VERTICAL_SPACE;

    while (it.hasMoreElements()){
      DisplayTree t
       = new DisplayTree((TreeNode)it.nextElement());

      //x-Positionen für das nächste Kind
      final int nextX = x+newX;
 
      //zeichne das Kind
      t.paintAt(g,nextX,nextY);

      //zeichne Kante
      g.drawLine(startLineX,startLineY
                ,nextX+t.getWidth()/2,nextY);

      newX = newX+t.getWidth()+HORIZONTAL_SPACE;
    }
  }
}</code>




Damit ist die Klasse zur graphischen Darstellung von Bäumen komplett
spezifiziert.  
Folgendes kleine Programm benutzt unsere 
Klasse <tt>DisplayTree</tt> in der gleichen Weise, wie wir auch die
Klasse <tt>JTree</tt> benutzt haben. Das optische Ergebnis ist in
Abbildung <ref name = "DisplayTreeTest"/> zu bewundern.<code class = "DisplayTreeTest"
              package = "name/panitz/data/tree/example"
              lang = "java">package name.panitz.data.tree.example;
import name.panitz.data.tree.DisplayTree;
import javax.swing.JFrame;
import javax.swing.JScrollPane;

class DisplayTreeTest {
  public static void main(String [] args){
    JFrame frame = new JFrame(&quot;Baum Fenster&quot;);
    frame.getContentPane()
         .add(new JScrollPane(
                new DisplayTree(SkriptTree.getSkript())));

    frame.pack();
    frame.setVisible(true);
  }
}</code><bild name = "DisplayTreeTest"
              pdfscale = "0.6"
              psscale = "1.3"
              caption = "Baum graphisch dargestellt mit DisplayTree."/>



Wir schreiben eine kleine Klasse mit Methoden, um das Bild eines Baumes in eine
Datei zu speichern.<p/>

Zunächst brauchen wir eine ganze Reihe von Klassen, die wir importieren:<code class = "TreeToFile"
              package = "name/panitz/data/tree"
              lang = "java">package name.panitz.data.tree;
import name.panitz.gui.graphicsFile.ComponentToFile;
import static name.panitz.gui.graphicsFile.ComponentToFile.*;

import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO; 
import javax.swing.JComponent;
import java.awt.image.RenderedImage;

public class TreeToFile{
  public static void treeToFile(Tree tree,String fileName){
    try {
     final JComponent component = new DisplayTree(tree);
     final RenderedImage image = createComponentImage(component);
     ImageIO.write(image,&quot;png&quot;, new File(fileName+&quot;.png&quot;));
     ImageIO.write(image,&quot;jpg&quot;, new File(fileName+&quot;.jpg&quot;));
    }catch (IOException e) {System.out.println(e);}
  }
}</code></subsection>
    </section><section titel = "Weitere Komponente und Ereignisse">
Im Prinzip haben wir bisher alles kennengelernt um graphische Benutzerflächen
und Anwendungen zu beschreiben. Die Schwierigkeit bei graphischen Anwendungen
liegt hauptsächlich in der schieren Menge der unterschiedlichen Komponenten
und ihrem Zusammenspiel. Die Anzahl der vordefinierten Komponenten der
Swing-Bibliothek ist immens. Diese Komponenten können auf eine Vielzahl von
unterschiedlichen Ereignisarten reagieren. Bisher haben wir nur die
Schnittstelle <tt>ActionListener</tt> kennengelernt, die lediglich ganz
allgemein ein Ereignis behandelt.<p/>

In diesem Abschnitt schauen wir uns ein paar wenige weitere Komponenten und
Ereignistypen an. <subsection titel = "Mausereignisse">
Ein in modernen graphischen Oberflächen häufigst benutztes Eingabemedium ist
die  Maus. Zwei verschiedene Ereignisarten sind für die Maus relevant:<itemize>
          <item>Mausereignisse, die sich auf das Drücken, Freilassen oder Klicken auf
einen der Mausknöpfe bezieht. Hierfür gibt es eine Schnittstelle zur
Behandlung solcher Ereignisse: <tt>MouseListener</tt>.</item>
          <item>Mausereignisse, die sich auf das Bewegen der Maus beziehen. Die
Behandlung solcher Ereignisse kann über eine Implementierung der 
Schnittstelle <tt>MouseMotionListener</tt> spezifiziert werden.</item>
        </itemize>

Entsprechend gibt es für graphische Komponenten Methoden, um solche
Mausereignisbehandler der Komponente 
hinzuzufügen: <tt>addMouseListener</tt> und <tt>addMouseMotionListener</tt>.<p/>

Um die Arbeit mit Ereignisbehandlern zu vereinfachen, gibt es für die
entsprechnden Schnittstellen im Paket <tt>java.awt.event</tt> prototypische
Implementierungen, in denen die Methoden der Schnittstelle so implementiert
sind, daß ohne Aktion auf die entsprechenden Ereignisse reagiert wird. Diese
prototypischen Implementierung sind Klassen, deren Namen 
mit <em>Adapter</em> enden. So gibt es zur 
Schnittstelle <tt>MouseListener</tt> die implementierende 
Klasse <tt>MouseAdapter</tt>. Will man eine bestimmte Mausbehandlung
programmieren, reicht es aus, diesen Adapter zu erweitern und nur die Methoden
zu überschreiben, für die bestimmte Aktionen vorgesehen sind. Es erübrigt sich
dann für alle sechs Methoden der 
Schnittstelle <tt>MouseListener</tt> Implementierungen vorzusehen.  <example>
Wir erweitern die Klasse <tt>Apfelmaennchen</tt> um eine Mausbehandlung.
Der mit gedrückter Maus markierte Bereich soll vergrößert in dem Fenster
dargestellt werden.<code lang = "java"
                class = "ApfelWithMouse"
                package = "name/panitz/crempel/tool/apfel">package name.panitz.crempel.tool.apfel;

import java.awt.Graphics;
import java.awt.event.*;
import javax.swing.JFrame;

public class ApfelWithMouse extends Apfelmaennchen{
  public ApfelWithMouse(){</code>

Im Konstruktor fügen wir der Komponente eine Mausbehandlung hinzu. Der
Mausbehandler merkt sich die Koordinaten, an denen die Maus gedrückt wird
und berechnet beim Loslassen des Mausknopfes den neuen darzustellenden Zahlenbereich:<code lang = "java"
                class = "ApfelWithMouse"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">    addMouseListener(new MouseAdapter(){
      int mouseStartX=0;
      int mouseStartY=0;

      public void <redv>mousePressed(MouseEvent e)</redv> {
        mouseStartX=e.getX();
        mouseStartY=e.getY();
      }
	
      public void <redv>mouseReleased(MouseEvent e)</redv> {
        int endX = e.getX();
        int endY = e.getY();
        startX = startX+(mouseStartX*zelle);
        startY = startY+(mouseStartY*zelle);
        zelle  = zelle*(endX-mouseStartX)/width;
        repaint();
      }
    });
  }</code>
Auch für diese Klasse sehen wir eine kleine Startmethode vor:<code lang = "java"
                class = "ApfelWithMouse"
                sequel = "true"
                package = "name/panitz/crempel/tool/apfel">  public static void main(String [] _){
    JFrame f = new JFrame();
    f.getContentPane().add(new ApfelWithMouse());
    f.pack();
    f.setVisible(true);
  }
}</code></example></subsection><subsection titel = "Fensterereignisse">
Auch für Fenster in einer graphischen Benutzeroberfläche existieren eine Reihe
von Ereignissen. Das Fenster kann minimiert oder maximiert werden, es kann das
aktive Fenster oder im Hintergrund sein und es kann schließlich auch
geschlossen werden. Um die Reaktion auf solche Ereignisse zu spezifizieren
existiert die Schnittstelle <tt>WindowListener</tt> mit entsprechender
prototypischer Adapterklasse <tt>WindowAdapter</tt>. Die Objekte der
Fensterereignisbehandlung können mit der 
Methode <tt>addWindowListener</tt> Fensterkomponenten hinzugefügt werden.<example>
In den bisher vorgestellten Programmen wird Java nicht beendet, wenn das
einzige Fenster der Anwendung geschlossen wurde. Man kann an der Konsole
sehen, daß der Javainterpreter weiterhin aktiv ist. Das liegt daran, daß wir
bisher noch nicht spezifiziert haben, wie die Fensterkomponenten auf das
Ereignis des Schließens des Fensters reagieren sollen. Dieses kann mit einem
Objekt, das <tt>WindowListener</tt> implementiert in der 
Methode  <tt>windowClosing</tt> spezifiziert werden. Wir schreiben hier eine
Version des Apfelmännchenprogramms, in dem das Schließen des Fensters den
Abbruch des gesammten Programms bewirkt.<code lang = "java"
                class = "ClosingApfelFrame"
                package = "name/panitz/crempel/tool/apfel">package name.panitz.crempel.tool.apfel;

import javax.swing.JFrame;
import java.awt.event.*;

public class ClosingApfelFrame {
  public static void main(String [] args){
    JFrame f = new JFrame();
    f.getContentPane().add(new ApfelWithMouse());
    f.addWindowListener(new WindowAdapter(){
      public void <redv>windowClosing</redv>(WindowEvent e) {
        <redv>System.exit(0)</redv>;
      }
    });
    f.pack();
    f.setVisible(true);
  }
}</code></example></subsection><subsection titel = "Weitere Komponenten">
Um einen kleinen Überblick der vorhandenen Swing Komponenten zu bekommen,
können wir ein kleines Programm schreiben, daß möglichst viele Komponenten
einmal instanziiert. Hierzu schreiben wir eine kleine Testklasse:<code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^">package name.panitz.gui.example;

import javax.swing.*;
import java.awt.*;
import java.util.*;

public class ComponentOverview  {
  public ComponentOverview(){</code>

Darin definieren wir eine Reihung von einfachen Swing-Komponenten:
 <code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^"
              sequel = "true">   JComponent [] cs1 =
    {new JButton(&quot;knopf&quot;)
    ,new JCheckBox(&quot;check mich&quot;)
    ,new JRadioButton(&quot;drück mich&quot;)
    ,new JMenuItem(&quot;ins Menue mit mir&quot;)
    ,new JComboBox(combos)
    ,new JList(combos)
    ,new JSlider(0,350,79)
    ,new JSpinner(new SpinnerNumberModel(18,0.0,42.0,2.0))
    ,new JTextField(12)
    ,new JFormattedTextField(&quot;hallo&quot;)
    ,new JLabel(&quot;einfach nur ein Label&quot;)
    ,new JProgressBar(0,42)
    };</code>

Sowie eine zweite Reihung von komplexeren Swing-Komponenten:
 <code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^"
              sequel = "true">   JComponent [] cs2 =
    {new JColorChooser(Color.RED)
    ,new JFileChooser()
    ,new JTable(13,5)
    ,new JTree()
    };</code>

Diese beiden Reihungen zeigen sollen mit einer Hilfsmethode 
in einem Fenster angezeigt werden:<code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^"
              sequel = "true">   displayComponents(cs1,3);
   displayComponents(cs2,2);
  }</code>

Für die Listen- und Auswahlkomponenten oben haben wir eine Reihung von
Strings benutzt:<code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^"
              sequel = "true">  String [] combos = {&quot;friends&quot;,&quot;romans&quot;,&quot;contrymen&quot;};</code>

Bleibt die Methode zu schreiben, die die Reihungen von Komponenten anzeigen
kann. Als zweites Argument bekommt diese Methode übergeben, in wieviel Spalten
die Komponenten angezeigt werden sollen.<code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^"
              sequel = "true">  public void displayComponents(JComponent [] cs,int col){</code>

Ein Fenster wird definiert, für das eine Gridlayout-Zwischenkomponente mit
genügend Zeilen erzeugt wird: <code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^"
              sequel = "true">    JFrame f = new JFrame();
    JPanel panel = new JPanel();
    panel.setLayout(
     new GridLayout(cs.length/col+(cs.length%col==0?0:1),col));</code>

Für jede Komponente wird ein <tt>Panel</tt> mit Rahmen und den Klassennamen
der Komponente als Titel erzeugt und der Zwischenkomponente hinzugefügt: <code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^"
              sequel = "true">    for (JComponent c:cs){
      JPanel p = new JPanel();
      p.add(c);  
      p.setBorder(BorderFactory
                 .createTitledBorder(c.getClass().getName()));  
      panel.add(p);
    }</code>

Schließlich wird noch das Hauptfester zusammengepackt:<code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^"
              sequel = "true">    f.getContentPane().add(panel);
    f.pack();
    f.setVisible(true);
  }</code>
Und um alles zu starten, noch eine kleine Hauptmethode:<code lang = "java"
              class = "ComponentOverview"
              package = "name/panitz/gui/example"
              commandchars = "|$^"
              sequel = "true">  public static void main(String [] _){
    new  ComponentOverview();
  }
}</code>

Wir erhalten einmal die Übersicht von Komponenten wie in 
Abbildung<white/><ref name = "Components1"/> und einmal wie
in Abbildung<white/><ref name = "Components2"/> dargestellt.<bild name = "Components1"
              pdfscale = "0.6"
              psscale = "1.1"
              caption = "Überblick über einfache Komponenten."/><p/><bild name = "Components2"
              pdfscale = "0.5"
              psscale = "1.1"
              caption = "Überblick über komplexere Komponenten."/>


Womit wir uns noch nicht im einzelnen beschäftigt haben, ist das Datenmodell,
das hinter den einzelnen komplexeren Komponenten steht. Im nächsten
Hauptkapitel werden insbesondere Bäume als Datenstruktur, die auch in einer
graphischen Komponente darstellbar ist, untersucht werden.</subsection></section><section titel = "Swing und Steuerfäden">
In der GUI-Programmierung kommt es oft vor, daß Dinge nebenläufig verlaufen
sollen. Hierzu kennen wir das Prinzip von Steuerfäden. Und tatsächlich
scheinen  viele Dinge in unseren GUIs bisher schon nebenläufig zu 
funktionieren. 
Die verschiedenen Objekte zur Ereignisbehandlung  fragen nebenläufig ab, ob
ein Ereignis aufgetreten ist, auf das sie reagieren sollen oder 
nicht. Solange man nur diese Nebenläufigkeit nutzt, die in Swing quasi für die
Ereignisbehandlung fest eingebaut ist, so bekommt man keine problematischen
Fälle. Im Java Handbuch von Sun<cite label = "javatutorial"/> gibt es daher 
eine erste große Empfehlung im
bezug auf Steuerfäden:<quote>The first rule of using threads is this: avoid them when you
can.</quote><p/>  

Oft braucht man aber Nebenläufigkeit. Wobei man zwei große
Anwendungsfälle identifizieren kann, in denen in einem GUI Nebenläufigkeit
wünschenswert ist.<itemize>
        <item>Bestimmte Operationen können sehr lange dauern und damit das GUI
blockieren. Das Laden oder Bearbeiten von Multimediadateien kann unter
Umständen sehr lange dauern. Während dieser Zeit, werden Fensterinhalte nicht
aktualisiert. </item>
        <item>Für Animationen soll nach bestimmten Zeitintervallen die Graphik eines
GUIs verändert und neu gezeichnet werden. Hierzu benötigt man so etwas wie 
ein <tt>sleep</tt> der Steuerfäden.</item>
      </itemize><example>
Wir können uns zunächst davon überzeugen, daß die einzelnen Komponenten in
einer Swinganwendung nicht in einzelnen Steuerfäden laufen. Hierzu schreiben
wir ein Programm mit zwei Knopfkomponenten, von denen der eine eine 
Ereignisbehandlung hat, die nicht terminiert.<code lang = "java"
              class = "GuiHangs"
              package = "name/panitz/swing/threadTest">package name.panitz.swing.threadTest;

import javax.swing.JFrame;
import javax.swing.JButton;
import java.awt.event.*;

public class GuiHangs {
  public static void main(String [] _){
    JFrame f1 = new JFrame(&quot;f1&quot;);
    JFrame f2 = new JFrame(&quot;f2&quot;);
    JButton b1 = new JButton(&quot;b1&quot;);
    JButton b2 = new JButton(&quot;b2&quot;);

    b1.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent _){
        System.out.println(&quot;b1 action&quot;);
      }
    });

    b2.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent _){
        System.out.println(&quot;b2 action&quot;);
        <redv>while (true){}</redv>
      }
    });

    f1.getContentPane().add(b1);
    f2.getContentPane().add(b2);
    f1.pack();
    f2.pack();
    f1.setVisible(true);
    f2.setVisible(true);
  }
}</code>
Starten wir dieses Programm, so werden zunächst zwei Fenster mit Knöpfen
    geöffnet. Sobald der Knopf <tt>b2</tt> das erste Mal gedrückt wird, hängt
    die komplette Anwendung. Es können keine Aktionen mehr durchgeführt werden
    und die Fenster werden auch nicht mehr neu gezeichnet.</example>

Leider ist Swing so konzipiert, daß man nicht auf naive Weise eigene Objekte
vom Typ <tt>Thread</tt> erzeugen und nebenläufig starten kann. Man spricht
davon, daß Swing nicht <em>thread safe</em> ist. Insbesondere in den
Zeichenmethoden der Komponenten, wie <tt>paintComponent</tt> darf man nicht
eigene Steuerfäden benutzen. Das GUI könnte sich sonst mit den Steuerfäden zur
Ereignisbehandlung in den Zeichenmethoden zur Darstellung der Komponenten auf
unkontrollierte Weise verwurschteln.<p/>

Um einen sicheren Umgang mit Steuerfäden zu gewährleisten, stellt Swing ein
paar Hilfsklassen zur Verfügung, die die wichtigen Anwendungsfälle für
Steuerfäden in GUIs abdecken. Diese Hilfsklasse sorgen dafür, daß weitere
Steuerfäden immer mit den Steuerfäden zur Ereignisbehandlung konform sind.<subsection titel = "Timer in Swing">
Um zeitlich immer wiederkehrende Ereignisse in GUIs zu prgrammieren gibt in
Swing eine Hilfsklasse <tt>Timer</tt>. Objekte dieser Klasse können so
instanziiert werden, daß sie in bestimmten Zeitabständen Ereignisse
auslösen. Der <tt>Timer</tt> ist also so etwas wie ein
Ereignisgenerator. Zusätzlich gibt man einem <tt>Timer</tt>-Objekt auch 
einen <tt>ActionListener</tt> mit, der spezifiziert, wie auf diese in
zeitintervallen auftretenen Ereignisse reagiert werden soll.<example>Folgende Klasse implementiert eine simple Uhr. In 
einem <tt>JLabel</tt> wird die aktuelle Zeit angegeben. Die Komponente wird
einem <tt>Timer</tt> übergeben, der jede Sekunde eine neues
Ereigniserzeugt. Diese Ereignisse sorgen dafür, daß die Zeit im Label
aktualisiert wird.<code lang = "java"
                class = "Uhr"
                package = "name/panitz/swing/threads">package name.panitz.swing.threads;

import javax.swing.*;
import java.util.Date;
import java.awt.event.*;</code>
Die Klasse Uhr ist nicht nur ein <tt>JPanel</tt>, in dem 
ein <tt>JLabel</tt> benutzt wird, Datum und Uhrzeit anzuzeigen, sondern
implementiert gleichfalls auch einen <tt>ActionListener</tt>.<code lang = "java"
                class = "Uhr"
                package = "name/panitz/swing/threads"
                sequel = "true">public class Uhr extends JPanel <redv>implements ActionListener</redv>{</code>
Zunächst sehen wir das Datumsfeld für diese Komponente vor:<code lang = "java"
                class = "Uhr"
                package = "name/panitz/swing/threads"
                sequel = "true">  JLabel l = new JLabel(new Date()+&quot;&quot;);</code>
Im Konstruktor erzeugen wir ein Objekt vom Typ <tt>Timer</tt>. Dieses Objekt
soll alle Sekunde (alle 1000 Millisekunden) ein Ereignis erzeugen. 
Dem <tt>Timer</tt> wird das gerade im Konstruktor erzeute Objekt vom 
Typ <tt>Uhr</tt> übergeben, das, da es ja 
einen  <tt>ActionListener</tt> implementiert, auf diese Ereignisse reagieren
soll. <code lang = "java"
                class = "Uhr"
                package = "name/panitz/swing/threads"
                sequel = "true">  public Uhr (){
    <redv>new Timer(1000,this).start();</redv>
    add(l);	
  }</code>
Um die Schnittstelle <tt>ActionListener</tt> korrekt zu implementieren, muß
die Methode <tt>actionPerformed</tt> implementiert werden. In dieser setzen
wir jeweils Datum und Uhrzeit mit dem aktuellen Wert neu ins Label.<code lang = "java"
                class = "Uhr"
                package = "name/panitz/swing/threads"
                sequel = "true">  public void <redv>actionPerformed</redv>(ActionEvent _){
    <redv>l.setText(&quot;&quot;+new Date());</redv>
  }</code>
Und natürlich sehen wir zum Testen eine kleine Hauptmethode vor, die die Uhr
in einem Fensterrahmen anzeigt.<code lang = "java"
                class = "Uhr"
                package = "name/panitz/swing/threads"
                sequel = "true">  public static void main(String [] _){
    JFrame f = new JFrame();
    f.getContentPane().add(new Uhr());
    f.pack();
    f.setVisible(true);
  }
}</code>
Das so erzeugte Fenster mit einer laufenden Uhr findet sich in 
Abbildung<white/><ref name = "Uhr"/> dargestellt.<bild name = "Uhr"
                pdfscale = "0.8"
                psscale = "0.5"
                caption = "Eine einfache Digitaluhr."/></example><aufgabe>Implementieren Sie eine Analoguhr. Das Ziffernblatt dieser Uhr können
Sie dabei mit den Methoden auf einem <tt>Graphics</tt>-Objekt zeichnen, oder
Sie können versuchen eine Bilddatei zu laden und das Ziffernblatt als Bild
bereitstellen. Als Anregung für ein  Ziffernblatt können Sie sich das Bild
des 
Ziffernblatts <exlink address = "http://www.panitz.name/prog2/examples/images/wiebking.jpg">der handgefertigten Sekundenuhr</exlink> des Uhrmachers 
G.Wiebking herunterladen.</aufgabe><subsubsection titel = "Animationen mit Timern">
Mit dem Prinzip des Timers können wir jetzt auf einfache Weise Animationen
realisieren. In einer Animation bewegt sich etwas. Dieses drücken wir durch
eine entsprechende Schnittstelle aus:<code lang = "java"
                class = "Animation"
                package = "name/panitz/animation">package name.panitz.animation;

public interface Animation {
  public void move();
}</code>

Wir wollen einen besonderen <tt>JPanel</tt> realisieren, in dem sich etwas
bewegen kann. Damit soll ein solcher <tt>JPanel</tt>  auch eine Animation
sein. Es bietet sich an, eine abstrakte Klasse zu schreiben, in der die
Methode <tt>move</tt> noch nicht implementiert ist:<code lang = "java"
                class = "AnimatedJPanel"
                package = "name/panitz/animation">package name.panitz.animation;

import javax.swing.JPanel;
import javax.swing.Timer;
import java.awt.event.*;

public abstract class AnimatedJPanel 
  extends JPanel implements Animation {</code>
Um zeitgesteuert das Szenario der Animation zu verändern, brauchen wir 
einen <tt>Timer</tt>.<code lang = "java"
                sequel = "true"
                class = "AnimatedJPanel"
                package = "name/panitz/animation">  Timer t;</code>

Im Konstruktor wird dieser initialisiert. Als Ereignisbehandlung wird ein
Ereignisbehandlungsobjekt erzeugt, das die Methode <tt>move</tt> aufruft, also
dafür sorgt, daß die Szenerie sich weiterbewegt und das dafür sorgt, daß die
Szenerie neu gezeichnet wird. Wir starten diesen Timer gleich.<code lang = "java"
                sequel = "true"
                class = "AnimatedJPanel"
                package = "name/panitz/animation">  public AnimatedJPanel(){
    super(true);
    t = new Timer(29,new ActionListener(){
      public void actionPerformed(ActionEvent _){
        move();
        repaint();
      }
    });
    t.start();
  }
}</code>

Jetzt können wir durch implementieren der Methode <tt>move</tt> und 
Überschreiben der Methode <tt>paintComponent</tt> beliebige Animationen
erzeugen. Als erstes schreiben wir eine Klasse in der ein Kreis sich auf und
ab bewegt:<code lang = "java"
                class = "BouncingBall"
                package = "name/panitz/animation">package name.panitz.animation;

import java.awt.Graphics;
import java.awt.Dimension;
import java.awt.Color;
import javax.swing.JFrame;

public class BouncingBall extends AnimatedJPanel {</code>

Die Größe des Kreises und des Spielfeldes setzen wir in Konstanten fest:<code lang = "java"
                sequel = "true"
                class = "BouncingBall"
                package = "name/panitz/animation">  final int width = 100;
  final int height = 200;
  final int ballSize = 20;</code>
Der Ball soll sich entlang der y-Achse bewegen, und zwar pro Bild um 4 Pixel:<code lang = "java"
                sequel = "true"
                class = "BouncingBall"
                package = "name/panitz/animation">  int yDir = 4;</code>

Anfangs soll der Ball auf der Hälfte der x-Achse liegen und ganz oben im Bild
liegen: <code lang = "java"
                sequel = "true"
                class = "BouncingBall"
                package = "name/panitz/animation">  int ballX = width/2-ballSize/2;
  int ballY = 0;</code>
Wir bewegen den Ball. Wenn er oben oder unten am Spielfeldrand anstößt, so
ändert er seine Richtung: <code lang = "java"
                sequel = "true"
                class = "BouncingBall"
                package = "name/panitz/animation">  public void move(){
    if (ballY&gt;height-ballSize || ballY&lt;0) yDir=-yDir;
    ballY=ballY+yDir;
  }</code>  

Zum Zeichnen, wird ein roter Hintergrund gezeichnet und der Kreis an seiner
aktuellen Position.<code lang = "java"
                sequel = "true"
                class = "BouncingBall"
                package = "name/panitz/animation">  public void paintComponent(Graphics g){
    g.setColor(Color.RED);
    g.fillRect(0,0,width,height);
    g.setColor(Color.YELLOW);
    g.fillOval(ballX,ballY,ballSize,ballSize); 
  }</code>
Unsere Größe wird verwendet als bevorzugte Größe der Komponente:<code lang = "java"
                sequel = "true"
                class = "BouncingBall"
                package = "name/panitz/animation">  public Dimension getPreferredSize(){
    return new Dimension(width,height);
  }</code>

Und schließlich folgt eine kleine Hauptmethode zum Starten der Animation.<code lang = "java"
                sequel = "true"
                class = "BouncingBall"
                package = "name/panitz/animation">  public static void main(String [] _){
    JFrame f = new JFrame(&quot;&quot;);
    f.getContentPane().add(new BouncingBall());
    f.pack();
    f.setVisible(true);
  }
}</code><aufgabe>Schreiben Sie eine Animation, in der zwei Kreise sich bewegen. Die
Kreise sollen an den Rändern der Spielfläche abprallen und sie sollen
ihre Richtung ändern, wenn sie sich berühren.</aufgabe><aufgabe>Schreiben Sie eine Animation, deren Verhalten über Mausklicks
beeinflussen können.</aufgabe></subsubsection></subsection><subsection titel = "Eine kleine Spielbibliothek">
In diesem Kapitel wollen wir den <tt>Timer</tt> aus Swing nutzen, um eine
kleine Bibliothek zum schreiben von spielen zu entwickeln. Ein Spiel soll
dabei auf einer zweidimensionalen Fläche stattfinden, auf der sich Objekte
bewegen. Die Bewegung bestimmter Objekte kann dabei über die Tastatur oder die
Maus beeinflußt werden. Die Objekte können  kollidieren und ihre Richtungen
ändern. Wir benötigen also ein fundamentales Konzept, zweidimensionale 
Objekte die sich bewegen können. Dieses sei durch eine Schnittstelle
ausgedrückt: <code class = "AMovable"
              lang = "java"
              package = "name/panitz/games">package name.panitz.games;
//import java.awt.Graphics;

public interface AMovable{
  public void move();
  public boolean touches(int x, int y);
  public void reverseXDirection();
  public void reverseYDirection();  
  public void reverseDirection();

  public boolean leftOf(int x);    
  public boolean rightOf(int x);   
  public boolean above(int     y); 
  public boolean underneath(int y);

  public int getX();
  public void setX(int x);
  public int getY();
  public void setY(int y);
  public int getMoveX();
  public void setMoveX(int x);
  public int getMoveY();
  public void setMoveY(int y);
  public int getHeight();
}</code><code class = "Movable"
              lang = "java"
              package = "name/panitz/games">package name.panitz.games;
import java.awt.Graphics;

public interface Movable extends AMovable{
  public void paintMeTo(Graphics g);
}</code><code class = "ASimpleMovable"
              lang = "java"
              package = "name/panitz/games">package name.panitz.games;

public class ASimpleMovable implements AMovable{
  protected int x=2;
  protected int y=2;
  protected int moveX=1;
  protected int moveY=1;
  protected int width=10;
  protected int height=10;

  public void move(){
    setX(getX()+getMoveX());
    setY(getY()+getMoveY());
  }

  public void reverseYDirection(){  
    moveY=-1*moveY;
  }

  public void reverseXDirection(){  
    moveX=-1*moveX;
  }

  public void reverseDirection(){
      reverseXDirection();
      reverseYDirection();
  }

  public boolean touches(int x, int y){
    return  x&gt;=getX()&amp;&amp;x&lt;=getX()+width
         &amp;&amp; y&gt;=getY()&amp;&amp;y&lt;=getY()+height;
  }

  public boolean leftOf(int x)    {return x&gt;=getX();}
  public boolean rightOf(int x)   {return x&lt;=getX()+width;}
  public boolean above(int     y) {return getY()&lt;=y;}
  public boolean underneath(int y){return getY()+height&gt;=y;}

  public int getX(){return x;}
  public void setX(int x){this.x=x;}
  public int getY(){return y;}
  public void setY(int y){this.y=y;}
  public int getMoveX(){return moveX;}
  public void setMoveX(int x){moveX=x;}
  public int getMoveY(){return moveY;}
  public void setMoveY(int y){moveY=y;}
  public int getHeight(){return height;}
}</code><code class = "SimpleMovable"
              lang = "java"
              package = "name/panitz/games">package name.panitz.games;
import java.awt.Graphics;
import java.awt.Color;

public class SimpleMovable extends ASimpleMovable implements Movable{
  public void paintMeTo(Graphics g){
    g.setColor(Color.YELLOW);
    g.fillRect(x,y,width,height); 
  }
}</code><code lang = "java"
              class = "SimpleAnimation"
              package = "name/panitz/games">package name.panitz.games;

import name.panitz.animation.AnimatedJPanel;
import java.awt.Graphics;
import java.awt.Dimension;
import java.awt.Color;
import javax.swing.JFrame;

import java.util.List;
import java.util.ArrayList;
import java.awt.event.*;

public class SimpleAnimation extends  AnimatedJPanel{
  final int width = 400;
  final int height = 300;
  final List&lt;Movable&gt; mvs = new ArrayList&lt;Movable&gt;();
    
  public SimpleAnimation(){
    addMouseListener(new MouseAdapter(){
      public void mouseClicked(MouseEvent me){
        mvs.add(new SimpleMovable());
      } 
    });
  }

  public void move(){
    for (Movable mv:mvs) mv.move();
  }  

  public void paintComponent(Graphics g){
    g.setColor(Color.RED);
    g.fillRect(0,0,width,height);
    for (Movable mv:mvs) mv.paintMeTo(g);
  }

  public Dimension getPreferredSize(){
    return new Dimension(width,height);
  }

  public static void main(String [] _){
    JFrame f = new JFrame(&quot;&quot;);
    f.getContentPane().add(new SimpleAnimation());
    f.pack();
    f.setVisible(true);
  }
}</code><subsubsection titel = "Das Telespiel Pong">
          <code class = "Ball"
                lang = "java"
                package = "name/panitz/games">package name.panitz.games;
import java.awt.Graphics;
import java.awt.Color;

public class Ball extends SimpleMovable{
    public Ball(){}
    public Ball(int x,int y){this.x=x;this.y=y;moveX=3;}

  public void paintMeTo(Graphics g){
    g.setColor(Color.YELLOW);
    g.fillOval(x,y,width,height); 
  }
}</code>
          <code class = "Paddle"
                lang = "java"
                package = "name/panitz/games">package name.panitz.games;
import java.awt.Graphics;
import java.awt.Color;

public class Paddle extends SimpleMovable{
  public Paddle(int xPos){
    x=xPos;
    width=10;
    height=30;
    moveX=0;
    moveY=2;
  }
}</code>
          <code class = "Pong"
                lang = "java"
                package = "name/panitz/games">package name.panitz.games;

import name.panitz.animation.AnimatedJPanel;
import java.awt.Graphics;
import java.awt.event.*;
import java.awt.Dimension;
import java.awt.Color;
import javax.swing.JFrame;

import java.util.List;
import java.util.ArrayList;

public class Pong extends AnimatedJPanel{
  enum Player{left,right};
  Player nextPlayer=Player.left;

  final char leftPlayerKey = &#39;a&#39;;
  final char rightPlayerKey = &#39;l&#39;;
  final char newBallKey = &#39; &#39;;
  final List&lt;Movable&gt; mvs = new ArrayList&lt;Movable&gt;();
  final Movable leftPaddle = getPaddle(10); 
  final Movable rightPaddle = getPaddle(getWidth()-20); 
  final Movable[] paddles = {leftPaddle,rightPaddle};

  Movable ball = null;

  int leftPoints=0;
  int rightPoints=0;

  Movable getPaddle(int x){return new Paddle(x);}
  Movable getBall(int x,int y){return new Ball(x,y);}

  public Pong(){
    mvs.add(leftPaddle);
    mvs.add(rightPaddle);

    setFocusable(true);
    addKeyListener(new KeyAdapter(){
      public void keyPressed(KeyEvent e){
	if (e.getKeyChar() == leftPlayerKey){
          leftPaddle.setMoveY(Math.abs(leftPaddle.getMoveY()));
        }
        if (e.getKeyChar() == rightPlayerKey){
          rightPaddle.setMoveY(Math.abs(rightPaddle.getMoveY()));
        }
      }
      public void keyReleased(KeyEvent e){ 
        if (e.getKeyChar() == leftPlayerKey){
          leftPaddle.setMoveY(-Math.abs(leftPaddle.getMoveY()));
        } 
        if (e.getKeyChar() == rightPlayerKey){
          rightPaddle.setMoveY(-Math.abs(rightPaddle.getMoveY()));
        }
      }
      public void keyTyped(KeyEvent e){
        if (ball==null &amp;&amp; e.getKeyChar() == newBallKey){
          switch (nextPlayer){
            case right: 
      	      ball=getBall(getWidth()-32,rightPaddle.getY()+10);
              ball.setMoveX(-ball.getMoveX());
              break;
            case left: 
              ball=getBall(22,leftPaddle.getY()+10);
              break;
	    }
            mvs.add(ball);
        }
      }
    });
  }

  public void move(){
    rightPaddle.setX(getWidth()-20); 
    if (ball!=null){
      if (ball.above(0) || ball.underneath(getHeight())){
        ball.reverseYDirection();
        ball.move();
      }

      if (ball.leftOf(0) ){
	mvs.remove(ball);
	ball=null;
	rightPoints=rightPoints+1;
	nextPlayer=Player.right;
      }

      else if (ball.rightOf(getWidth()) ){
	mvs.remove(ball);
	ball=null;
	leftPoints=leftPoints+1;
	nextPlayer=Player.left;
      }

      else if (
         (    ball.rightOf(getWidth()-20) 
          &amp;&amp; ball.underneath(rightPaddle.getY())
	  &amp;&amp; ball.above(rightPaddle.getY()+rightPaddle.getHeight())
         )
         ||
         (    ball.leftOf(20) 
          &amp;&amp; ball.underneath(leftPaddle.getY())
	  &amp;&amp; ball.above(leftPaddle.getY()+leftPaddle.getHeight())
         )
        )
	ball.reverseXDirection();
    }

    for (Movable mv:mvs) mv.move();
    for (Movable p:paddles){
      if (p.getY()&lt;0) p.setY(0);
      if (p.getY()+p.getHeight()&gt;getHeight()) 
        p.setY(getHeight()-p.getHeight());
    }
  }  

  public void paintComponent(Graphics g){
    g.setColor(Color.GREEN);
    g.fillRect(0,0,getWidth(),getHeight());
    for (Movable mv:mvs) mv.paintMeTo(g);
    g.setColor(Color.BLACK);
    g.drawString(&quot;&quot;+leftPoints,40,40);
    g.drawString(&quot;&quot;+rightPoints,getWidth()-80,40);
  }

  public Dimension getPreferredSize(){
    return new Dimension(400,300);
  }

  public static void main(String [] _){
    JFrame f = new JFrame(&quot;&quot;);
    f.getContentPane().add(new Pong());
    f.pack();
    f.setVisible(true);
  }
}</code>
          <paragraph titel = "als Applet">
            <code class = "PongApplet"
                  lang = "java">import javax.swing.*;
import name.panitz.games.Pong;
public class PongApplet extends JApplet{
  public PongApplet(){add(new Pong());}
}</code>
            <code class = "ViewPong"
                  lang = "html">&lt;html&gt;&lt;body&gt;
&lt;h1&gt;Das Spiel Pong&lt;/h1&gt;
&lt;b&gt;Tastaturbelegung:&lt;/b&gt;&lt;p /&gt;

&#39;a&#39;: linker Schläger&lt;br/&gt;
&#39;l&#39;: rechter Schläger&lt;br/&gt;
&#39; &#39;: neuer Ball&lt;br/&gt;

&lt;applet code=&quot;PongApplet.class&quot; 
        codebase=&quot;../classes/&quot;
        width=&quot;400&quot; height=&quot;300&quot;&gt;
Der Browser ignoriert das Applets. Hier wäre jetzt ein Spiel
gewesen.
&lt;/applet&gt;
&lt;/body&gt;&lt;/html&gt;</code>
          </paragraph>
          <paragraph titel = "Sound und Bilder">
            <code class = "SmileBall"
                  lang = "java"
                  package = "name/panitz/games">package name.panitz.games;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.image.ImageObserver;

public class SmileBall extends Ball{
  static final Toolkit toolkit = Toolkit.getDefaultToolkit();
  static Image smile;
  ImageObserver obs;

  public SmileBall(ImageObserver obs){
    this.obs=obs;
    try {
      if (smile==null)
        smile = toolkit.getImage(
                 getClass().getClassLoader()
                  .getResource(&quot;../../images/smile.gif&quot;));
    }catch(Exception e){System.out.println(e);}
    width=40;height=30;
    moveX=8;
    moveY=6;
  }

  public SmileBall(ImageObserver obs,int x,int y){
    this(obs);
    this.x=x;this.y=y;
  }

  public void paintMeTo(Graphics g){
    g.drawImage(smile, x, y, obs);
  }
 
  public void loadImages(java.applet.Applet a){
    try {
      smile = a.getImage(a.getCodeBase(),&quot;../../images/smile.gif&quot;);
    }catch(Exception _){}
  }
}</code>
            <code class = "ImagePaddle"
                  lang = "java"
                  package = "name/panitz/games">package name.panitz.games;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.image.ImageObserver;

public class ImagePaddle extends Paddle{
  static Image paddle;
  ImageObserver obs;

  public ImagePaddle(  ImageObserver obs,int x){
    super(x);
    this.obs=obs;
    try {
      if (paddle==null)
        paddle = SmileBall.toolkit.getImage(
                 getClass().getClassLoader()
                  .getResource(&quot;../../images/schlaeger.gif&quot;));
    }catch(Exception e){System.out.println(e);}
    width=10;height=99;
    moveY=4;
  }

  public void paintMeTo(Graphics g){
    g.drawImage(paddle, x, y, obs);
  }
 
  public void loadImages(java.applet.Applet a){
    try {
      paddle = a.getImage(a.getCodeBase(),&quot;../../images/smile.gif&quot;);
    }catch(Exception _){}
  }
}</code>
            <code class = "ImagePong"
                  lang = "java"
                  package = "name/panitz/games">package name.panitz.games;
import java.awt.Dimension;
import javax.swing.JFrame;
public class ImagePong extends Pong{
  Movable getPaddle(int x){return new ImagePaddle(this,x);}
  Movable getBall(int x,int y){return new SmileBall(this,x,y);}  
  public Dimension getPreferredSize(){
    return new Dimension(800,600);
  }

  public static void main(String [] _){
    JFrame f = new JFrame(&quot;&quot;);
    f.getContentPane().add(new ImagePong());
    f.pack();
    f.setVisible(true);
  }
}
</code>
          </paragraph>
        </subsubsection></subsection><subsection titel = "SwingWorker für Steuerfäden in der Ereignisbehandlung">
Sun bietet eine Beispielimplementierung einer Hilfsklasse an, die es erlaubt,
Code in einen eigenen Steuerfaden zu verpacken. Die 
Klasse <tt>SwingWorker</tt>. <tt>SwingWorker</tt> ist nicht Bestandteil des
offiziellen Swing APIs, sondern lediglich im Tutorial angegeben. Im Anhang des
Skripts ist die Klasse <tt>SwingWorker</tt> abgedruckt.<p/>

Die Klasse <tt>SwingWorker</tt> ist dazu gedacht, Code innerhalb einer 
Ereignisbehandlungsmethode, dessen Ausführung
lange dauern kann, in einen Steuerfaden zu kapseln.  Statt den Code direkt in
der Ereignisbehandlungsmethode zu schreiben:<code>public void actionPerformed(ActionEvent e) {
    ...
    <redv>//...Code, der sehr lange dauert ...</redv>
    ...
}</code>

Ist er in die Methode <tt>construct</tt> einer <tt>SwingWorker</tt>-Instanz zu
kapseln: <code>public void actionPerformed(ActionEvent e) {
    ...
    final SwingWorker worker = <redv>new SwingWorker()</redv> {
        public <redv>Object construct()</redv> {
            <redv>//...Code, der sehr lange dauert, ist jetzt hier...</redv>
            return someValue;
        }
    };
    worker.start();
    ...
}

 </code><example>
Jetzt können wir unser Eingangsbeispiel mit der <tt>SwingWorker</tt>-Klasse so
umschreiben, daß es  nicht mehr zum Hängen des gesamten Programms  kommt.<code lang = "java"
                class = "GuiHangsNoLonger"
                package = "name/panitz/swing/threadTest">package name.panitz.swing.threadTest;

import javax.swing.JFrame;
import javax.swing.JButton;
import java.awt.event.*;

public class GuiHangsNoLonger {
  public static void main(String [] _){
    JFrame f1 = new JFrame(&quot;f1&quot;);
    JFrame f2 = new JFrame(&quot;f2&quot;);
    JButton b1 = new JButton(&quot;b1&quot;);
    JButton b2 = new JButton(&quot;b2&quot;);

    b1.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent _){
        System.out.println(&quot;b1 action&quot;);
      }
    });

    b2.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent _){
        final SwingWorker worker = <redv>new SwingWorker()</redv> {
          public <redv>Object construct() </redv>{
            System.out.println(&quot;b2 action&quot;);
            <redv>int x = 1; while (true){if (x==0) break;}</redv>
            return null;
          }
        };
        worker.start();  
      }
    });

    f1.getContentPane().add(b1);
    f2.getContentPane().add(b2);
    f1.pack();
    f2.pack();
    f1.setVisible(true);
    f2.setVisible(true);
  }
}</code>



Nach Drücken des Knopfes <tt>b2</tt> bleibt das Gui weiterhin voll
funktionsfähig. Allerdings stellt man fest, indem man sich z.B. 
mit <tt>top</tt> die laufenden Prozesse in einem Unixsystem anschaut, daß
jedes Drücken des Knopfes einen neuen Unterprozess von Java erzeugt.</example><subsubsection titel = "SwingWorkerbeispiel">
Im folgenden ist ein weiteres Beispiel angegeben, in dem die 
Klasse <tt>SwingWorker</tt> benutzt wird. Diesmal soll eine Bilddatei geladen
werden. Hierzu schreiben wir eine Klasse, die von <tt>JLabel</tt> ableitet.
Das Label soll eine vorgegebene feste Größe haben.
Dem Konstruktor wird eine Bilddatei übergeben. <code lang = "java"
                class = "ImageIcon"
                package = "name/panitz/gui"
                commandchars = "!~^">package name.panitz.gui;

import java.io.File;
import java.net.MalformedURLException;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class ImageIcon extends JLabel {
  private int height = 60;
  private int width = 80;
  final Toolkit toolkit = Toolkit.getDefaultToolkit();
  private Image image;

  public ImageIcon(String fileName){this(new File(fileName));}
  public ImageIcon(final File file){
    setImage(file);
  }</code>
Zum Setzen des Bildes, wird die Bilddatei gelesen, um es dann auf die
  vorgegebene Größe zu skalieren:<code lang = "java"
                class = "ImageIcon"
                package = "name/panitz/gui"
                sequel = "true"
                commandchars = "!~^">  public void setImage(File jpgFile){
    try{
      image=toolkit.getImage(jpgFile.toURL());
      final MediaTracker tracker = new MediaTracker(this);
      tracker.addImage(image, 0,width,height);
      try {tracker.waitForAll();}
      catch (Exception e) {e.printStackTrace();}
      fitImage();
      setIcon(new javax.swing.ImageIcon(image));
    }catch (MalformedURLException e){}
  }</code>
Zum Skalieren ist zunächst die Originalgröße zu lesen, die skalierte Größe zu
  berechnen und schließlich das Bild auf die skalierte Größe zu setzen:<code lang = "java"
                class = "ImageIcon"
                package = "name/panitz/gui"
                sequel = "true"
                commandchars = "!~^">  private void fitImage(){
    final int w = image.getWidth(this); 
    final int h = image.getHeight(this); 
    
    final int w1 = width;        final int h1 = h*width/w;
    final int w2 = w*height/h;   final int h2 = height;
    final int w3 = w1&lt;w2?w1:w2;  final int h3 = h1&lt;h2?h1:h2;

    image=image.getScaledInstance
                  (w3&lt;w?w3:w,h3&lt;h?h3:h,Image.SCALE_FAST); 
  }
}</code>
Damit haben wir eine Komponente, die Bilder beliebiger Größe aus Dateien in
einer vorgegebenen Größe anzeigen kann. Diese Komponente
können wir benutzen, um eine  kleine Anwendung zu
starten. Die Anwendung soll zwei Fenster Öffnen: im erstem
Fenster sollen alle über die Kommandozeile mitgegebenen Biler als Label
                  angezeigt werden, im zweitem Fenster soll eine Uhr laufen: <code lang = "java"
                class = "UseImageIcon"
                package = "name/panitz/gui"
                commandchars = "!_^">package name.panitz.gui;

import name.panitz.swing.threads.Uhr;

import java.io.File;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class UseImageIcon {
  public static void main(String [] args){
    JFrame f= new JFrame();
    final JPanel p = new JPanel();
    f.getContentPane().add(p);
    final int c = 10;
    final int n = args.length;
 
    p.setLayout(new GridLayout(n/c+((n%c)==0?0:1),c));
    for (final String arg:args)p.add(new ImageIcon(arg));

    f.pack();
    f.setVisible(true);

    JFrame f2 = new JFrame();
    f2.getContentPane().add(new Uhr());
    f2.pack();
    f2.setVisible(true);
  }
}</code>
Wenn wir dieses Programm mit allen unseren Urlaubsbildern starten, dann
    stellen wir fest, daß es sehr lange dauert, bis sich die beiden Fenster
    öffnen. Erst wenn alle Bilder geladen und skaliert sind, werden die beiden
    Fenster geöffnet. Auch dieses Programm läßt sich mit Hilfe der 
Klasse <tt>SwingWorker</tt> verbessern. Das Erzeugen der Objekte vom 
Typ <tt>ImageIcon</tt> wird hierzu in 
einem <tt>ActionListener</tt> durchgeführt. Es wird 
ein <tt>Timer</tt> benutzt, der genau ei Ereignis erzeugt, so daß der
    Ereignisbehandler genau einmal auf diesen Timer reagieren kann.  <code lang = "java"
                class = "BetterUseOfImageIcon"
                package = "name/panitz/gui"
                commandchars = "!_^">package name.panitz.gui;

import name.panitz.swing.threads.Uhr;
import name.panitz.swing.threadTest.SwingWorker;

import java.io.File;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class BetterUseOfImageIcon{
  public static void main(String [] args){
    final JFrame f= new JFrame();
    final JPanel p = new JPanel();
    f.getContentPane().add(p);
    final int c = 10;
    final int n = args.length;

    p.setLayout(new GridLayout(n/c+((n%c)==0?0:1),c));
    for (final String arg:args){
      ActionListener listen = new ActionListener(){ 
        public void actionPerformed(ActionEvent e) {
         final SwingWorker worker = new SwingWorker() {
           public Object construct() {
              p.add(new ImageIcon(arg)); f.pack();
              f.repaint();
              return null;
           }
         };
         worker.start(); 
        }
      };

      Timer t = new Timer(10,listen);
      t.setRepeats(false);

      t.start();
    }
    f.pack();
    f.setVisible(true);

    JFrame f2 = new JFrame();
    f2.getContentPane().add(new Uhr());
    f2.pack();
    f2.setVisible(true);
  }
}</code>

Und tatsächlich: starten wir dieses Programm jetzt mit vielen Bilddateien, so
öffnen sich gleich beide Bilder und die Uhr läuft durch. Nach und nach
erscheinen die Bilder in ihrem  Fenster, jedes solbald es erfolgreich geladen
und skaliert wurde.</subsubsection></subsection></section></kapitel>
  <kapitel titel = "3 dimensionale Graphiken"/>
  <kapitel titel = "Formale Sprachen, Grammatiken, Parser">
Sprachen sind ein fundamentales Konzept nicht nur der Informatik. In
der Informatik begegnen uns als auffälligste Form der Sprache<em>Programmiersprachen</em>. Es gibt gewisse Regeln, nach denen die Sätze
einen Sprache aus einer Menge von Wörtern geformt werden können. 
Die Regeln nennen wir im 
allgemeinen eine <em>Grammatik</em>. Ein Satz einer
Programmiersprache nennen wir Programm. Die Wörter sind,
Schlüsselwörter, Bezeichner, Konstanten und Sonderzeichen.<p/> 
Ausführlich beschäftigt sich die Vorlesung <em>Compilerbau</em><cite label = "grudeCompilerbau"/> mit
formalen Sprachen. Wir werden in diesem Kapitel die wichtigsten
Grundkenntnisse hierzu betrachten, wie sie zum Handwerkszeug eines
jeden Informatikers gehören.<section titel = "formale Sprachen">
Eine der bahnbrechenden Erfindungen des 20.<white/>Jahrhunderts
geht auf den Sprachwissenschaftler Noam 
Chomsky<cite label = "chomsky56"/><footnote>Chomsky gilt
als der am häufigsten zitierte Wissenschaftler 
des 20.<white/>Jahrhunderts. Heutzutage tritt Chomsky weniger durch
seine wissenschaftlichen Arbeiten als vielmehr durch seinen Einsatz
für Menschenrechte und bedrohte Völker in Erscheinung.</footnote> zurück. Er
präsentierte als erster ein formales Regelsystem, mit dem die
Grammatik einer Sprache beschrieben werden kann. Dieses Regelsystem
ist in seiner Idee verblüffend einfach. Es bietet Regeln an, 
mit denen mechanisch die Sätze einer Sprache generiert werden können.<p/>
Systematisch wurden Chomsky Ideen zum erstenmal für die Beschreibung
der Syntax der Programmiersprache Algol angewendet<cite label = "naur60"/>. <subsection titel = "kontextfreie Grammatik">  
Eine kontextfreie Grammatik besteht aus<itemize>
          <item>einer Menge <cal>T</cal> von Wörteren,
 den <em>Terminalsymbole</em>.</item>
          <item>einer Menge <cal>N</cal> von Nichtterminalsymbolen.</item>
          <item>ein ausgezeichnetes Startsymbol $S\in$<cal>N</cal>.</item>
          <item>einer endlichen Menge <cal>R</cal> von Regeln der Form:<br/><em>nt</em><tt>::=</tt> $t_1<dots/> t_n$, 
wobei <em>nt</em>$\in$<cal>N</cal>, $t_i\in$<cal>N</cal>$\cup$<cal>T</cal>. </item>
        </itemize>

Mit den Regeln einer kontextfreien Grammatik werden Sätze gebildet,
indem ausgehend vom Startsymbol Regel angewendet werden. Bei einer
Regelanwendung wird ein Nichtterminalzeichen $t$ durch die Rechte Seite
einer Regel, die $t$ auf der linken Seite hat, ersetzt.<example>Wir geben eine Grammatik an, die einfache Sätze über unser
Sonnensystem auf Englisch
bilden kann:<itemize>
            <item><cal>T</cal>$=\{$mars,mercury,deimos,phoebus,orbits,is,a,moon,planet$\}$</item>
            <item><cal>N</cal>$=\{$<em>start,noun-phrase,verb-phrase,noun,verb,article</em>$\}$</item>
            <item>$S=$<em>start</em></item>
            <item><em>start</em> ::= <em>noun-phrase verb-phrase</em><p/><em>noun-phrase</em> ::= <em>noun</em><br/><em>noun-phrase</em> ::= <em>article noun</em><p/><em>verb-phrase</em> ::= <em>verb noun-phrase</em><p/><em>noun</em> ::= planet<br/><em>noun</em> ::= moon<br/><em>noun</em> ::= mars<br/><em>noun</em> ::= deimos<br/><em>noun</em> ::= phoebus<p/><em>verb</em> ::= orbits<br/><em>verb</em> ::= is<p/><em>article</em> ::= a</item>
          </itemize>
Wir können mit dieser Grammatik Sätze in der folgenden Art bilden:<itemize>
            <item><em>start</em><br/><rightarrow/><em>noun-phrase verb-phrase</em><br/><rightarrow/><em>article noun verb-phrase</em><br/><rightarrow/><em>article noun verb noun-phrase</em><br/><rightarrow/> a <em>noun verb noun-phrase</em><br/><rightarrow/> a moon <em>verb noun-phrase</em><br/><rightarrow/> a moon orbits <em>noun-phrase</em><br/><rightarrow/> a moon orbits <em>noun</em><br/><rightarrow/> a moon orbits mars<br/></item>
            <item><em>start</em><br/><rightarrow/><em>noun-phrase verb-phrase</em><br/><rightarrow/><em>noun verb-phrase</em><br/><rightarrow/> mercury <em>verb-phrase</em><br/><rightarrow/> mercury <em>verb noun-phrase</em><br/><rightarrow/> mercury is <em>noun-phrase</em><br/><rightarrow/> mercury is <em>article noun</em><br/><rightarrow/> mercury is a <em>noun</em><br/><rightarrow/> mercury is a planet<br/></item>
            <item>Mit dieser einfachen Grammatik lassen sich auch Sätze bilden,
die weder korrektes Englisch sind, noch eine vernünftige inhaltliche
Aussage machen:<p/><em>start</em><br/><rightarrow/><em> noun-phrase verb-phrase</em><br/><rightarrow/><em>noun verb-phrase</em><br/><rightarrow/> planet <em>verb-phrase</em><br/><rightarrow/> planet <em>verb noun-phrase</em><br/><rightarrow/> planet orbits <em>noun-phrase</em><br/><rightarrow/> planet orbits <em>article noun</em><br/><rightarrow/> planet orbits a <em> noun</em><br/><rightarrow/> planet orbits a phoebus<br/></item>
          </itemize></example>

Eine Grammatik beschreibt die Syntax einer Sprache im Gegensatz zur
Semantik, der Bedeutung, einer Sprache. <subsubsection titel = "Rekursive Grammatiken">
Die Grammatik aus dem letzen Beispiel kann nur endlich viele Sätze
generieren. Will man mit einer Grammatik unendlich viele Sätze
beschreiben, so wie eine Programmiersprache unendlich viele Programme
hat, so kann man sich dem Trick der Rekursion bedienen. Eine Grammatik
kann rekursive Regeln enthalten; das sind Regeln, in denen auf der
rechten Seite das Nichtterminalsymbol der linken Seite wieder
auftaucht. <example>Die folgende Grammatik erlaubt es arithmetische Ausdrücke zu
generieren: <itemize>
              <item><cal>T</cal>$=\{0,1,2,3,4,5,6,7,8,9,+,-,*,/\}$</item>
              <item><cal>N</cal>$=\{$<em>start,expr,op,integer,digit,</em>$\}$</item>
              <item>$S=$<em>start</em></item>
              <item><em>start</em> ::= <em>expr</em><p/><em>expr</em> ::= <em>integer</em><br/><em>expr</em> ::= <em>integer op expr</em><p/><em>integer</em> ::= <em>digit</em><p/><em>integer</em> ::= <em>digit integer</em><p/><em>op</em> ::= +<br/><em>op</em> ::= -<br/><em>op</em> ::= *<br/><em>op</em> ::= /<p/><em>digit</em> ::= 0<br/><em>digit</em> ::= 1<br/><em>digit</em> ::= 2<br/><em>digit</em> ::= 3<br/><em>digit</em> ::= 4<br/><em>digit</em> ::= 5<br/><em>digit</em> ::= 6<br/><em>digit</em> ::= 7<br/><em>digit</em> ::= 8<br/><em>digit</em> ::= 9</item>
            </itemize>
Diese Grammatik hat zwei rekursive Regeln: eine für das 
Nichtterminal <em>expr</em> und eines für das 
Nichtterminal <em>integer</em>. <p/>

Folgende Abeleitung generiert einen arithmetischen Ausdrucke mit dieser
Grammatik:<itemize>
              <item><em>start</em><br/><rightarrow/><em>expr</em><br/><rightarrow/><em>integer op expr</em><br/><rightarrow/><em>integer op integer op expr</em><br/><rightarrow/><em>integer op integer op integer op expr</em><br/><rightarrow/><em>integer op integer op integer op integer</em><br/><rightarrow/><em>integer</em> + <em>integer op integer op integer</em><br/><rightarrow/><em>integer</em> + <em>integer</em> $*$ <em>integer op integer</em><br/><rightarrow/><em>integer</em> + <em>integer</em> $*$ <em>integer</em> $-$<em>integer</em><br/><rightarrow/><em>digit integer</em> + <em>integer</em> $*$ <em>integer</em> $-$ <em>integer</em><br/><rightarrow/> $1$ <em>integer</em> + <em>integer</em> $*$ <em>integer</em>
$-$ <em>integer</em><br/><rightarrow/> $1$ <em>digit integer</em> + <em>integer</em> $*$<em>integer</em> $-$ <em>integer</em><br/><rightarrow/> $12$ <em>integer</em> + <em>integer</em> $*$<em>integer</em> $-$ <em>integer</em><br/><rightarrow/> $12$ <em>digit</em> + <em>integer</em> $*$ <em>integer</em>
$-$ <em>integer</em><br/><rightarrow/> $129+$ <em>integer</em> $*$ <em>integer</em> $-$<em>integer</em><br/><rightarrow/> $129+$ <em>digit</em> $*$ <em>integer</em> $-$<em>integer</em><br/><rightarrow/> $129+4*$ <em>integer</em> $-$ <em>integer</em><br/><rightarrow/> $129+4*$ <em>digit integer</em> $-$ <em>integer</em><br/><rightarrow/> $129+4*5$<em>integer</em> $-$ <em>integer</em><br/><rightarrow/> $129+4*5$<em>digit</em> $-$ <em>integer</em><br/><rightarrow/> $129+4*53-$ <em>integer</em><br/><rightarrow/> $129+4*53-$ <em>digit integer</em><br/><rightarrow/> $129+4*53-8$ <em>integer</em><br/><rightarrow/> $129+4*53-8$ <em>digit</em><br/><rightarrow/> $129+4*53-87$<br/></item>
            </itemize></example><aufgabe>Erweitern Sie die obige Grammatik so, daß sie mit ihr auch
geklammerte arithmetische Ausdrücke ableiten können. Hierfür gibt es
zwei neue Terminalsymbolde: <tt>(</tt> und <tt>)</tt>. <p/>
Schreiben Sie
eine Ableitung für den Ausdruck: <tt>1+(2*20)+1</tt></aufgabe></subsubsection><subsubsection titel = "Grenzen kontextfreier Grammatiken">
Kontextfreie Grammatiken sind ein einfaches und dennoch mächtiges 
Beschreibungsmittel für Sprachen. Dennoch gibt es viele Sprachen, die
nicht durch eine kontextfreie Grammatik beschrieben werden können. <paragraph titel = "syntaktische Grenzen">
Es gibt syntaktisch recht einfache Sprachen, die sich nicht durch eine
kontextfreie Grammatik beschreiben lassen. Eine sehr einfache solche
Sprache besteht aus drei Wörtern: <cal>T</cal>$=\{$a,b,c$\}$. Die
Sätze dieser Sprache sollen so gebildet sein, daß für eine Zahl $n$
eine Folge von $n$ mal dem Zeichen a, $n$ mal das Zeichen b und
schließlich $n$ mal das Zeichen c folgt, 
also <quote>$\{a^nb^nc^n|n\in I\!\!N\}$. </quote>

Die Sätze dieser Sprache lassen sich aufzählen:<quote>
abc<br/> 
aabbcc<br/> 
aaabbbccc<br/> 
aaaabbbbcccc<br/> 
aaaaabbbbbccccc<br/> 
aaaaaabbbbbbcccccc<br/><dots/></quote>
Es gibt formale Beweise, daß derartige Sprachen sich nicht mit
kontextfreie Grammatiken bilden lassen. Versuchen Sie einmal das
Unmögliche: eine Grammatik aufzustellen, die diese Sprache erzeugt.<p/>
Eine weitere einfache Sprache, die nicht durch eine kontextfreie auszudrücken
ist, hat zwei Terminalsymbole und verlangt, daß in jedem Satz die
beiden Symbole gleich oft vorkommen, die Reihenfolge jedoch beliebig
sein kann.</paragraph><paragraph titel = "semantische Grenzen">
Über die Syntax hinaus, haben Sprachen noch weitere Einschränkungen,
die sich nicht in der Grammatik ausdrücken lassen. Die meisten
syntaktisch korrekten Javaprogramme werden trotzdem vom Javaübersetzer
als inkorrekt zurückgewiesen. Diese Programme verstoßen gegen
semantische Beschränkungen, wie z.B.<white/>gegen die
Zuweisungskompatibilität. Das Programm:<code>class SemanticalIncorrect{int i = &quot;1&quot;;}</code>
ist syntaktisch nach den Regeln der Javagrammatik korrekt gebildet,
verletzt aber die Beschränkung, daß einem Feld vom 
Typ <tt>int</tt> kein Objekt des Typs <tt>String</tt> zugewiesen
werden darf.<p/>

Aus diesen Grund besteht ein Übersetzer aus zwei großen Teilen. Der
syntaktischen Analyse, die prüft, ob der Satz mit den Regeln der
Grammatik erzeugt werden kann und der semantischen Analyse, die
anschließend zusätzliche semantische Bedingungen prüft.</paragraph></subsubsection><subsubsection titel = "Das leere Wort">
Manchmal will man in einer Grammatik ausdrücken, daß in
Nichtterminalsymbol auch zu einem leeren Folge von Symbolen reduzieren
soll. Hierzu könnte man die Regel<br/><quote>$t$::=</quote>
mit leerer rechter Seite schreiben. Es ist eine Konvention ein
spezielles Zeichen für das leere Wort zu benutzen. Hierzu bedient man
sich des griechischen Buchtstabens $\epsilon$. Obige Regel würde man
also schreiben als:<quote>$t$::=$\epsilon$</quote></subsubsection><subsubsection titel = "Lexikalische Struktur">
Bisher haben wir uns keine Gedanken gemacht, woher die  Wörter unserer
Sprache kommen. Wir haben bisher immer eine gegebene Menge
angenommen. Die Wörter einer Sprache bestimmen ihre lexikalische
Struktur. In unseren obigen Beispielen haben wir sehr unterschiedliche
Arten von Wörtern: einmal Wörter der englischen Sprache und einmal
Ziffernsymbole und arithmetische Operatorsymbole. Im Kontext von
Programmiersprachen spricht man von Token. <p/>

Bevor wir testen können, ob ein Satz mit einer Grammatik erzeugt
werden kann, sind die einzelnen Wörter in diesem Satz zu
identifizieren. Dieses geschieht in einer lexikalischen Analyse. Man
spricht auch vom <em>Lexer</em> und <em>Tokenizer</em>. Um zu
beschreiben, wie die einzelnen lexikalischen Einheiten einer Sprache
aussehen, bedient man sich eines weiteren Formalismus, den regulären
Ausdrücken. </subsubsection><subsubsection titel = "Andere Grammatiken">
Die in diesem Kapitel vorgestellten Grammatiken 
heißen <em>kontextfrei</em>, weil eine Regel für ein
Nichtterminalzeichen angewendet wird, ohne dabei zu betrachten, was
vor oder nach dem Zeichen für ein weiteres Zeichen steht, der Kontext
also nicht betrachtet wird. Läßt man auch Regeln zu, die auf der
linken Seite nicht ein Nichtterminalzeichen stehen haben, so kann man
mächtigere Sprachen beschreiben, als mit einer kontextfreien
Grammatik.<example>Wir können mit der folgenden nicht-kontextfreien Grammatik
die Sprache beschreiben, in der jeder Satz gleich oft die beiden
Terminalsymbole, eber in beliebiger Reihenfolge enthält.<itemize>
              <item><cal>T</cal>$=\{$a,b$\}$</item>
              <item><cal>N</cal>$=\{$<em>start,A,B</em>$\}$</item>
              <item>$S=$<em>start</em></item>
              <item><em>start</em> ::= <em>ABstart</em><br/><em/>start ::= $\epsilon$<p/><em>AB</em> ::= <em>BA</em><p/><em>BA</em> ::= <em>AB</em><p/><em>A</em> ::= a<p/><em>B</em> ::= b</item>
            </itemize><quote><em>start</em><br/><rightarrow/><em>ABstart</em><br/><rightarrow/><em>ABABstart</em><br/><rightarrow/><em>ABABABstart</em><br/><rightarrow/><em>ABABABABstart</em><br/><rightarrow/><em>ABABABABABstart</em><br/><rightarrow/><em>ABABABABAB</em><br/><rightarrow/><em>AABBABABAB</em><br/><rightarrow/><em>AABBBAABAB</em><br/><rightarrow/><em>AABBBABAAB</em><br/><rightarrow/><em>AABBBABABA</em><br/><rightarrow/><em>AABBBABBAA</em><br/><rightarrow/><em>AABBBBABAA</em><br/><rightarrow/><em>AABBBBBAAA</em><br/><rightarrow/> a<em>ABBBBBAAA</em><br/><rightarrow/> aa<em>BBBBBAAA</em><br/><rightarrow/> aab<em>BBBBAAA</em><br/><rightarrow/> aabb<em>BBBAAA</em><br/><rightarrow/> aabbb<em>BBAAA</em><br/><rightarrow/> aabbbb<em>BAAA</em><br/><rightarrow/> aabbbbb<em>AAA</em><br/><rightarrow/> aabbbbba<em>AA</em><br/><rightarrow/> aabbbbbaa<em>A</em><br/><rightarrow/> aabbbbbaaa</quote></example><example>
Auch die nicht durch eine kontextfreie Grammatik darstellbare Sprache:<quote>$\{a^nb^nc^n|n\in I\!\!N\}$. </quote>
läßt sich mit einer solchen Grammatik generieren:<quote><em>S</em>::=ab<em>T</em>c<br/><em>T</em>::=Ab<em>T</em>c<bar/>$\epsilon$<br/>
b<em>A</em>::=<em>A</em>b<br/>
a<em>A</em>::=aa<br/></quote>
Eine Ableitung mit dieser Grammatik sieht wie folgt aus:<quote><em>S</em><br/><rightarrow/> ab<em>T</em>c<br/><rightarrow/> ab<em>A</em>b<em>T</em>cc<br/><rightarrow/> ab<em>A</em>b<em>A</em>b<em>T</em>ccc<br/><rightarrow/> ab<em>A</em>b<em>A</em>b<em>A</em>b<em>T</em>cccc<br/><rightarrow/> ab<em>A</em>b<em>A</em>b<em>A</em>b<em>A</em>b<em>T</em>ccccc<br/><rightarrow/> ab<em>A</em>b<em>A</em>b<em>A</em>b<em>A</em>bccccc<br/><rightarrow/> ab<em>AA</em>bb<em>A</em>b<em>A</em>bccccc<br/><rightarrow/> ab<em>AA</em>b<em>A</em>bb<em>A</em>bccccc<br/><rightarrow/> ab<em>AAA</em>bbb<em>A</em>bccccc<br/><rightarrow/> ab<em>AAA</em>bb<em>A</em>bbccccc<br/><rightarrow/> ab<em>AAA</em>b<em>A</em>bbbccccc<br/><rightarrow/> ab<em>AAAA</em>bbbbccccc<br/><rightarrow/> a<em>A</em>b<em>AAA</em>bbbbccccc<br/><rightarrow/> a<em>AA</em>b<em>AA</em>bbbbccccc<br/><rightarrow/> a<em>AAA</em>b<em>A</em>bbbbccccc<br/><rightarrow/> a<em>AAAA</em>bbbbbccccc<br/><rightarrow/> aa<em>AAA</em>bbbbbccccc<br/><rightarrow/> aaa<em>AA</em>bbbbbccccc<br/><rightarrow/> aaaa<em>A</em>bbbbbccccc<br/><rightarrow/> aaaaabbbbbccccc</quote></example>




Als Preis dafür, daß man sich nicht auf kontextfreie Grammatiken
beschränkt, kann nicht immer leicht und eindeutig erkannt werden, ob
ein bestimmter vorgegebener Satz mit dieser Grammatik erzeugt werden
kann. </subsubsection><subsubsection titel = "Grammatiken und Bäume">
Im letzten Kapitel haben wir uns ausführlich mit Bäumen
beschäftigt. Eine Grammatik stellt in naheliegender Weise nicht nur
ein Beschreibung einer Sprache dar, sondern jede Generierung eines
Satzes dieser Sprache entspricht einem Baum, dem Ableitungsbaum. 
Die Knoten des Baumes
sind mit Terminal- und Nichtterminalzeichen markiert, wobei Blätter
mit Terminalzeichen markiert sind. Die Kinder eines Knotens sind die
Knoten, die mit der rechten Seite einer Regelanwendung markiert sind.<p/>
Liest man die Blätter eines solchen Baumes von links nach rechts, so
ergibt sich der generierte Satz.<example>Die Ableitungen der Sätze unserer ersten Grammatik haben
folgende Baumdarstellung:<br/><bild name = "mars1"
                  pdfscale = "0.9"
                  psscale = "0.8"
                  caption = "Ableitungsbaum für a moon orbits mars."/><p/><bild name = "mars2"
                  pdfscale = "0.9"
                  psscale = "0.8"
                  caption = "Ableitungsbaum für mercury is a planet."/><p/><bild name = "mars3"
                  pdfscale = "0.9"
                  psscale = "0.8"
                  caption = "Ableitungsbaum für planet orbits a phoebus."/></example>

Gegenüber unserer bisherigen Darstellung der Ableitung eines Wortes
mit den Regeln einer Grammatik, ist die Reihenfolge, in der die Regeln
angewendet werden in der Baumdarstellung nicht mehr ersichtlich. Daher
spricht man häufiger auch vom Syntaxbaum des Satzes.<aufgabe>Betrachten Sie die einfache Grammatik für arithmetische
Ausdrücke aus dem letzen Abschnitt. Zeichnen Sie einen Syntaxbaum für den 
Audruck <tt>1+1+2*20</tt>.</aufgabe></subsubsection></subsection><subsection titel = "Erweiterte Backus-Naur-Form">
Die Ausdrucksmöglichkeit einer kontextfreien Grammatik ist auf wenige
Konstrukte beschränkt. Das macht das Konzept einfach. Im Kontext von
Programmiersprachen gibt es häufig sprachliche Konstrukte, wie die
mehrfache Wiederholung oder eine Liste von bestimmten Teilen, die zwar
mit einer kontextfreien Grammatik darstellbar ist, für die aber
spezielles zusätzliche Ausdrucksmittel in der Grammatik eingeführt
werden.  In den nächsten Abschnitten werden wir diese Erweiterungen
kennenlernen, allerdings werden wir in unseren Algorithmen für Sprachen
und Grammatiken diese Erweiterungen nicht berücksichtigen. <subsubsection titel = "Alternativen">
Wenn es für ein Nichtterminalzeichen mehrere Regeln gibt, so werden
diese Regeln zu einer Regel umgestaltet. Die unterschiedlichen rechten
Seiten werden dann durch einen vertikalen 
Strich <bar/> gestrennt.<p/>
Durch diese Darstellung verliert man leider den direkten Zusammenhang
zwischen den Regeln und einen Ableitungsbaum. <example>
Die Regeln unserer ersten Grammatik können damit wie folgt geschrieben
werden:<quote><em>start</em> ::= <em>noun-phrase verb-phrase</em><p/><em>noun-phrase</em> ::= <em>noun</em><bar/><em>article noun</em><p/><em>verb-phrase</em> ::= <em>verb noun-phrase</em><p/><em>noun</em> ::= planet<bar/>moon<bar/>mars<bar/>deimos<bar/>phoebus<p/><em>verb</em> ::= orbits<bar/>is<p/><em>article</em> ::= a</quote></example></subsubsection><subsubsection titel = "Gruppierung">
Bestimmte Teile der rechten Seite einer Grammatik können durch
Klammern gruppiert werden. In diesen Klammern können wieder durch
einen vertikalen Strich getrennte 
Alternativen stehen.<example>
Die einfache Grammatik für arithmetische Ausdrücke läßt sich damit
ohne das Nichtterminalzeichen <em>op</em> schreiben:<quote><em>start</em> ::= <em>expr</em><p/><em>expr</em> ::= <em>integer</em><bar/><em>integer</em>
$(+$<bar/>$-$<bar/>$*$<bar/>$/)$ <em> expr</em><p/><em>integer</em> ::= <em>digit</em><bar/><em>digit integer</em><p/><em>digit</em> ::=
0<bar/>1<bar/>2<bar/>3<bar/>4<bar/>5<bar/>6<bar/>7<bar/>8<bar/>9</quote></example></subsubsection><subsubsection titel = "Wiederholungen">
Ein typische Konstrukt in Programmiersprachen ist, daß bestimmte
Kontrukte wiederholt werdn können. So stehen 
z.B.<white/> in Java im Rumpf einer
Methode mehrere Anweisungen. Solche Sprachkonstrukte lassen sich mit einer
kontextfreien Grammatik ausdrücken.<example>Eine Zahl besteht aus einer Folge von $n$ Ziffern
($n&gt;0$). Dieses läßt sich durch folgende Regel ausdrücken:<quote><em>Zahl</em> ::= <em>Ziffer Zahl</em><white/><bar/><white/><em>Ziffer</em></quote></example><paragraph titel = "1 bis n-fach">
Im obigen Beispiel handelt es sich um eine 1 bis $n$-fache
Wiederholung des Zeichens <em>Ziffer</em>. Hierzu gibt es eine
abkürzende Schreibweise. Dem zu wiederholenden Teil wird das 
Zeichen <tt>+</tt> nachgestellt.<example>
Obige Regel für das Nichtterminal <em>Zahl</em> läßt sich mit dieser
abkürzenden Schreibweise schreiben als:<quote><em>Zahl</em> ::= <em>Ziffer</em><tt>+</tt></quote></example></paragraph><paragraph titel = "0 bis n-fach">
Soll ein Teil in einer Wiederholung auch keinmal vorkommen, so wird
statt des Zeichens <tt>+</tt> das Zeichen <tt>*</tt> genommen.<example>
Folgende Regel drückt aus, daß ein Ausdruck eine durch Operatoren
getrennte Liste von Zahlen ist.<quote><em>expr</em> ::= <em>Zahl</em><white/><bar/><white/> (<em>Op</em><white/><em>Zahl</em>)* </quote></example></paragraph><paragraph titel = "Option">
Ein weiterer Spezialfall der Wiederholung ist die, in der der
entsprechende Teil keinmal oder einmal vorkommen darf, d.h.~der Teil
ist optional. Optionale Teile werden in der erweiterten Form in eckige
Klammern gesetzt.</paragraph></subsubsection></subsection></section><section titel = "Parser">
Grammatiken geben an, wie Sätze einer Sprache gebildet werden
können. In der Informatik interessiert der umgekehrte Fall. Ein Satz
ist vorgegeben und es soll geprüft werden, ob dieser Satz mit einer
bestimmten Grammatik erzeugt werden kann. Ein Javaübersetzer 
prüft z.B.<white/>ob ein vorgegebenes Programm syntaktisch zur durch
die Javagrammatik beschriebenen Sprache gehört.
Hierzu ist ein Prüfalgorithmus anzugeben, der testet, ob die Grammatik
einen bestimmten Satz generieren kann. Ein solches Programm 
wird <em>Parser</em> genannt. Ein Parser<footnote>Lateinisch Pars
bedeutet Teil.</footnote> zerteilt einen Satz in seine syntaktischen
Bestandteile.  <subsection titel = "Parsstrategien">
Man kann unterschiedliche Algorithmen benutzen, um zu testen, daß ein
zu der Sprache einer Grammatik gehört. Eine Strategie geht primär von
der Grammatik aus, die andere betrachten eher den zu prüfenden Satz.<subsubsection titel = "Rekursiv absteigend">
Eine einfache Idee zum Schreiben eines Parsers ist es, einfach
nacheinander auszuprobieren, ob die Regelanwendung nach und nach einen
Satz bilden kann. Hierzu startet man mit dem Startsymbol und wendet
nacheinander die Regeln an. Dabei wendet man immer eine Regel auf das
linkeste Nichtterminalzeichen an, so lange, bis der Satzanfang
abgelitten wurde, oder aber ein falscher Satzanfang abgelitten
wurde. Im letzteren Fall hat man offensichtlich bei einer Regel die
falsche Alternative gewählt. Man ist in eine Sackgasse geraten. 
Nun geht man in seiner Ableitung zurück bis
zu der letzten Regelanwendung, an der eine andere Alternative hätte
gewählt werden können. Man spricht dann von <em>backtracking</em>; auf
deutsch kann man treffend von Zurückverfolgen sprechen.<p/>

Auf diese Weise gelangt man entweder zu einer Ableitung des Satzes,
oder stellt irgendwann fest, daß man alle Alternativen ausprobiert hat
und immer in eine Sackgasse geraten ist. Dann ist der Satz nicht in
der Sprache.<p/>
Diese Strategie ist eine Suche. Es wird systematisch aus allen
möglichen Ableitungen in der Grammatik nach der Ableitung gesucht, die
den gewünschten Satz findet.<example>
Wir suchen mit dieser Strategie die Ableitung des 
Satzes <em>a moon orbits mars</em> in dem
Sonnensystembeispiel. Sackgassen sind durch einen Punkt $\bullet$
markiert. <table layout = "lllr">
              <zeile>
                <zelle>(0)</zelle>
                <zelle/>
                <zelle>
                  <em>start</em>
                </zelle>
              </zeile>
              <zeile>
                <zelle>(1) aus 0</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>
                  <em>noun-phrase verb-phrase</em>
                </zelle>
              </zeile>
              <zeile>
                <zelle>(2a) aus 1</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>
                  <em>noun verb-phrase</em>
                </zelle>
              </zeile>
              <br/>
              <zeile>
                <zelle>(2a3a) aus 2a</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>planet <em> verb-phrase</em></zelle>
                <zelle>$\bullet$</zelle>
              </zeile>
              <zeile>
                <zelle>(2a3b) aus 2a</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>moon <em> verb-phrase</em></zelle>
                <zelle>$\bullet$</zelle>
              </zeile>
              <zeile>
                <zelle>(2a3c) aus 2a</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>mars <em> verb-phrase</em></zelle>
                <zelle>$\bullet$</zelle>
              </zeile>
              <zeile>
                <zelle>(2a3d) aus 2a</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>deimos <em> verb-phrase</em></zelle>
                <zelle>$\bullet$</zelle>
              </zeile>
              <zeile>
                <zelle>(2a3e) aus 2a</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>phobus <em> verb-phrase</em></zelle>
                <zelle>$\bullet$</zelle>
              </zeile>
              <br/>
              <zeile>
                <zelle>(2b)  aus 1</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>
                  <em>article noun verb-phrase</em>
                </zelle>
              </zeile>
              <zeile>
                <zelle>(3) aus 2b</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>a <em> noun verb-phrase</em></zelle>
              </zeile>
              <br/>
              <zeile>
                <zelle>(4a) aus 3</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>a planet <em> verb-phrase</em></zelle>
                <zelle>$\bullet$</zelle>
              </zeile>
              <zeile>
                <zelle>(4b) aus 3</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>a moon <em> verb-phrase</em></zelle>
              </zeile>
              <br/>
              <zeile>
                <zelle>(5) aus 4b</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>a moon <em> verb noun-phrase</em></zelle>
              </zeile>
              <br/>
              <zeile>
                <zelle>(6) aus 5</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>a moon orbits <em> noun-phrase</em></zelle>
              </zeile>
              <br/>
              <zeile>
                <zelle>(7) aus 6</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>a moon orbits <em> noun</em></zelle>
              </zeile>
              <br/>
              <zeile>
                <zelle>(8a) aus 7</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>a moon orbits planet</zelle>
                <zelle>$\bullet$</zelle>
              </zeile>
              <zeile>
                <zelle>(8b) aus 7</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>a moon orbits moon</zelle>
                <zelle>$\bullet$ </zelle>
              </zeile>
              <zeile>
                <zelle>(8c) aus 7</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle>a moon orbits mars</zelle>
              </zeile>
            </table></example>

Alternativ könnte man diese Strategie auch symetrisch nicht von links
sondern von der rechten Seite an ausführen, also immer eine Regel für
das rechtestes Nichtterminalsymbol anwenden.<paragraph titel = "Linksrekursion">
Die Strategie des rekursiven Abstiegs auf der linken Seite
funktioniert für eine bestimmte Art von Regeln nicht. Dieses sind
Regeln, die in einer Alternative als erstes Symbol wieder das
Nichtterminalsymbol stehen haben, das auch auf der linken Seite
steht. Solche Regeln heißen linksrekursiv. Unsere Strategie terminiert
in diesen Fall nicht.<example>
Gegeben sei eine Grammatik mit einer linksrekursiven Regel:<quote><em>expr</em>::=<em>expr</em>+<em>zahl</em><bar/><em>zahl</em></quote>
Der Versuch den Satz<quote>zahl+zahl</quote>
mit einem links rekursiv absteigenden Parser abzuleiten, führt zu
einem nicht terminierenden rekursiven Abstieg. Wir gelangen nie in
eine Sackgasse:<p/><table layout = "ll">
                <zeile>
                  <zelle/>
                  <zelle>
                    <em>expr</em>
                  </zelle>
                </zeile>
                <zeile>
                  <zelle>
                    <rightarrow/>
                  </zelle>
                  <zelle><em>expr</em>+<em>zahl</em></zelle>
                </zeile>
                <zeile>
                  <zelle>
                    <rightarrow/>
                  </zelle>
                  <zelle><em>expr</em>+<em>zahl</em>+<em>zahl</em></zelle>
                </zeile>
                <zeile>
                  <zelle>
                    <rightarrow/>
                  </zelle>
                  <zelle><em>expr</em>+<em>zahl</em>+<em>zahl</em>+<em>zahl</em></zelle>
                </zeile>
                <zeile>
                  <zelle>
                    <rightarrow/>
                  </zelle>
                  <zelle><em>expr</em>+<em>zahl</em>+<em>zahl</em>+<em>zahl</em>+<em>zahl</em></zelle>
                </zeile>
                <zeile>
                  <zelle/>
                  <zelle>
                    <dots/>
                  </zelle>
                </zeile>
              </table></example>

Es läßt sich also nicht für alle Grammatiken mit dem Verfahren des
rekursiven Abstiegs entscheiden, ob ein Satz mit der Grammatik erzeugt
werden kann; aber es ist möglich, eine Grammatik mit linksrekursiven
Regeln so umzuschreiben, daß sie die gleiche Sprache generiert, jedoch
nicht mehr linksrekursiv ist. Hierzu gibt es ein einfaches Schema:<quote>
Eine Regel nach dem Schema:<quote><em>A</em> ::= <em>A</em><white/><em>rest</em><bar/><em>alt2</em></quote>
ist zu ersetzen durch die zwei Regeln:<quote><em>A</em>::= <em>alt2</em><white/><em>R</em><br/><em>R</em>::= <em>rest</em><white/><em>R</em><bar/>$\epsilon$</quote>
wobei <em>R</em> ein neues Nichtterminalsymbol ist.</quote></paragraph><paragraph titel = "Linkseindeutigkeit">
Die rekursiv absteigende Strategie hat einen weiteren Nachteil. Wenn
sie streng schematisch angewendet wird, führt sie dazu, daß bestimmte
Prüfungen mehrfach durchgeführt werden. Diese mehrfache Ausführung
kann sich bei wiederholter Regelanwendung multipizieren und zu einem
sehr ineffizienten Parser führen. Grund dafür sind Regeln, die zwei
Alternativen mit gleichem Anfang haben:<quote><em>S</em> ::= <em>AB</em><bar/><em>A</em></quote>
Beide Alternativen für das Nichtterminalzeichen <em>S</em> starten mit
dem Zeichen <em>A</em>. Für unseren Parser bedeutet das soweit:
versuche nach der ersten Alternative zu parsen. Hierzu parse erst nach
dem Symbol <em>A</em>. Das kann eine sehr komplexe Berechnung
sein. Wenn sie gelingt, dann versuche anschließend weiter nach dem
Symbol <em>B</em> zu parsen. Wenn das fehlschlägt, dann verwerfe die
Regelalternative und versuche nach der zweiten Regelalternative zu
parsen. Jetzt ist wieder nach dem Symbol <em>A</em> zu parsen, was wir
bereits gemacht haben.<p/>
Regeln der obigen Art wirken sich auf unsere Parsstrategie ungünstig
aus. Wir können aber ein Schema angegeben, wie man solche Regeln aus
der Grammatik eleminiert, ohne die erzeugte Sprache zu ändern:<quote>
Regeln der Form
  <quote><em>S</em> ::= <em>AB</em><bar/><em>A</em></quote>
sind zu ersetzen durch
  <quote><em>S</em> ::= <em>AT</em><br/><em>T</em> ::= <em>B</em><bar/>$\epsilon$
  </quote>
wobei <em>T</em> ein neues Nichtterminalzeichen ist.</quote></paragraph><paragraph titel = "Vorausschau">
Im letzten Abschnitt haben wir gesehen, wie wir die Grammatik
umschreiben können, so daß nach dem Zurücksetzen in unserem
Algorithmus es nicht vorkommt, bereits ausgeführte Regeln ein weiteres
Mal zu durchlaufen. Schöner noch wäre es, wenn wir auf das
Zurücksetzen ganz verzichten könnten. Dieses läßt sich allgemein nicht
erreichen, aber es gibt Grammatiken, in denen man durch Betrachtung
des nächsten zu parsenden Zeichens erkennen kann, welche der
Regelalternativen als einzige Alternative in betracht kommt. Hierzu
kann man für eine  Grammatik für jedes Nichtterminalzeichen in jeder
Regelalternative berechnen, welche Terminalzeichen als linkestes
Zeichen in einem mit dieser Regel abgelittenen Satz auftreten
kann. Wenn die Regelalternativen disjunkte solche Menge des ersten
Zeichens haben, so ist eindeutig bei Betrachtung des ersten Zeichens
eines zu parsenden Satzes erkennbar, ob und mit welcher Alternative
dieser Satz nur parsbar sein kann.<p/>
Die gängigsten Parser benutzen diese Entscheidung, nach dem erstem
Zeichen. Diese Parser sind darauf angewiesen, daß die Menge der ersten
Zeichen der verschiedenen Regelalternativen disjunkt sind.<p/>
Der Vorteil an diesem Verfahren ist, daß die Token nach und nach von
links nach rechts stückweise konsumiert werden. Sie können durch einen
Datenstro, relisiert werden. Wurden sie einmal konsumiert, so werden
sie nicht mehr zum Parsen benötigt, weil es kein Zurücksetzen gibt.   </paragraph></subsubsection><subsubsection titel = "Schieben und Reduzieren">
Der rekursiv absteigende Parser geht vom Startsymbol aus und versucht
durch Regelanwendung den in Frage stehenden Satz abzuleiten.  
Eine andere Strategie ist die des Schiebens-und-Reduzierens
(shift-reduce).  Diese
geht vom im Frage stehenden Satz aus und versucht die Regeln rückwärts
anzuwenden, bis das Startsymbol erreicht wurde. Hierzu wird der Satz
von links nach rechts (oder symmetrisch von rechts nach links)
betrachtet und versucht, rechte Seiten von Regeln zu finden und durch
ihre linke Seite zu ersetzen. Dazu benötigt man einen Marker, der angibt, bis
zu welchen Teil man den Satz betrachtet. Wenn links des Markers keine
linke Seite einer Regel steht, so wird der Marker ein Zeichen weiter
nach rechts verschoben.<example>
Wir leiten im folgenden unserer allseits bekannten Beispielsatz aus
dem Sonnensystem durch Schieben und Reduzieren ab. Als Marker benutzen
wir einen Punkt.<p/><table layout = "lll">
              <zeile>
                <zelle/>
                <zelle/>
                <zelle>. a moon orbits mars</zelle>
              </zeile>
              <zeile>
                <zelle>(shift)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle> a . moon orbits mars</zelle>
              </zeile>
              <zeile>
                <zelle>(reduce)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>article</em> . moon orbits mars</zelle>
              </zeile>
              <zeile>
                <zelle>(shift)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>article</em> moon . orbits mars</zelle>
              </zeile>
              <zeile>
                <zelle>(reduce)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>article noun</em>  . orbits mars</zelle>
              </zeile>
              <zeile>
                <zelle>(reduce)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>noun-phrase</em> . orbits mars</zelle>
              </zeile>
              <zeile>
                <zelle>(shift)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>noun-phrase</em>  orbits . mars</zelle>
              </zeile>
              <zeile>
                <zelle>(reduce)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>noun-phrase verb</em> . mars</zelle>
              </zeile>
              <zeile>
                <zelle>(shift)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>noun-phrase verb</em> mars .</zelle>
              </zeile>
              <zeile>
                <zelle>(reduce)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>noun-phrase verb noun</em> .</zelle>
              </zeile>
              <zeile>
                <zelle>(reduce)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>noun-phrase verb noun-phrase</em> .</zelle>
              </zeile>
              <zeile>
                <zelle>(reduce)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>noun-phrase verb-phrase</em> .</zelle>
              </zeile>
              <zeile>
                <zelle>(reduce)</zelle>
                <zelle>
                  <rightarrow/>
                </zelle>
                <zelle><em>start</em>.</zelle>
              </zeile>
            </table></example>
Wir werden im Laufe dieser Vorlesung diese Parserstrategie nicht
weiter verfolgen.</subsubsection></subsection></section><section titel = "Handgeschriebene Parser">
Genug der Theorie. Wir kennen jetzt Grammatiken und zwei Strategien,
um für einen Satz zu entscheiden, ob er mit einer Grammatik generiert
werden kann. In diesem Abschnitt wollen wir unsere theoretischen
Erkenntnisse in ein Programm praktisch umsetzen. Wir werden hierzu
einen rekursiv absteigenden Parser entwickeln.<subsection titel = "Basisklassen der Parserbibliothek">
Wir werden eine Bibliothek entwerfen, mit der Parser einer beliebigen Grammatik
konstruiert werden können. Parser we lang=&quot;java&quot;rden dabei Objekte sein, insbesondere mit
einer Methode zum Parsen. Entwerfen wir also zunächst eine Schnittstelle, die
einen Parser beschreibt. Die Schnittstelle für Parser soll genau eine Methode
haben, die Methode <tt>parse</tt>. Sie bekommt ein Argument,  die Liste der
Token, die zu parsen sind. Ein Parser erzeugt ein Ergebnis. Das Ergebnis kann
von beliebigen Typen sein: so gibt es Parser, die einen Baum als Ergebnis
produzieren, oder Parser, die nur als einen bool&#39;schen Wert angeben, ob der
Parsevorgang erfolgreich war. Um diesem Rechnung zu tragen, lassen wir in der
Schnittstelle <tt>Parser</tt> den Ergebnistyp zunächst variabel. Wir erhalten
folgende generische Schnittstelle:<code class = "Parser"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;
import java.util.List;
public interface Parser&lt;a&gt; {
  ParseResult&lt;a&gt; parse(List&lt;Token&gt; ts);
}</code>

Für einen beliebigen aber festen Typen <tt>a</tt> können wir Parser
implementieren: so ist der Typ <tt>Parser&lt;String&gt;</tt> ein Parser, der
ein Stringobjekt als Ergebnis liefert.<p/>

Wir haben in der obigen Definition der Parserschnittstelle einen 
Typ <tt>Token</tt> vorgesehen. Auch für diesen sehen wir eine Schnittstelle
vor: <code class = "Token"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;
public interface Token {}</code>


Die Schnittstelle ist leer. Sie hat keine Eigenschaften.
 Der Einfachheit
haben wir als einen Strom von Token eine Liste von Token verwenden.<p/>

Schließlich haben wir einen Typ <tt>ParseResult&lt;a&gt;</tt> in der
Parserschnittstelle vorgesehen. Das Ergebnis des Parsevorgangs eines Parser
des Typs <tt>Parser&lt;a&gt;</tt> ist vom Typ <tt>a</tt>. Es reicht aber nicht
aus, allein das Parseergebnis zurückzugeben. Wir müssen zusätzlich angeben,
welche Token durch den Parsvorgang konsumiert wurden. Daher haben wir einen
Typ <tt>ParseResult&lt;a&gt;</tt> vorgesehen, der aus zwei Teilen besteht:<itemize>
          <item>dem eigentlichen Ergebnis vom Typ <tt>a</tt>.</item>
          <item>der Liste der durch den Parsvorgang nicht konsumierten restlichen Token.</item>
        </itemize>

So läßt sich folgende Klasse für Parsergebnisse definieren:<code class = "ParseResult"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;
import java.util.List;
public class ParseResult&lt;a&gt; {
  final private a result;
  final private List&lt;Token&gt; remainingToken;
  public ParseResult(a r,List&lt;Token&gt; toks){
    result=r;remainingToken=toks;
  }
  public a getResult(){return result;}
  public List&lt;Token&gt; getRemainingToken(){return remainingToken;}
  public boolean failed(){return result==null;}
}</code>


Wir haben für die zwei Teile eines Parsergebnisse jeweils 
eine <tt>get</tt>-Methode definiert. Die Methode <tt>failed</tt> gibt
an ob es sich um einen erfolgreichen Parsvorgang gehandelt hat oder nicht. <subsubsection titel = "Der Epsilon Parser">
Wir können schon einen allerersten Parser schreiben, den Epsilonparser, der
kein Token der Eingabe konsumiert. Er endet immer erfolgreich. 
Wir lassen ihm daher immer den Wert <tt>true</tt> als Ergebnis
zurückgeben. Kein Token der Eingabeliste wird konsumiert.<code class = "Epsilon"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;

public class Epsilon implements Parser&lt;Boolean&gt;{
  public ParseResult&lt;Boolean&gt; parse(List&lt;Token&gt; ts){
     return new ParseResult&lt;Boolean&gt;(true,ts);
  }
}</code></subsubsection></subsection><subsection titel = "Parser zum Erkennen von Token">
Der allgemeine Rahmen für Parser ist nun abgesteckt. Jetzt können wir
schrittweise für komplexe Grammatiken Parser bauen. Der elementarste Parser
ist der, der prüft, ob ein bestimmtes Token als nächstes in der Eingabeliste
folgt. Hierzu ist eine Klasse, die <tt>Parser</tt> implementiert,
zu definieren, in der die Methode <tt>parse</tt> entsprechend implementiert
ist. In der Methode <tt>parse</tt> ist zunächst zu prüfen, ob die Tokenliste
nicht leer ist. Dann ist zu prüfen, ob das nächste Token ein bestimmtes Token,
nach dem der Parser sucht, gleicht. Im Erfolgsfall wird ein erfolgreiches
Ergebnis mit dem gefundenen Token erzeugt.<code class = "ParseToken"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;
import java.util.List;

public class ParseToken&lt;a extends Token&gt; implements Parser&lt;a&gt;{
  final private a t;
  public ParseToken(a _t){t=_t;}
  public ParseResult&lt;a&gt; parse(List&lt;Token&gt; ts){
    if (ts.isEmpty()) return new ParseResult&lt;a&gt;(null,ts);
    if (ts.get(0).equals(t))
      return new ParseResult&lt;a&gt;((a)ts.get(0),ts.subList(1,ts.size()));
    return new ParseResult&lt;a&gt;(null,ts);
  }
}</code></subsection><subsection titel = "Parser zum Bilden der Sequenz zweier Parser">
In einfachen Chomsky-Grammatiken gibt es nur zwei Arten wie für ein
Nichtterminalsymbol Regeln gebildet werden:<itemize>
          <item>durch die Sequenz mehrer Symbole auf der rechten Seite einer 
Regel. </item>
          <item>durch mehrere Regelalternativen.</item>
        </itemize>

Für diese beiden Bildungsprinzipien schreiben wir Parserobjekte, die aus
jeweils zwei Parser einen neuen Parser bilden. <p/>

In diesen Abschnitt machen wir das zunächst für die Sequenz zweier Parser.
Haben wir in der Grammatik eine Regel der Form:<quote><em>A</em> ::= <em>B</em> ~<em>C</em></quote>

So können wir sie beim Schreiben eines Parser lesen als: Um den Parser für das
Nichtterminalsymbol <tt>A</tt> zu schreiben, schreibe die Parser für die
Symbole <em>B</em> und <em>C</em> und konstruiere mit diesen beiden den Parser
für das Symbol <em>A</em> durch den Sequenzparser aus den beiden Teilparsern.<p/>
Das Ergebnis einer Sequenz von zwei Parsern muß die beiden Parsergebnisse
irgendwie sinnvoll kombinieren. Hierzu sehen wir eine Klasse vor, die Paare
von zwei Objekten repräsentieren kann:<code class = "Pair"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;

public class Pair&lt;a,b&gt;{
  final private a e1;
  final private b e2;
  public Pair(a x1,b x2){e1=x1;e2=x2;}
  public a getE1(){return e1;}
  public b getE2(){return e2;}
}</code>

Die Sequenz zweier Parser kann jetzt als Parsergebnis ein Paar aus den beiden
Teilergebnissen haben. Wir implementieren den Parser, der die Sequenz zweier
Parser darstellt. Die zwei Teilparser werden dem Konstruktor übergeben:<code class = "Seq"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;

import java.util.List;

public class Seq&lt;a,b&gt; implements Parser&lt;Pair&lt;a,b&gt;&gt;{
  final private Parser&lt;a&gt; p1;
  final private Parser&lt;b&gt; p2;
  public Seq(Parser&lt; a&gt; _p1,Parser&lt; b&gt; _p2){p1=_p1;p2=_p2;}</code>

Die Methode <tt>parse</tt> wendet zunächst den ersten Parser auf die
Tokenliste an:<code class = "Seq"
              package = "name/panitz/parser"
              lang = "java"
              commandchars = "_~^"
              sequel = "true">  public ParseResult&lt;Pair&lt;a,b&gt;&gt; parse(List&lt;Token&gt; ts){
    ParseResult&lt;a&gt; r1 = p1.parse(ts);</code>

Sollte dieses schon mißglücken, so ist das Gesamtergebnis auch ein mißglückter
Parsversuch: <code class = "Seq"
              package = "name/panitz/parser"
              lang = "java"
              commandchars = "_~^"
              sequel = "true">    if (r1.failed()) return new ParseResult&lt;Pair&lt;a,b&gt;&gt;(null,ts);</code>

Im erfolgreichen Fall sind die übrigen noch nicht konsumierten Token des
ersten Parses zu nehmen und der zweite Parser auf diese anzuwenden:<code class = "Seq"
              package = "name/panitz/parser"
              lang = "java"
              commandchars = "_~^"
              sequel = "true">    ParseResult&lt;b&gt; r2 = p2.parse(r1.getRemainingToken());</code>

Sollte dieses schon mißglücken, so ist das Gesamtergebnis auch ein mißglückter
Parsversuch: <code class = "Seq"
              package = "name/panitz/parser"
              lang = "java"
              commandchars = "_~^"
              sequel = "true">    if (r2.failed()) return new ParseResult&lt;Pair&lt;a,b&gt;&gt;(null,ts);</code>

Sind schließlich beide Parser erfolgreich gewesen ist ein erfolgreiches
Ergebnis als Paar der beiden Teilergebnisse zu bilden.<code class = "Seq"
              package = "name/panitz/parser"
              lang = "java"
              commandchars = "_~^"
              sequel = "true">    return new ParseResult&lt;Pair&lt;a,b&gt;&gt;
                 (new Pair&lt;a,b&gt;(r1.getResult(),r2.getResult())
                 ,r2.getRemainingToken());
  }
}</code></subsection><subsection titel = "Parser zum Bilden der Alternative zweier Parser">
Das zweite Bildungsprinzip, um für eine Grammatik einen Parser zu bauen, ist
die alternative Anwendung zweier bestehender Parser. In einer einfachen
Chomskygrammatik stellt sich dieses durch zwei Regelalternativen dar. <p/>

Haben wir in der Grammatik zwei Regeln der Form:<quote><em>A</em> ::= <em>B</em><br/><em>A</em> ::= <em>C</em></quote>

So können wir diese lesen als: um das Nichtterminal <tt>A</tt> zu parsen,
versuche den Parser für <em>B</em>, sollte dieses mißglücken versuche mit dem
Parser für <em>C</em> zu Parsen.<p/>

Entsprechend der Klasse <tt>Seq</tt> für die Sequenz von zwei Parsern
definieren wir die Klasse <tt>Alt</tt> für die Alternative aus zwei Parsern:<code class = "Alt"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;

import java.util.List;
import java.util.ArrayList;

public class Alt&lt;a&gt; implements Parser&lt;a&gt;{
  final private Parser&lt;a&gt; p1;
  final private Parser&lt;a&gt; p2;
  public Alt(Parser&lt;a&gt; _p1,Parser&lt;a&gt; _p2){p1=_p1;p2=_p2;}</code>

Zum Parsen der Alternative zweier Parser wird erst der erste der beiden ausprobiert:<code class = "Alt"
              package = "name/panitz/parser"
              sequel = "true"
              lang = "java">  public ParseResult&lt;a&gt; parse(List&lt;Token&gt; ts){
    ParseResult&lt;a&gt; r1 = p1.parse(ts);</code>

Sollte dieses mißglücken, so ist der zweite Parser auf derselben Tokenliste
anzuwenden, andernfalls ist das erfolgreiche Ergebnis des ersten Parses
zurückzugeben.  <code class = "Alt"
              package = "name/panitz/parser"
              sequel = "true"
              lang = "java">    if (r1.failed()) return p2.parse(ts);
    return r1;
  }
}</code></subsection><subsection titel = "Parser zum Verändern des Ergebnisses">
Unsere kleine Parserbibliothek kann bisher drei Dinge:<itemize>
          <item>elementare Parser definieren, die bestimmte Token erkennen</item>
          <item>aus zwei Parsern die Sequenz bilden, die als Ergebnis das Paar der zwei
 Tailparses hat.</item>
          <item>aus zwei Parsern einen neuen Parser bilden, der einen der beiden Parser
 anzuwendet.</item>
        </itemize>

Oft will man etwas mit dem Ergebnis anstellen, nachdem ein Parser es
erfolgreich erkannt hat. Man möchte also auf das Ergebnis eine Funktion
anwenden. Hierzu definieren wir uns eine Schnittstelle, die zunächst einmal
beschreibt, wie Funktionsobjekte definiert sind. <code class = "Function"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;
public interface Function&lt;a,b&gt;{
    b apply(a x);
}</code>

Unsere letzte Klasse zum Bilden von Parsern, beschreibt einen Parser, der
zunächst einen vorgegebenen Parser auf die Tokenliste anwendet und
anschließend auf das erhaltene Ergebnis  eine gegebene  Funktion anwendet.<code class = "Map"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;
import java.util.List;
import java.util.ArrayList;

public class Map&lt;a,b&gt; implements Parser&lt;b&gt;{
  final private Parser&lt;a&gt; p1;
  final private Function&lt;a,b&gt; f;
  public Map(Parser&lt;a&gt; _p1,Function&lt;a,b&gt; _f){p1=_p1;f=_f;}</code>

Zum Parsen wird zunächst der gegebene Parser auf die Tokenliste angewendet:<code class = "Map"
              package = "name/panitz/parser"
              sequel = "true"
              lang = "java">  public ParseResult&lt;b&gt; parse(List&lt;Token&gt; ts){
    ParseResult&lt;a&gt; r1 = p1.parse(ts);</code>
Im Erfolgsfall wird ein neues Ergebnis gebaut, indem auf die Ergebiskomponente
die mitgegebene Funktion angewendet wird.<code class = "Map"
              package = "name/panitz/parser"
              sequel = "true"
              lang = "java">    if (r1.failed()) return new ParseResult&lt;b&gt;(null,ts);
    return new ParseResult&lt;b&gt;
      (f.apply(r1.getResult()),r1.getRemainingToken());
  }
}</code>

Unsere Parserbibliothek ist vollständig. In den nächsten Abschnitten sehen wir
Beispiele, wie sie zum Schreiben von Parsern benutzt werden kann.</subsection><subsection titel = "Beispiel: arithmetische Ausdrücke">
Als Beispiel betrachten wir eine Grammatik, die einfache arithmetische
Ausdrücke generiert.<p/>
Grammatik:<quote><em>start</em>     ::= <em>addExpr</em><br/><em>addExpr</em> ::=  <em>multExpr</em><em>addOp</em><white/><em>addExpr</em><bar/><em>multExpr</em><br/><em>multExpr</em> ::=  zahl<white/><em>multOp</em><white/><em>multExpr</em><bar/> zahl<br/><em>multOp</em> ::= <tt>*</tt><bar/><tt>/</tt><br/><em>addOp</em> ::= <tt>+</tt><bar/><tt>-</tt><br/></quote><subsubsection titel = "Token">
In unserer obigen Grammatik gibt es 5 verschiedene Token. Die vier Operatoren
und Zahlen. Für Zahlen können wir eine einfache Tokenklasse definieren, die
diese beschreibt.<code class = "Zahl"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
public class Zahl implements Token{
  final public int i;
  public Zahl(int _i){i=_i;}
  public boolean equals(Object o){return o instanceof Zahl;} 
}</code>


Die vier Operatoren können wir als Aufzählung realisieren:<code class = "OpToken"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
public enum OpToken implements Token{
 add,sub,mult,div;</code>

Jeder Operator entspricht einer zweistelligen Funktion. Auch dieses können wir
mit Hilfe einer Schnittstelle ausdrücken:<code class = "BinFunction"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;

public interface BinFunction&lt;a,b,c&gt;{
  c apply(a x,b y);
}</code>

Die Operatoren sollen spezielle zweistellige Funktionen auf ganzen Zahlen
sein: <code class = "IntOp"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;

public interface IntOp 
         extends BinFunction&lt;Integer,Integer,Integer&gt;{}</code>

Nun  können wir in der Aufzählungsklasse der Operatortoken noch eine Methode
vorsehen, die zu dem entsprechenden Operator die entsprechende Funktion als
Ergebnis zurückgibt:<code class = "OpToken"
                package = "name/panitz/parser"
                sequel = "true"
                lang = "java">
 public IntOp getFunction(){
   switch (this){
     case div : return new IntOp(){
          public Integer apply(Integer x,Integer y){return x/y;}};
     case mult : return new IntOp(){
          public Integer apply(Integer x,Integer y){return x*y;}};
     case add : return new IntOp(){
          public Integer apply(Integer x,Integer y){return x+y;}};
     default : return new  IntOp(){
          public Integer apply(Integer x,Integer y){return x-y;}};
   }
  }
}</code></subsubsection><subsubsection titel = "AuswertungsParser">
Wir schreiben einen ersten Parser, der für einen arithmetischen Ausdruck
seinen ausgewerteten Wert als Ergenis hat. Für jedes Symbol der Klasse
schreiben wir einen Parser, der eine ganze Zahl als Ergebnis hat. 
Wir fangen mit den Terminalsymbolen an. Zunächst der Parser für Zahlen. Hier
handelt ich sich um den Tokenparser für das Token <tt>Zahl</tt>, auf den die
Funktion, die die eigentliche Zahl extrahiert angewendet wird.  <code class = "ZahlEval"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;

public class ZahlEval implements Parser&lt;Integer&gt;{
  public ParseResult&lt;Integer&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;Zahl,Integer&gt;
        (new ParseToken&lt;Zahl&gt;(new Zahl(0))
        ,new Function&lt;Zahl,Integer&gt;(){
           public Integer apply(Zahl z){return z.i;}}
        ).parse(ts);
  }
}</code>

Als nächstes kümmern wir uns um die Operatoren. In einem Funktionsobjekt
kapseln wir die Funktion, die für ein Operatortoken die entsprechende
zweistellige Funktion extrahiert:<code class = "GetIntOp"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;

public class GetIntOp implements Function&lt;OpToken,IntOp&gt;{
  public IntOp apply(OpToken t){
    return t.getFunction();
  }
}</code>

Der Parser für Punktrechnungsoperatoren besteht aus der Alternative der beiden
Tokenparser mit anschließender Extraktion der binären Funktion:<code class = "MultOpEval"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;

public class MultOpEval implements Parser&lt;IntOp&gt;{
  public ParseResult&lt;IntOp&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;OpToken,IntOp&gt;
      (new Alt&lt;OpToken&gt;
         (new ParseToken&lt;OpToken&gt;(OpToken.mult)
         ,new ParseToken&lt;OpToken&gt;(OpToken.div))
      ,new GetIntOp()).parse(ts);
  }
}</code>

Analog funktioniert der Parser für die Strichrechnung:<code class = "AddOpEval"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;

public class AddOpEval implements Parser&lt;IntOp&gt;{
  public ParseResult&lt;IntOp&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;OpToken,IntOp&gt;
      (new Alt&lt;OpToken&gt;
         (new ParseToken&lt;OpToken&gt;(OpToken.add)
         ,new ParseToken&lt;OpToken&gt;(OpToken.sub))
      ,new GetIntOp()).parse(ts);
  }
}</code>

Als nächstes folgt der Parser für das 
Nichtterminalsymbol <em>multExpr</em>. <quote><em>multExpr</em> ::=  zahl<white/><em>multOp</em><white/><em>multExpr</em><bar/> zahl </quote>

Dieses ist entweder eine Sequenz 
aus <tt>Zahl</tt><em> multOp multExpr</em> oder nur eine <tt>Zahl</tt>.
Die Sequenz hat als Ergebnistyp doppelt verschachtelte Paare des 
Typs: <tt>Pair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;</tt>. Aus diesen Typ
ist eine ganze Zahl zu bilden. Hierfür schreiben wir die 
Klasse <tt>DoIntOp</tt>:<code class = "DoIntOp"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;

public class DoIntOp
   implements Function&lt;Pair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;,Integer&gt;{
  public Integer apply(Pair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt; x){
    return x.getE2().getE1().apply(x.getE1(),x.getE2().getE2());
  }
}</code>

Jetzt können wir entsprechend der Grammatik einen Parser für das 
Nichtterminalsymbol <em>multExpr</em> schreiben:<code class = "MultExprEval"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;

public class MultExprEval implements Parser&lt;Integer&gt;{
  public ParseResult&lt;Integer&gt; parse(List&lt;Token&gt; ts){
    return
      new Alt&lt;Integer&gt;
       (new Map&lt;Pair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;,Integer&gt;
         (new Seq&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;
           (new ZahlEval(),new Seq&lt;IntOp,Integer&gt;
                            (new MultOpEval(),new MultExprEval()))
         ,new DoIntOp()
         )
       ,new ZahlEval()
       ).parse(ts);
  }
}</code>

Analog läßt sich der Parser für das 
Nichtterminalsymbol <em>addExpr</em> schreiben:<quote><em>addExpr</em> ::=  <em>multExpr</em><em>addOp</em><white/><em>addExpr</em><bar/><em>multExpr</em></quote><code class = "AddExprEval"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;

public class AddExprEval implements Parser&lt;Integer&gt;{
  public ParseResult&lt;Integer&gt; parse(List&lt;Token&gt; ts){
    return
      new Alt&lt;Integer&gt;
       (new Map&lt;Pair&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;,Integer&gt;
         (new Seq&lt;Integer,Pair&lt;IntOp,Integer&gt;&gt;
           (new MultExprEval(),new Seq&lt;IntOp,Integer&gt;
                            (new AddOpEval(),new AddExprEval()))
         ,new DoIntOp()
         )
       ,new MultExprEval()
       ).parse(ts);
  }
}</code>

Damit sind wir fertig. <em>addExpr</em> ist das Startsymbol der Grammatik.<code class = "EvalArith"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;

public class EvalArith implements Parser&lt;Integer&gt;{
  Parser&lt;Integer&gt; startExpr = new AddExprEval();

  public ParseResult&lt;Integer&gt; parse(List&lt;Token&gt; ts){
    return startExpr.parse(ts);
  }
}</code>

Im folgenden eine kleine Testklasse für unseren ersten handgeschriebenen
Parser: <code class = "TestEvalArith"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;
import java.util.ArrayList;

public class TestEvalArith {

  public static void main(String[] _){
    List&lt;Token&gt; ts = new ArrayList&lt;Token&gt;();
    ts.add(new Zahl(17));
    ts.add(OpToken.mult);
    ts.add(new Zahl(2));
    ts.add(OpToken.add);
    ts.add(new Zahl(8));

    ParseResult&lt;Integer&gt; res = new EvalArith().parse(ts);
    System.out.println(res.getResult());
    System.out.println(res.getRemainingToken());
  }
}</code></subsubsection><subsubsection titel = "Aufbau eines Parsbaumes">
In diesen Abschnitt schreiben wir einen zweiten Parser für die Grammatik der
arithmetischen Ausdrücke. Dieses mal liefert der Parser einen Baum als
Ergebnis. <p/>

Für jedes Symbol der Sprache schreiben wir wiesder genau eine Klasse. Die
Klasse unterscheiden sich von den Parserklassen des vorherigen Parser nur in
den Funktionsobjekten, die das Ergebnis berechnen.<code class = "ZahlTree"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import name.panitz.data.tree.*;
import java.util.List;

public class ZahlTree implements Parser&lt;Tree&lt;String&gt;&gt;{
  public ParseResult&lt;Tree&lt;String&gt;&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;Zahl,Tree&lt;String&gt;&gt;
        (new ParseToken&lt;Zahl&gt;(new Zahl(0))
        ,new Function&lt;Zahl,Tree&lt;String&gt;&gt;(){
           public Tree&lt;String&gt; apply(Zahl z){
             return new Tree&lt;String&gt;(&quot;&quot;+z.i);}}
        ).parse(ts);
  }
}</code><code class = "OpTree"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import name.panitz.data.tree.*;

public interface OpTree 
    extends BinFunction&lt;Tree&lt;String&gt;,Tree&lt;String&gt;,Tree&lt;String&gt;&gt;{}</code><code class = "GetOpTree"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;
import java.util.ArrayList;

public class GetOpTree implements Function&lt;OpToken,OpTree&gt;{
  public OpTree apply(final OpToken t){
    return 
      new OpTree(){
        public Tree&lt;String&gt; apply(Tree&lt;String&gt;op1,Tree&lt;String&gt; op2){
          List&lt;Tree&lt;String&gt;&gt; cs = new ArrayList&lt;Tree&lt;String&gt;&gt;();
          cs.add(op1);
          cs.add(op2);
          return new Tree&lt;String&gt;(t.toString(),cs);
        }
      };
  }
}</code><code class = "MultOpTree"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;

public class MultOpTree implements Parser&lt;OpTree&gt;{
  public ParseResult&lt;OpTree&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;OpToken,OpTree&gt;
      (new Alt&lt;OpToken&gt;
         (new ParseToken&lt;OpToken&gt;(OpToken.mult)
         ,new ParseToken&lt;OpToken&gt;(OpToken.div))
      ,new GetOpTree()).parse(ts);
  }
}</code><code class = "AddOpTree"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;

public class AddOpTree implements Parser&lt;OpTree&gt;{
  public ParseResult&lt;OpTree&gt; parse(List&lt;Token&gt; ts){
    return new Map&lt;OpToken,OpTree&gt;
      (new Alt&lt;OpToken&gt;
         (new ParseToken&lt;OpToken&gt;(OpToken.add)
         ,new ParseToken&lt;OpToken&gt;(OpToken.sub))
      ,new GetOpTree()).parse(ts);
  }
}</code><code class = "DoOpTree"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import name.panitz.data.tree.*;

public class DoOpTree
 implements  Function&lt;Pair&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;
                     ,Tree&lt;String&gt;&gt; {
  public Tree&lt;String&gt; apply
                   (Pair&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt; x){
    return x.getE2().getE1().apply(x.getE1(),x.getE2().getE2());
  }
}</code><code class = "MultExprTree"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;

public class MultExprTree implements Parser&lt;Tree&lt;String&gt;&gt;{
  public ParseResult&lt;Tree&lt;String&gt;&gt; parse(List&lt;Token&gt; ts){
    return
      new Alt&lt;Tree&lt;String&gt;&gt;
       (new Map&lt;Pair&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;,Tree&lt;String&gt;&gt;
         (new Seq&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;
           (new ZahlTree(),new Seq&lt;OpTree,Tree&lt;String&gt;&gt;
                            (new MultOpTree(),new MultExprTree()))
         ,new DoOpTree()
         )
       ,new ZahlTree()
       ).parse(ts);
  }
}</code><code class = "AddExprTree"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import name.panitz.data.tree.*;

import java.util.List;

public class AddExprTree implements Parser&lt;Tree&lt;String&gt;&gt;{
  public ParseResult&lt;Tree&lt;String&gt;&gt; parse(List&lt;Token&gt; ts){
    return
      new Alt&lt;Tree&lt;String&gt;&gt;
       (new Map&lt;Pair&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;,Tree&lt;String&gt;&gt;
         (new Seq&lt;Tree&lt;String&gt;,Pair&lt;OpTree,Tree&lt;String&gt;&gt;&gt;
           (new MultExprTree(),new Seq&lt;OpTree,Tree&lt;String&gt;&gt;
                            (new AddOpTree(),new AddExprTree()))
         ,new DoOpTree()
         )
       ,new MultExprTree()
       ).parse(ts);
  }
}</code><code class = "TreeArith"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import java.util.List;
import name.panitz.data.tree.*;

public class TreeArith implements Parser&lt;Tree&lt;String&gt;&gt;{
  Parser&lt;Tree&lt;String&gt;&gt; startExpr = new AddExprTree();

  public ParseResult&lt;Tree&lt;String&gt;&gt; parse(List&lt;Token&gt; ts){
    return startExpr.parse(ts);
  }
}</code><code class = "TestTreeArith"
                package = "name/panitz/parser"
                lang = "java">package name.panitz.parser;
import name.panitz.data.tree.*;
import java.util.List;
import java.util.ArrayList;
import javax.swing.*;

public class TestTreeArith {

  public static void main(String[] _){
    List&lt;Token&gt; ts = new ArrayList&lt;Token&gt;();
    ts.add(new Zahl(17));
    ts.add(OpToken.mult);
    ts.add(new Zahl(2));
    ts.add(OpToken.add);
    ts.add(new Zahl(8));
    ts.add(OpToken.mult);
    ts.add(new Zahl(2));
    ts.add(OpToken.div);
    ts.add(new Zahl(1));
    ts.add(OpToken.add);
    ts.add(new Zahl(1));
    ts.add(OpToken.sub);
    ts.add(new Zahl(1));
    ParseResult&lt;Tree&lt;String&gt;&gt; res = new TreeArith().parse(ts);
    JFrame f = new JFrame();
    f.getContentPane().add(new DisplayTree(res.getResult()));
    f.pack();
    f.setVisible(true);
    System.out.println(res.getRemainingToken());
  }
}</code></subsubsection></subsection><subsection titel = "Tokenizer">
Wir wollen wenigstens für die Grammatik der arithmetischen Ausdrücke
einen Tokenizer schreiben, so daß wir eine Anwendung schreiben können,
die eine Datei liest, deren Inhalt als arithmetischen Ausdruck parst
und in einer Bilddatei den Ableitungsbaum darstellt.<p/>

Wir sehen eine Klasse vor, die Tokenizerobjekte für die Token in
arithmethischen Ausdrücken darstellt:<code class = "ArithTokenizer"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;
import java.util.List;
import java.util.ArrayList;
import java.io.Reader;
import java.io.StringReader;
import java.io.IOException;

class ArithTokenizer {</code>


Ein Tokenizer soll auf einen Eingabestrom des 
Typs <tt>Reader</tt> operieren. Ein Feld soll das aktuelle aus diesem
Strom untersuchte Zeichen enthalten, und eine Liste die bisher
gefundenen Token:
 <code class = "ArithTokenizer"
              sequel = "true"
              package = "name/panitz/parser"
              lang = "java">  Reader reader; 
  int next=0;
  List&lt;Token&gt; result = new ArrayList&lt;Token&gt;();</code>

Wir sehen einen Konstruktor vor, der den Strom, aus dem gelesen wird
übergeben bekommt, und das erste Zeichen aus diesem Strom einliest:<code class = "ArithTokenizer"
              sequel = "true"
              package = "name/panitz/parser"
              lang = "java">  ArithTokenizer(Reader reader){
    this.reader=reader;
    try {
      next= reader.read();
    }catch (IOException _){}
  }</code>
  
Die entscheidene Methode <tt>tokenize</tt> liest nach und nach die
Zeichen aus dem Eingabestrom und erzeugt ja nach gelesenen Zeichen ein
Token für die Ergebnistokenliste:<code class = "ArithTokenizer"
              sequel = "true"
              package = "name/panitz/parser"
              lang = "java">  List&lt;Token&gt; tokenize() throws Exception{
    try {
      while (next&gt;=0){
        char c = (char)next;
        switch (c){</code>

Für Leerzeichen wird kein Token erzeugt:<code class = "ArithTokenizer"
              sequel = "true"
              package = "name/panitz/parser"
              lang = "java">          case &#39;\u0020&#39;  : break;
          case &#39;\n&#39; : break;
          case &#39;\t&#39; : break;</code>

Token, die aus einen Zeichen bestehen, erzeugen sobald das Zeichen
erkannt wurde ein Tokenobjekt für die Ausgabeliste:<code class = "ArithTokenizer"
              sequel = "true"
              package = "name/panitz/parser"
              lang = "java">          case &#39;+&#39;  : result.add(OpToken.add) ; break;
          case &#39;-&#39;  : result.add(OpToken.sub) ; break;
          case &#39;*&#39;  : result.add(OpToken.mult); break;
          case &#39;/&#39;  : result.add(OpToken.div) ; break;</code>

Wenn keines der obigen Zeichen gefunden wurde, kann es sich nur noch
um den Anfang einer Zahl, oder um eine fehlerhafte Eingabe handeln.
Wir unterscheiden, ob das Zeichen eine Ziffer darstellt, und versuchen
eine Zahl zu lesen, oder werfen eine Ausnahme:<code class = "ArithTokenizer"
              sequel = "true"
              package = "name/panitz/parser"
              lang = "java">          default   : if (Character.isDigit(c)) {
                        result.add(getInt());
                        continue;
                      }else throw new Exception
                            (&quot;unexpected Token found: &#39;&quot;+c+&quot;&#39;&quot;);
        }</code>

Schließlich können wir den Strom um ein neues Zeichen bitten:<code class = "ArithTokenizer"
              sequel = "true"
              package = "name/panitz/parser"
              lang = "java">
        next = reader.read();
      }
    }catch (IOException _){}
    return result;
  }
</code>

Zum Lesen von Zahlen holen wir solange Zeichen, wie noch Ziffern im
Eingabestrom zu finden sind und addieren diese auf.<code class = "ArithTokenizer"
              sequel = "true"
              package = "name/panitz/parser"
              lang = "java">
  Token getInt() throws IOException {
    int res=0;
    while (next&gt;=0 &amp;&amp; Character.isDigit((char)next)){
      res=res*10+next-48;
        next = reader.read();
    }
      
    return new Zahl(res);
  }
</code>

Schließlich schreiben wir uns zwei statische Methoden zur einfachen
Benutzung des Tokenizers. <code class = "ArithTokenizer"
              sequel = "true"
              package = "name/panitz/parser"
              lang = "java">
  static List&lt;Token&gt; tokenize(String inp) throws Exception{
    return tokenize(new StringReader(inp));
  }

  static List&lt;Token&gt; tokenize(Reader inp) throws Exception{
      return new ArithTokenizer(inp).tokenize();
  }
}</code>

So lassen sich einfache Test in Jugs schnell durchführen:<scode>sep@swe10:~/fh/prog2/examples&gt; java Jugs
     __ __  __  ____   ___      _________________________________________
     || ||  || ||  || ||__      Jugs: the interactive Java interpreter
     || ||__|| ||__||  __||     Copyright (c) 2003 Sven Eric Panitz
     ||         ___||           World Wide Web:
||   ||                                  http://www.tfh-berlin.de/~panitz
\\__//  Version: February 2003  _________________________________________


&gt;ArithTokenizer.tokenize(&quot;888+0009   *+-/   9&quot;)
[888, add, 9, mult, add, sub, div, 9]
&gt;ArithTokenizer.tokenize(&quot;888+0009   *uiu**+- 09&quot;)
java.lang.Exception: unexpected Token found: &#39;u&#39;
&gt;</scode>

Wir können die unterschiedlichsten Klassen aus diesem Skript für eine
kleine Anwendung zusammensetzen. Wir lesen eine Datei mit der 
Endung <tt>.arith</tt>, in der ein arithmetischer Ausdruck steht. Die
Datei wird gelesen, die Tokenliste erzeugt und diese mit dem Parser
geparst. Der erzeugte Ableitungsbaum wird in eine<tt>png</tt>-Bilddatei geschrieben. Wir sehen ein paar praktische
statische Methoden zum Testen in Jugs und eine Hauptmethode vor:<code class = "ArithParsTreeBuilder"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;
import java.io.*;
import javax.imageio.ImageIO; 
import javax.swing.*; 
import name.panitz.data.tree.Tree;
import name.panitz.data.tree.DisplayTree;
import static name.panitz.data.tree.TreeToFile.treeToFile;

class ArithParsTreeBuilder{
  
  public static void main(String [] args) throws Exception{
    final String fileName = args[0];
    writeParsTreeFile(new FileReader(fileName+&quot;.arith&quot;),fileName);    
  }

  static void writeParsTreeFile(Reader reader,String fileName)
                                               throws Exception{
    treeToFile(parsArith(reader),fileName);            
  }

  public static Tree&lt;String&gt; parsArith(Reader reader) 
                                               throws Exception{
    final ParseResult&lt;Tree&lt;String&gt;&gt; res
     = new TreeArith().parse(ArithTokenizer.tokenize(reader));
    return res.getResult();
  }

  public static DisplayTree parseAndShow(String inp) 
                                      throws Exception{
    return new DisplayTree(parsArith(new StringReader(inp)));
  }

  public static void parseAndShowInFrame(String inp)
                                      throws Exception{
    JComponent c = ArithParsTreeBuilder.parseAndShow(inp);
    JFrame f = new JFrame();
    f.getContentPane().add(c);
    f.pack();
    f.setVisible(true);
  }
}</code></subsection><aufgabe><b>(2 Punkte)</b> In dieser Aufgabe sollen Sie den Parser für
arithmetische Ausdrücke um geklammerte Ausdrücke erweitern. 
Hierzu sei die Grammatik für die Regel <em>multExpr</em> wie folgt geändert:<quote><em>multExpr</em> ::=  <em>atomExpr</em><white/><em>multOp</em><white/><em>multExpr</em><bar/><em>atomExpr</em><br/><em>atomExpr</em> ::= <tt>(</tt><em>addExpr</em><tt>)</tt><tt>|</tt><em>zahl</em></quote>

Hierzu sei die entsprechende zusätzliche Tokenaufzählung für die zwei
Klammersymbole gegeben:<code class = "Parentheses"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;
public enum Parentheses implements Token{lpar,rpar;}</code>

Zusätzlich gegeben sei die die folgende Funktion:<code class = "DoParentheses"
              package = "name/panitz/parser"
              lang = "java">package name.panitz.parser;

public class DoParentheses
  implements  
    Function&lt;Pair&lt;Parentheses,Pair&lt;Integer,Parentheses&gt;&gt;,Integer&gt;{
  public Integer 
             apply(Pair&lt;Parentheses,Pair&lt;Integer,Parentheses&gt;&gt; x){
    return x.getE2().getE1();
  }
}</code><unteraufgaben>
          <teil>Schreiben Sie eine Klasse <tt>AtomExprEval</tt>, 
die <tt>Parser&lt;Integer&gt;</tt> implementiert und der Regel 
für <em>atomExpr</em> entspricht.</teil>
          <teil>Ändern Sie die Klasse <em>MultExprEval</em>, so daß sie der geänderten
Grammatikregel entspricht. </teil>
          <teil>Erweitern Sie die Klasse <tt>ArithTokenizer</tt>, so daß er auch die
beiden Klammersymbole erkennt.</teil>
        </unteraufgaben></aufgabe></section><section titel = "Parsergeneratoren">
Im letzem Abschnitt haben wir gesehen, daß die Aufgabe einen Parser für
eine kontextfreie Grammatik zu schreiben eine mechanische Arbeit
ist. Nach bestimmten Regeln läßt sich eine Grammatik direkt in einen
Parser umsetzen. In unserem in Java geschriebenen Parser führte jede
Regel zu genau einer Methode. <p/>
Aus der Tatsache, daß einen Parser für eine Grammatik zu schreiben
eine mechanische Tätigkeit ist, folgt sehr schnell, daß man diese
gerne automatisiert durchführen möchte und in der Tat schon sehr bald
gab es Werkzeuge, die diese Aufgabe übernehmen konnten, sogenante
Parsergeneratoren. Heutzutage schreibt kaum ein Programmierer in einer
Sprache wie Java einen Parser von Hand, sondern läßt den Parser aus
der Definition der Grammatik generieren.<p/>

Der wohl am weitesten verbreitete Parsergenerator ist
Yacc<cite label = "yacc"/>. Wie man seinem Namen, der für <em>yet
another compiler compiler</em> steht, entnehmen kann, war dieses bei
weiten nicht der erste Parsergenerator. Yacc erzeugt traditionell
C-Code; es gibt aber mitlerweile auch Versionen, die Java-Code
generieren. Ein weitgehendst funktionsgleiches Programm zu Yacc 
heißt <em>Bison</em>. Die lexikalische Analyse steht im im
Zusammenspiel mit Yacc und Bison jeweils auch ein Generatorprogramm
zur Verfügung, daß einen Tokenizer generiert. Dieses Programm 
heißt <tt>lex</tt>.<p/>
Weitere modernere und auf Java zugeschnittene Parsergeneratoren 
sind: <tt>yavacc</tt>, <tt>antlr</tt> und <tt>gentle</tt><cite label = "grudeGentle"/>.<subsection titel = "javacc">
Wir wollen uns die Mühe machen, einen Parser mit einem Parsergenerator
zu beschreiben. Hierzu nehmen wir den 
Parsergenerator <tt>javacc</tt>. Dieser Parsergenerator kommt mit zwei
Progammen: <itemize><item><tt>jjtree</tt>: Dieses Programm generiert Klassen, mit denen
der Ableitungsbaum eines Parses dargestellt werden kann. Es nimmt als
Eingabedatei eine Beschreibung der Grammatik. Diese Datei hat die
Endung <tt>.jjt</tt>. Sie generiert Klassen für die Baumknoten. 
Zusätzlich generiert
es eine Datei mit der Endung <tt>.jj</tt>. die im nächsten Schritt
Eingabe für den eigentlichen Parsergenerator ist.</item><item><tt>javacc</tt>: Dieses Programm generiert eine Klasse für den
eigentlichen Parser. Seine Eingabe ist eine Beschreibung der Grammatik
in einer Datei mit Endung <tt>.jj</tt>.</item> Sie generiert eine
Klasse für den Parser und eine für die
Token, die in der Grammatik spezifiziert werden. Zusätzlich werden
Klassen zur Fehlerbehandlung generiert.</itemize>

Eine wichtige Frage bei der Benutzung eines Parsergenerators ist, nach
welcher Strategie der generierte Parser vorgeht. Wenn es ein rekurisv
absteigender Parser ist, so dürfen wir keine Linksrekursion in der
Grammatik haben. Wenn der generierte Parser 
kein <em>backtracking</em> hat, dann muß er mit Betrachtung des
aktuellen Tokens wissen, welche Regelalternative zu wählen ist. Die
Alternativen brauchen entsprechend disjunkte Startmengen. Bei
generierten Parsern mit der Strategie des Schieben und Reduzierens,
kann es sein, daß es zu sogenannten <em>shift-reduce</em> Konflikten
kommt, wenn nämlich bereits reduziert werden kann, aber auch nach
einem <em>shift</em>-Schritt reduziert werden kann.<p/>

Desweiteren ist wichtig, was für Konstrukte die Eingabegrammtik
zuläßt. Konfortable moderne Parsergeneratoren lassen heute die
erweiterte Backus-Naur-Form zur Beschreibung der Grammatik zu.<p/><tt>javacc</tt> generiert einen rekursiv absteigenden Parser 
ohne <tt>backtracking</tt>. Es darf also keine linksrekursive Regel in
der Grammatik sein.<p/><tt>javacc</tt> integriert einen Tokenizer, d.h.<white/>mit der
Grammatik werden auch die Token definiert.<example>Als erstes Beispiel  wollen wir für unsere Sprache astronomischer
Aussagen einen Parser generieren lassen. Hierzu schreiben wir eine
Eingabegrammatikdatei mit den Namen <tt>sms.jjt</tt>.<footnote>SMS
stehe hier für <em>Sonne Mond und Sterne</em>.</footnote>.<p/>
Die Datei <tt>sms.jjt</tt> beginnt mit einer Definition der Klasse,
die den Parser enthalten soll. In unserem Beispiel soll die generierte
Klasse <tt>SMS</tt> heißen:<code class = "sms"
                lang = "jj">PARSER_BEGIN(SMS)
public class SMS {
}
PARSER_END(SMS)</code>

Anschließend lassen sich die Token der Sprache definieren. In unserem
Beispiel gibt es 8 Wörter. Wir können für  <tt>javacc</tt> definieren,
daß Groß-und-Kleinschreibung für unsere Wörter irrelevant ist. <code class = "sms"
                lang = "jj"
                sequel = "true">TOKEN [IGNORE_CASE] :
{ &lt;MOON: &quot;moon&quot;&gt;
| &lt;MARS: &quot;mars&quot;&gt;
| &lt;MERCURY: &quot;mercury&quot;&gt;
| &lt;PHOEBUS: &quot;phoebus&quot;&gt;
| &lt;DEIMOS: &quot;deimos&quot;&gt;
| &lt;ORBITS: &quot;orbits&quot;&gt;
| &lt;IS: &quot;is&quot;&gt;
| &lt;A: &quot;a&quot;&gt;
}</code>

Zusätzlich gibt es in <tt>javacc</tt> die Möglichkeit anzugeben, was
für Zwischenraum zwischen den Token stehen darf. In unserem Beispiel
wollen wir Leerzeichen, Tabularturzeichen und Zeilenendezeichen
zwischen den Wörtern als Trennung zulassen: <code class = "sms"
                lang = "jj"
                sequel = "true">SKIP :
{ &quot; &quot;
| &quot;\t&quot;
| &quot;\n&quot;
| &quot;\r&quot;
}</code>

Und schließlich und endlich folgen die Regeln für die Grammatik:<code class = "sms"
                lang = "jjt"
                sequel = "true">void start() : {}
{
  nounPhrase() verbPhrase() 
}

void nounPhrase() : {}
{
  noun()|article() noun()
}

void noun() : {}
{ &lt;MOON&gt;|&lt;MARS&gt;|&lt;MERCURY&gt;|&lt;PHOEBUS&gt;|&lt;DEIMOS&gt;
}

void article() : {}
{&lt;A&gt;}

void verbPhrase() : {}
{
verb() nounPhrase()
}

void verb() : {}
{
 &lt;IS&gt;|&lt;ORBITS&gt;
}</code>

Aus dieser Datei <tt>sms.jj</tt> lassen sich jetzt mit dem 
Programm <tt>jjtree</tt> Klassen für die Darstellung des
Ableitungsbaums generieren:<scode>sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; ls
sms.jjt
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; jjtree sms.jjt
Java Compiler Compiler Version 2.1 (Tree Builder)
Copyright (c) 1996-2001 Sun Microsystems, Inc.
Copyright (c) 1997-2001 WebGain, Inc.
(type &quot;jjtree&quot; with no arguments for help)
Reading from file sms.jjt . . .
File &quot;Node.java&quot; does not exist.  Will create one.
File &quot;SimpleNode.java&quot; does not exist.  Will create one.
Annotated grammar generated successfully in sms.jj
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; ls
JJTSMSState.java  SMSTreeConstants.java  sms.jj
Node.java         SimpleNode.java        sms.jjt
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt;
</scode>
Wie zu sehen ist, werden Klassen für Baumknoten 
generiert (<tt>SimpleNode.java</tt>) und eine Eingabedatei für den
eigentlichen Parsergenerator (<tt>sms.jj</tt>). Jetzt können wir
diesen Parser generieren lassen:<scode>sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; javacc sms.jj
Java Compiler Compiler Version 2.1 (Parser Generator)
Copyright (c) 1996-2001 Sun Microsystems, Inc.
Copyright (c) 1997-2001 WebGain, Inc.
(type &quot;javacc&quot; with no arguments for help)
Reading from file sms.jj . . .
File &quot;TokenMgrError.java&quot; does not exist.  Will create one.
File &quot;ParseException.java&quot; does not exist.  Will create one.
File &quot;Token.java&quot; does not exist.  Will create one.
File &quot;SimpleCharStream.java&quot; does not exist.  Will create one.
Parser generated successfully.
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; ls
JJTSMSState.java     SMSConstants.java      SimpleNode.java     sms.jjt
Node.java            SMSTokenManager.java   Token.java
ParseException.java  SMSTreeConstants.java  TokenMgrError.java
SMS.java             SimpleCharStream.java  sms.jj
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt;
</scode>
Die generierten Javaklassen lassen sich übersetzen:<scode>sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; javac *.java
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; ls
JJTSMSState.class     SMSConstants.class      SimpleNode.class
JJTSMSState.java      SMSConstants.java       SimpleNode.java
Node.class            SMSTokenManager.class   Token.class
Node.java             SMSTokenManager.java    Token.java
ParseException.class  SMSTreeConstants.class  TokenMgrError.class
ParseException.java   SMSTreeConstants.java   TokenMgrError.java
SMS.class             SimpleCharStream.class  sms.jj
SMS.java              SimpleCharStream.java   sms.jjt
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt;</scode>
Bevor wir den Parser benutzen können, schauen wir uns die generierter
Parserdatei <tt>SMS.java</tt> in Auszügen einmal an:<code commandchars = "|~^">/* Generated By:JJTree&amp;JavaCC: Do not edit this line. SMS.java */
public class SMS/*bgen(jjtree)*/
implements SMSTreeConstants, SMSConstants {/*bgen(jjtree)*/

  protected static JJTSMSState jjtree = new JJTSMSState();

  static final public void start() throws ParseException {
                /* bgen(jjtree) start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      nounPhrase();
      verbPhrase();
    } catch (Throwable jjte000) {

...



  static final public void nounPhrase() throws ParseException {
                     /* bgen(jjtree) nounPhrase */
  SimpleNode jjtn000 = new SimpleNode(JJTNOUNPHRASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MOON:
      case MARS:
      case MERCURY:
      case PHOEBUS:
      kcase DEIMOS:


  public SMS(java.io.InputStream stream) {
    if (jj_initialized_once) {


....
</code>
Als erstes ist festzustellen, daß der generierte Parser kein gutes
objektorientiertes Design hat. 
Es gibt für jede Regel der Grammatik eine Methode, allerdings sind
alle Methoden statisch.<p/>
Es gibt einen Konstruktor dem ein Objekt des 
Typs <tt>java.io.InputStream</tt>, in dem die zu parsende Eingabe
übergeben wird.<p/>
Alle Methoden können im Fehlerfall 
eine <tt>ParseException</tt> werfen, die angibt, wieso eine Eingabe
nicht geparst werden konnte.<p/>

Es gibt ein Feld <tt>jjtree</tt>des Typs  <tt>JJTSMSState</tt>, in
welchem das Ergebnis des Parses gespeichert ist. Diese Klasse enthält
eine Methode <tt>Node rootNode()</tt>, mit der die Wurzel des
Ableitungsbaums erhalten werden kann.<p/>
 
Damit können wir eine Hauptmethode schreiben, in der wir den
generierten Parser aufrufen. <code>public class MainSMS {
  public static void main(String args[]) throws ParseException {
    SMS parser = new SMS(System.in);
    parser.start();
    ((SimpleNode)parser.jjtree.rootNode()).dump(&quot;&quot;);
  }
}</code>
Als Eingabestrom definieren wir die Tastatureingabe. Wir benutzen die
  Methode <tt>dump</tt>, um den Ableitungsbaum auf dem Bilschirm
  auszugeben. Wir können nun das Hauptprgramm starten und mit der
  Tastatur Sätze eingeben:<scode>sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; javac *.java
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; java MainSMS
a moon orbits mars
start
 nounPhrase
  article
  noun
 verbPhrase
  verb
  nounPhrase
   noun
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt; java MainSMS
mars is a red planet
Exception in thread &quot;main&quot; TokenMgrError: 
Lexical error at line 1, column 11.  Encountered: &quot;r&quot; (114), after : &quot;&quot;
        at SMSTokenManager.getNextToken(SMSTokenManager.java:447)
        at SMS.jj_ntk(SMS.java:298)
        at SMS.noun(SMS.java:84)
        at SMS.nounPhrase(SMS.java:50)
        at SMS.verbPhrase(SMS.java:133)
        at SMS.start(SMS.java:12)
        at MainSMS.main(MainSMS.java:4)
sep@swe10:~/fh/prog2/beispiele/javacc/sms&gt;
</scode></example><aufgabe>Fügen Sie der Datei <tt>sms.jjt</tt> folgende Zeilen am
Anfang ein:<code>options {
   MULTI=true;
   STATIC=false;
}</code>
Generieren Sie mit <tt>jjtree</tt> und <tt>javac</tt> den Parser
   neu. Was hat sich geändert?</aufgabe></subsection></section></kapitel>
  <kapitel titel = "Java und der Rest der Welt">
    <section titel = "I18N, L12N"/>
    <section titel = "Socketkommunikation "/>
    <section titel = "RMI">
Java bietet die Möglichkeit, programme verteilt auf verschiedenen Rechnern
laufen zu lassen. Es läuft dabei auf mehreren Rechnern eine Instanz der
virtuellen Maschine. Es ist dann möglich, von der einen Maschine Methoden auf
Objekten, die auf der anderen Maschinen existieren, aufzurufen. Dieses Prinzip
wird RMI bezeichnet. Es steht für <em>remote method 
invocation</em>. Hierzu müssen
die Parameter der aufgerufenen Methode über ein Netzwerk an die entfernte
viruelle maschine geschickt werden und das Ergebnis der Methode ebenso wieder
über das Netzwerk an die aufrufende Methode zurückgeschickt werden. RMI
realisiert ein Client-Server Modell.<p/>

Schnittstellen sind in der Modellierung einer RMI Anwendung von entscheidener
Bedeutung. Über eine Schnittstelle definiert der Server, welche Funktionalität
er anbietet. Eine Schnittstelle, die definiert, was ein RMI Servee für
Methoden  zur Verfügung stellt, leitet von der 
Schnittstelle <tt>java.rmi.Remote</tt> ab.<p/>

Beginnen wir mit einer ersten einfachen Anwendung. Unser Server soll eine
Methode <tt>getDate</tt> anbieten, die das aktuelle Datum mit Uhrzeit vom
Server zurückgibt. Dieses läßt sich einfach definieren:<code class = "GetDate"
            lang = "java"
            package = "name/panitz/rmi/date">package name.panitz.rmi.date;

import java.util.Date;
import java.rmi.Remote;
import java.rmi.RemoteException;

public interface GetDate extends Remote {
    Date getDate() throws RemoteException;
}</code>

Jede Methode, die ein RMI Server über das Netzwerk als entfernte Methode
anbietet, muß in seiner <tt>throws</tt>-Klausel die 
Ausnahmeklasse <tt>RemoteException</tt> auflisten.<p/>

Eine Schnittstelle, die <tt>Remote</tt> erweitert läßt sich wie jede normale
Schnittstelle in Java erweitern. Es muß auf keinster Weise berücksichtigt
werden, daß die Methoden über ein Netzwerk von entfernten virtuellen Maschinen
aufgerufen werden. Für unser erstes Beispiel genügt folgende naheliegende
Implementierung.<code class = "GetDateImpl"
            lang = "java"
            package = "name/panitz/rmi/date">package name.panitz.rmi.date;
import java.util.Date;

public class GetDateImpl implements GetDate {
  public Date getDate() {return new Date();}
}</code><subsection titel = "RMI Server">
Mit der Schnittstelle <tt>GetDate</tt> haben wir spezifiziert, welche
Funktionalität übers Netz angeboten werden soll. Die Implementierung setzt
diese Funktionalität um. Jetzt brauchen wir noch ein Programm, das diese
Funktionalität auch im Netz bekannt macht und anbietet; entsprechende
Methodenaufrufe aus dem Netz entgegennimmt, ausführt und das Ergebnis an die
aufrufende Maschine zurücksendet. Hierzu ist eine Serveranwendung zu
schreiben. Diese benötigt eine Instanz der implementierenden Klasse, und muß
diese für die Benutzung unter einem Namen für das Netzwerk
registrieren. Hierzu gibt es in 
Paketen <tt>java.rmi.registry</tt> bzw. <tt>java.rmi.server</tt> drei
entscheidene Klassen:<itemize>
          <item><tt>UnicastRemoteObject</tt>: die statische 
Methode <tt>exportObject</tt> dieser Klasse wandelt ein Objekt in ein Instanz
um, die geeignet ist, über das Netz aufgerufen zu werden. Dahinter verbirgt
sich tatsächlich unter der Hand, der ganze Code, der für die Vorbereitung der
Kommunikation notwendig ist.</item>
          <item><tt>LocateRegistry</tt>: hier kann mit der statischen 
Methode <tt>getRegistry</tt> eine Instanz der auf dem Server laufenden
Registrierumgebung für RMI Objekte erhalten werden. </item>
          <item><tt>Registry</tt>: Objekte dieser Klasse haben die 
Methode <tt>bind</tt>, in der <tt>Remote</tt> Objekte in der RMI Umgebung
bekannt gemacht werden können. Hierbei bindet man einen beliebigen Namen an
das <tt>Remote</tt> Objekt. Unter diesen Namen können Client-Applikationen auf
das <tt>Remote</tt>-Objekt zugreifen.</item>
        </itemize>

Für unser kleines erstes Beispiel einer Servers, der die Zeit angeben kann,
ergibt das folgenden Code. Zunächst wird eine Instanz der implementierenden
Klasse erzeugt. Diese wird als ein Remote Objekt exportiert, dann wird die
RMI-Registry geholt, auf der dann das Objekt bekannt gemacht wird.<code class = "DateServer"
              lang = "java"
              package = "name/panitz/rmi/date">package name.panitz.rmi.date;

import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class DateServer {
  public static void main(String args[]) {
    try {
      GetDateImpl obj = <redv>new GetDateImpl()</redv>;
      GetDate stub = <redv>(GetDate) UnicastRemoteObject.exportObject(obj, 0)</redv>;
      Registry registry = <redv>LocateRegistry.getRegistry()</redv>;
      registry.<redv>bind(&quot;date&quot;, stub)</redv>;
      System.err.println(&quot;Server ready&quot;);
    } catch (Exception e) {
      System.err.println(&quot;Server exception: &quot; + e.toString());
      e.printStackTrace();
    }
  }
}</code>

Die drei bis hierhin geschriebenen Javadateien sind ganz normal mit dem
Javacompiler zu übersetzen. Bevor jedoch die Hauptmethode 
von <tt>DateServer</tt> gestartet werden kann, ist die RMI-Registrierung zu
starten. Hierzu liefert das JDK das Programm <tt>rmiregistry</tt> mit.
Dieses ist auf dem Servermaschine zunächst einmal zu starten. 
Dann ist das Programm <tt>DateServer</tt> zu starten. Diesem ist aber als
Umgebungsparameter mitzugeben, wo der Server seine Javaklassen findet. Hier
reicht der Klassenpfad nicht aus. Es ist das 
Attribut <tt>java.rmi.server.codebase</tt> zu setzen. Insgesammt erhalten wir
folgende kleine Session auf der Kommandozeile:<scode>sep@pc305-3:~/fh/java/student/classes&gt; rmiregistry &amp;
[1] 5492
sep@pc305-3:~/fh/java/student/classes&gt; java -Djava.rmi.server.codebase=fil
e:///home/sep/fh/java/student/classes/ name.panitz.rmi.date.DateServer &amp;
[2] 5502
sep@pc305-3:~/fh/java/student/classes&gt; Server ready

sep@pc305-3:~/fh/java/student/classes&gt;</scode></subsection><subsection titel = "RMI Client">
Unser Server ist jetzt bereit, Methodenaufrufe zu empfangen.  Diese werden von
einem Clientprogramm aus unternommen. Hierzu ist ähnlich wie im Serverprogramm
zu verfahren. Für die RMI-Registry des Servers ist eine repräsentierende 
Instanz zu erzeugen, in der ist unter dem registriertem Namen nach dem
angebotenen entfernten Objekt zu fragen. Schließlich kann dieses wie ein
ganz normales Javaobjekt benutzt werden. Es ist dabei nur zu beachten, daß
eventuell eine  Ausnahme auftritt.<p/>

Für unser Beispiel schreiben wir eine kleine GUI-Anwendung. Der meiste Code
beschäftigt sich dabei mit dem GUI. Die eigentlichen Aufrufe an das auf einer
anderen Maschine laufende Objekt, bestehen aus nur drei Zeilen.<code class = "DateClient"
              lang = "java"
              package = "name/panitz/rmi/date">package name.panitz.rmi.date;
import javax.swing.*;
import java.awt.event.*;

import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class DateClient extends JPanel {
  JButton getButton = new JButton(&quot;get new time from server&quot;);
  JLabel l    = new JLabel();
  DateClient(String host){
    add(getButton);
    add(l);
    try {
      Registry <redv>registry = LocateRegistry.getRegistry(host)</redv>;
      final GetDate <redv>stub = (GetDate) registry.lookup(&quot;date&quot;)</redv>;
      l.setText(&quot;&quot;+<redv>stub.getDate()</redv>);

      getButton.addActionListener(new ActionListener(){
        public void actionPerformed(ActionEvent e){
          try {
            l.setText(&quot;&quot;+<redv>stub.getDate()</redv>);
          }catch (Exception e1){}
        }
      });
    }catch (Exception e) {}
  }

  public static void main(String[] args) {
    JFrame f = new JFrame();
    f.add(new DateClient(args[0]));
    f.pack();
    f.setVisible(true);
  }
}</code></subsection><subsection titel = "Serialisierbarkeit">
Um entfernte Methode aufrufen zu können, müssen die Argumente des
Methodenaufrufs über das Netz evrschickt werden und ebenso das Ergebnis
zurückgeschickt werden. Hierzu müssen sich die entsprechenden Daten in eine
für das verschicken geeignete Art umwandeln lassen, sie müssen serialisierbar
sein. Java kennt das Konzept der Serialisierbarkeit und drückt es über die
Schnittstelle <tt>Serializable</tt> aus. Die einige Einschränkung für RMI
besteht also in der Serialisierbarkeit der in der methodensignatur beteiligten
Typen. </subsection><subsection titel = "Verteilte Spielanwendung">
Da im letzten Abschnitt sich das Schreiben verteilter Anwendungen in Java als
so einfach erwiesen hat, wollen wir in diesem Abschnitt eine weitere kleine
verteilte Anwenung schreiben. Dieses Mal sollen die entfernten Methoden auch
Parameter bekommen. Damit können Clients dem Server Daten schicken, die
anderen Clients dann auch vom Server erfragen können. Somit können die Clients
sich gegenseitig Nachrichten zukommen lassen, die grundlage zum Beispiel eines
jedem Chatprogramms.<p/>

Wir wollen aber keine Chatprogramm entwickeln, sondern eine kleine Anwendung,
in der die Clients einen Punkt auf einer zweidimensionalen Fläche plazieren
und bewegen können. Die einzelnen Clients sehen dabei nicht nur ihre eigenen
Punkte sondern auch die Punkte der anderen Clients.<p/>

Die entsprechende <tt>Remote</tt>-Schnittstelle kommt mit drei Methoden aus:<itemize>
          <item>eine zum Erzeugen eines neuen Balls, wobei jeder Ball durch einen Namen
identifiziert wird.</item>
          <item>eine zum Bewegen eines Balles mit einem bestimmten Namen.</item>
          <item>und eine zum Erfragen der Position eines jeden Balls, der 
existiert.</item>
        </itemize>


Wir bekommen die folgende Schnittstelle:<code class = "BallGame"
              lang = "java"
              package = "name/panitz/rmi/game">package name.panitz.rmi.game;

import java.rmi.*;
import java.util.Map;

public interface BallGame extends Remote {

  void createBall(String name) throws RemoteException;
  void move(String name,int x,int y) throws RemoteException;
  Map&lt;String,java.awt.Dimension&gt; getBalls()throws RemoteException;
}</code>

Für die x-, y-position der Bälle mißbrauchen wir die 
Klasse <tt>Dimension</tt>, die eine 2-dimensionale Position speichern kann,
auch wenn die entsprechenden Felder <tt>width</tt> und <tt>hieght</tt> statt
x und y heißen.<p/>

Auch die Implementierung dieser Schnittstelle läßt sich relativ trivial
bewerkstelligen. Ein privates Feld speichert alle Namens- Dimensionspaare in
einer Abbildung. Die 
Methoden <tt>createBall</tt> und <tt>move</tt> manipulieren diese Abbildung.<code class = "BallGameImpl"
              lang = "java"
              package = "name/panitz/rmi/game">package name.panitz.rmi.game;
import java.util.*;

import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.awt.Dimension;

public class BallGameImpl implements BallGame {
  private Map&lt;String,java.awt.Dimension&gt; bs
    = new HashMap&lt;String,java.awt.Dimension&gt;();

  public void createBall(String name){
    bs.put(name,new Dimension(10,10));}

  public void move(String name,int x,int y){
    Dimension d=bs.get(name);
    if (d!=null) d.setSize(d.width+x,d.height+y);
  }

  public Map&lt;String,java.awt.Dimension&gt; getBalls(){return bs;}
}</code>

Der Server für diese Anwendung sieht exakt aus, wie der Server für die
Datumsanwendung zuvor. <code class = "BallGameServer"
              lang = "java"
              package = "name/panitz/rmi/game">package name.panitz.rmi.game;

import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
public class BallGameServer {
  public static void main(String args[]) {
    try {
      BallGameImpl obj = new BallGameImpl();
      BallGame stub = (BallGame) UnicastRemoteObject.exportObject(obj, 0);
      Registry registry = LocateRegistry.getRegistry();
      registry.bind(&quot;ballgame&quot;, stub);
      System.err.println(&quot;Server ready&quot;);
    } catch (Exception e) {
      System.err.println(&quot;Server exception: &quot; + e.toString());
      e.printStackTrace();
    }
  }
}</code>

Es bleibt das spannenste: der Client. Auch in diesem Beispiel wieder eine
GUI-Anwendung. <code class = "BallGameClient"
              lang = "java"
              package = "name/panitz/rmi/game">package name.panitz.rmi.game;
import javax.swing.*;
import java.awt.event.*;
import java.awt.Graphics;
import java.awt.Dimension;
import java.awt.Color;

import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import static java.awt.event.KeyEvent.*;

import name.panitz.animation.AnimatedJPanel;

public class BallGameClient extends AnimatedJPanel {
  final String name;
  BallGame game=null;
  final int width = 400;
  final int height = 300;

  BallGameClient(String host,String n){
    this.name=n;
    setFocusable(true);
    try {
      Registry registry = LocateRegistry.getRegistry(host);
      game = (BallGame) registry.lookup(&quot;ballgame&quot;);
    } catch (Exception e) {}

    addMouseListener(new MouseAdapter(){
      public void mouseClicked(MouseEvent e){
        try{game.createBall(name);}catch(Exception e1){}
      }
    });

    addKeyListener(new KeyAdapter(){
      public void keyReleased(KeyEvent e){
        try{
          switch (e.getKeyCode()){
            case VK_DOWN: game.move(name,0,2);break;
	    case VK_LEFT:game.move(name,-2,0);break;
            case VK_RIGHT:game.move(name,2,0);break;
            case VK_UP:game.move(name,0,-2);break;
          }
        }catch(Exception e1){System.out.println(e);}
      }
    });
  }

  public void paintComponent(Graphics g){
    g.setColor(Color.WHITE);
    g.fillRect(0,0,width,height);
    try{
      for (Dimension d:game.getBalls().values()){
        g.setColor(Color.RED);
        g.fillOval(d.height,d.width,10,10);
      }
    }catch (Exception e){}
  }

  public Dimension getPreferredSize(){
    return new Dimension(width,height);}

  public static void main(String[] args) {
    JFrame f = new JFrame();
    f.add(new BallGameClient(args[0],args[1]));
    f.pack();
    f.setVisible(true);
  }
  public void move(){}
}</code></subsection></section>
    <section titel = "Java und Datenbanken">
Jede einigermaßen interessante Anwendung besonders im Geschäftsbereich 
verarbeitet an einem bestimmten Punkt persistente Daten, d.h. Daten, die über
die Laufzeit der Anwendung hinaus existieren. Für kleine Datenmengen reicht es
in der Regel aus, diese in einer Datei persistent zu speichern, aber schon
mittelgroße Datenmengen werden in einer Datenbanksystem gehalten. Die gängiste
Form von Datenbanksystemen sind relationale Datenbanken, die als
Datenbankanfragesprache die deklarative Programmiersprache SQL benutzen.<p/>

Im Umgang mit Datenbanken gibt es prinzipiell zwei Varianten für Java:<itemize>
        <item>auf eine bestehende relationale Datenbank soll zugegriffen werden. In
diesem wahrscheinlich häufigeren Fall definiert die Datenbank die Art der
Daten und die Javaanwendung orientiert sich an dieser. </item>
        <item>eine vollkommen neue Anwendung soll objektorientiert entworfen
werden. Hier stehen die Objekte im Mittelpunkt. Objekte sollen dann auch in
einer Datenbank persistent gehalten werden. Nun sind Objekte auf Tabellen
einer relationalen Datenbank abzubilden. Man spricht von OR-Mapping (object
relational mapping)</item>
      </itemize><subsection titel = "JDBC Verbindungen">
Java bietet ein API an, um SQL-Queries an eine Datenbank zu verschicken und
somit Daten aus dieser zu extrahieren oder die Daten zu manipulieren. Im
einfachsten Fall werden die SQL-Ausdrücke in Java als String erzeugt und diese
Stringwerte an eine Datenbank verschickt. Unter diesen Gesichtspunkt reicht es 
aus, in der Datenbankvorlesung gut aufzupassen, um mit Java auf Daten einer
Datenbank zuzugreifen.<p/>

Wie immer, wenn es um den Zugriff auf Datenquellen in der externen Welt geht,
sind die Schwierigkeiten keine programmiersprachlichen, sondern liegen in der
Beherrschung der Spezifika der darunterliegenden Datenquellen in unserem Fall
der Datenbank.<code lang = "java"
              package = "name/panitz/sheetMusic/db/"
              class = "MusicDB">package name.panitz.sheetMusic.db;
import java.sql.*;
public class MusicDB{
  final public Connection con;
  public MusicDB(String host,String database,String userid,String password) 
                                                   throws Exception {
    con = DriverManager
          .getConnection(&quot;jdbc:mysql://&quot;+host+&quot;/&quot;+database,userid,password);
  }</code><subsubsection titel = "SQL expressions">
          <paragraph titel = "Table creation">
            <code lang = "java"
                  package = "name/panitz/sheetMusic/db/"
                  sequel = "true"
                  class = "MusicDB">  public void createTable(String tableName,String tableSpec) 
        throws Exception {    
    final Statement s = con.createStatement();
    s.execute (&quot;create table &quot;+tableName+&quot; &quot;+tableSpec);      
    s.close ( );
  }</code>
          </paragraph>
          <paragraph titel = "Insertion of rows">
            <code lang = "java"
                  package = "name/panitz/sheetMusic/db/"
                  sequel = "true"
                  class = "MusicDB">  public void insertRow(String tableName,String values ) 
                                                   throws Exception {    
    final Statement s = con.createStatement();
    s.execute(&quot;insert into &quot;+tableName+&quot; values &quot;+values);      
    s.close ( );
  }</code>
          </paragraph>
          <paragraph titel = "Queries">
            <code lang = "java"
                  package = "name/panitz/sheetMusic/db/"
                  sequel = "true"
                  class = "MusicDB">  public ResultSet query(String sqlExpr) 
                                           throws Exception {
    return con.createStatement().executeQuery(sqlExpr);
  }</code>
            <code lang = "java"
                  package = "name/panitz/sheetMusic/db/"
                  sequel = "true"
                  class = "MusicDB">}</code>
          </paragraph>
        </subsubsection><subsubsection titel = "Transaktionen"/><subsubsection titel = "Beispiellauf">
          <code lang = "java"
                package = "name/panitz/sheetMusic/db/"
                sequel = "true"
                class = "Example">package name.panitz.sheetMusic.db;
public class Example{
  public static void main(String [] args) throws Exception{
    MusicDB db = new MusicDB(&quot;localhost&quot;,&quot;test&quot;,&quot;sep&quot;,&quot;stammel&quot;);
    try{
    db.createTable
     (&quot;composer&quot;
     ,&quot;(last_name varchar(60),first_name varchar(60),biography text)&quot; );
    db.createTable
     (&quot;opus&quot;
     ,&quot;(composer varchar(60),title varchar(256),opsNr varchar(20),url varchar(128))&quot; );

    db.insertRow
     (&quot;composer&quot;
     ,&quot;(&#39;Legnani&#39;,&#39;Luigi&#39;,&#39;&#39;)&quot;);
    db.insertRow
     (&quot;composer&quot;
     ,&quot;(&#39;Giuliani&#39;,&#39;Mauro&#39;,&#39;&#39;)&quot;);
    db.insertRow
     (&quot;composer&quot;
     ,&quot;(&#39;Fossa&#39;,&#39;Francois de&#39;,&#39;&#39;)&quot;);

    db.insertRow
     (&quot;opus&quot;
     ,&quot;(&#39;Legnani&#39;&quot;+
      &quot;,&#39;36 capricci per tutti i tuoni maggiori e minori per la chitarra&#39;&quot;+
      &quot;,&#39;20&#39;&quot;+
      &quot;,&#39;http://www.kb.dk/elib/noder/rischel/RIBS0501.pdf&#39;)&quot;);
    db.insertRow
     (&quot;opus&quot;
     ,&quot;(&#39;Legnani&#39;&quot;+
      &quot;,&#39;Coro e rondo, Pensa alla patria nell opera L italiana in Algeri del Rossini&#39;&quot;+
      &quot;,&#39;8a&#39;&quot;+
      &quot;,&#39;http://www.kb.dk/elib/noder/rischel/RIBS0480.pdf&#39;)&quot;);    
    db.insertRow
     (&quot;opus&quot;
     ,&quot;(&#39;Legnani&#39;&quot;+
      &quot;,&#39;Introduction et thême&#39;&quot;+
      &quot;,&#39;237&#39;&quot;+
      &quot;,&#39;http://www.kb.dk/elib/noder/rischel/RIBS0490.pdf&#39;)&quot;);    
    }catch(Exception e){
    }   
  }  
}</code>
        </subsubsection></subsection></section>
    <section titel = "JNI: Aufruf von C"/>
    <section titel = "Java unterwegs"> 
Heutzutage tragen die meisten Menschen  einen
Computer in der Tasche, der in Speicherkapazität und Rechenleistung bereits
einen Arbeitsplatzrechner von vor wenigen Jahren übertrifft: das 
Mobiltelephon auch Handy genannt. Auf den meisten
heute handelsüblichen Mobiltelephonen ist auch Javas virtuelle Maschine
vorhanden. Hier kann Java sein Ausführungsmodell wieder perfekt
nutzen. Ursprünglich war es entwickelt worden für Set-Top-Boxen im
Fernsehbereich, erwies sich für kurze Zeit als Killerapplikation im Webbrowser
und kann jetzt auf Mobiltelephonen reüssieren. Was in allen diesen drei
Anwendungen identisch ist: es gibt Clients mit verschiedenste Hardware. 
Ziel ist es
auf diesen Clients 
fremde Software laufen zu lassen, und dieses in einer sicheren
Umgebung, die nur auf kontrollierte Art und Weise auf die Resourcen der
Hardware zugreifen kann.<p/>

Nun untescheidet sich ein Mobiltelephon in vielen Punkten von einem
Arbeitsplatzrechner:<itemize>
        <item>als Bildschirm existiert nur eine kleinste Fläche</item>
        <item>als Tastatur stehen in der Regel nur die Tasten eines Telephons zur
Verfügung. </item>
        <item>der Prozessor ist einfacher gestaltet und unterstützt oft keine
Fließkommaoperationen. </item>
        <item>die Kommunikation läuft auf eingeschränkte definierte Wege.</item>
        <item>Arbeitsspeicher ist wesentlich kleiner.</item>
        <item>statt einer großen Festplatte gibt es einebaute oder austauschbare
Speicherchips.  </item>
        <item>eingehende Anrufe sollten in jedem Fall die Oberhand gegenüber anderen
Applikationen behalten.</item>
      </itemize>

Zieht man diese nicht marginale Unterschiede in Betracht, verwundert es nicht,
daß auf einem Mobiltelephon nicht komplette Javaanwendungen, wie wir sie
bisher entwickelt haben, laufen können. Die virtuelle wie sie auf
Mobiltelephonen installiert ist, stellt nicht die komplette
Javastandardbibliothek zur Verfügung. Sie hat ein stark eingeschränktes
API. Die Gründe weshalb Standardklassen aus Java auf einem Mobiltelephon nicht
zur Verfügung stehen, können unterschiedlichster Natur sein; z.B. lediglich um
die Masse der Klassen zu reduzieren oder weil sie sich auf Hardware beziehen,
wie sie so nicht im Mobiltelephon existiert. <p/>

Um all diesen Überlegungen Rechnung zu tragen, gibt es eine spezielle Java-API
Version für Hardware mit eingeschränkten Resourcen: die Java ME. Hierbei
handelt es sich um eine Version von Java, die im Programmiersprachlichen Sinne
ein volles Java ist. Als Javaübersetzer wird der Standardübersetzer genommen,
den wir bisher auch benutzt haben. Lediglich die verfügbaren Bibliotheken sind
stark reduziert.  Zusätzlich gibt es dafür Bibliotheken, die sich speziell auf
die Bedürfnisse  von Mobiltelephonen bezieht.<p/>

Um bequem Javaanwendungen für Mobiltelephone zu entwicken bieten Java eine
kleine Entwicklungsumgebung an: das J2ME Wireless Toolkit. Diese hilft einem
dabei Javaanwendungen für Telephone zu übersetzen, testen und als fertige
Anwendung zu verpacken. <footnote>Wie man am Namen <ttt>J2ME</ttt> sieht, hat
Java 5 noch 
nicht in die Welt der Kleingeräte einzug gehalten.</footnote><subsection titel = "Hello Mobile World">
Genug der Vorrede, Zeit die erste Javaanwendung fürs Handy zu schreiben.
So wie Anwendungen, die im Browser laufen sollen, von der 
Klasse <tt>Applet</tt> ableiten müssen, müssen Anwendungen, die im Handy
laufen sollen von einer bestimmten Klasse 
ableiten: <tt>javax.microedition.midlet.MIDlet</tt>. Wir schreiben also ein 
sogenanntes Midlet:<code class = "HelloMobileWorld"
              lang = "java"
              bootclasspath = "wtk"
              package = "name/panitz/mobile">package name.panitz.mobile;

import javax.microedition.midlet.MIDlet; 
import javax.microedition.lcdui.*; 
 
public class HelloMobileWorld extends MIDlet{</code>

Ähnlich den den Applets gibt es in Midlets Methoden, die das Verhalten beim
Starten, Pausieren oder endgültigen Zerstören eines Midlets bestimmen.  
Für unsere erste kleine Anwenung reicht es aus, das Verhalten beim Starten zu
definieren. Wir wollen auf dem Display einen Text plazieren. Hierzu erlaubt es
ein Midlet sein Display in Form eines Objekts der 
Klasse <tt>Display</tt> zu erfragen.  Diesem Display kann dann ein 
Objekt der Klasse <tt>Form</tt> hinzugefügt werden, dem wiederum
verschiedenste Text- und Bildelemente zugefügt erden können. Man kann
vielleicht in Analogie zu GUI-Anwendungen in Swing das <tt>Display</tt> mit
einem <tt>JFrame</tt> und das <tt>Form</tt> mit 
einem <tt>JPanel</tt> vergleichen.<code class = "HelloMobileWorld"
              lang = "java"
              bootclasspath = "wtk"
              package = "name/panitz/mobile"
              sequel = "true">  public void startApp() {
    final Display display = Display.getDisplay(this);     
    final Form mainForm = new Form(&quot;TinyMIDlet&quot;);</code> 

Dem <tt>Form</tt>-Objekt läßt sich nun der gewünschte Text hinzufügen:<code class = "HelloMobileWorld"
              lang = "java"
              bootclasspath = "wtk"
              package = "name/panitz/mobile"
              sequel = "true">    mainForm.append(&quot;Welcome to the world of MIDlets!&quot;);</code> 

Auch im Handy gibt es Ereignisse. Das Ereignisbehandlungskonzept ist dabei auf
gleiche Weise realisiert, wie wir es bereits 
aus <em>AWT</em> und <em>Swing</em> kennen. Ein Ereignisbehandler 
für <tt>Form</tt>-Objekte sind Kommandoereignisse. Mit einer anonymen Klasse
fügen wir dem <tt>Form</tt>-Objekt eine Behandlung des 
Kommandos <tt>exit</tt> hinzu, die bewirkt, daß das Midlet schließlich
zerstört wird:<code class = "HelloMobileWorld"
              lang = "java"
              bootclasspath = "wtk"
              package = "name/panitz/mobile"
              sequel = "true">    mainForm.setCommandListener(new CommandListener(){
      public void commandAction(Command c, Displayable s) { 
        if (c.getCommandType() == Command.EXIT) 
          notifyDestroyed(); 
       } 
    });</code>

Das somit erstellte <tt>Form</tt>-Objekt kann nun dem Display zugefügt werden:<code class = "HelloMobileWorld"
              lang = "java"
              bootclasspath = "wtk"
              package = "name/panitz/mobile"
              sequel = "true">    display.setCurrent(mainForm);</code>

Schließlich ist noch das Kommando als <tt>Exit</tt> als Auswahlkommando dem
Midlet hinzuzufügen. 

 <code class = "HelloMobileWorld"
              lang = "java"
              bootclasspath = "wtk"
              package = "name/panitz/mobile"
              sequel = "true">    mainForm.addCommand(new Command(&quot;Exit&quot;, Command.EXIT, 0)); 
  } 
  public void destroyApp(boolean b) {}
  public void pauseApp() {}
} </code><midlet name = "HelloMobileWorld"
                source = "name/panitz/mobile/* "
                class = "name.panitz.games.HelloMobileWorld"/><subsubsection titel = "Übersetzen der drahtlosen Anwendung">
          <paragraph titel = "über die Kommandozeile">
            <code>javac \
  -bootclasspath \
 /home/sep/software/WTK2.2/lib/cldcapi10.jar\
:/home/sep/software/WTK2.2/lib/midpapi20.jar \
-source 1.3 -target 1.3 -d classes HelloMobileWorld.java</code>
          </paragraph>
          <paragraph titel = "mit WTK">


Abbildung <ref label = "Midlet"/> zeigt die Simuation des Handies zu
Testzwecken. <bild name = "Midlet"
                  pdfscale = "0.6"
                  psscale = "0.6"
                  caption = "Handysimulation mit WTK2.2."/></paragraph>
        </subsubsection></subsection><subsection titel = "Pong fürs Handy">
Auch wenn die Vorstellung etwas seltsam ist, daß zwei Spieler auf einem Handy
gegeneinander spielen, wollen wir als Beispiel wieder das 
Telespiel <tt>Pong</tt> programmieren. Im entsprechenden Kapitel über
GUI-Programmierung wurde bereits darauf geachtet, daß das Programm so in
verschiedene Klassen gesplittet wird, daß möglichst viel Code benutzt werden
kann, um die Ponganwendung fürs Telephon zu schreiben. So benutzen wir die
Schnittstelle <tt>AMovable</tt>, um sie jetzt mit 
einer <tt>paint</tt>-Methode zu erweitern, die sich auf 
ein <tt>Graphics</tt>-Objekt des 
Pakets <tt>javax.microedition.lcdui</tt> bezieht.<code bootclasspath = "wtk"
              lang = "java"
              class = "MMovable"
              package = "name/panitz/mobile/pong">
package name.panitz.mobile.pong;
import javax.microedition.lcdui.Graphics;

public interface MMovable extends name.panitz.games.AMovable{
  public void paintMeTo(Graphics g);
}</code>

Ebenso benutzen wir die Klasse <tt>ASimpleMovable</tt> und erweitern diese um
eine Implementierung der entsprechenden Zeichenmethode.<code bootclasspath = "wtk"
              class = "MSimpleMovable"
              lang = "java"
              package = "name/panitz/mobile/pong">package name.panitz.mobile.pong;
import javax.microedition.lcdui.Graphics;

public class MSimpleMovable extends name.panitz.games.ASimpleMovable 
                            implements MMovable{
  public void paintMeTo(Graphics g){
    g.setColor(0x00FFFF);
    g.fillRect(x,y,width,height); 
  }
}</code><code bootclasspath = "wtk"
              lang = "java"
              class = "MBall"
              package = "name/panitz/mobile/pong">
package name.panitz.mobile.pong;
import javax.microedition.lcdui.Graphics;

public class MBall extends MSimpleMovable{
  public MBall(){}
  public MBall(int x,int y){this.x=x;this.y=y;moveX=3;}

  public void paintMeTo(Graphics g ){
    g.setColor(0x00FFFF);
    g.fillArc(x,y,width,height,0,360); 
  }
}</code><code bootclasspath = "wtk"
              lang = "java"
              class = "MPaddle"
              package = "name/panitz/mobile/pong">
package name.panitz.mobile.pong;

public class MPaddle extends MSimpleMovable{
  public MPaddle(int xPos){
    x=xPos;
    width=10;
    height=30;
    moveX=0;
    moveY=2;
  }
}</code><code bootclasspath = "wtk"
              lang = "java"
              class = "PongCanvas"
              package = "name/panitz/mobile/pong">
package name.panitz.mobile.pong;

import javax.microedition.lcdui.*;

public class PongCanvas extends Canvas implements Runnable {
  Display display;
  MBall ball=null;
  MPaddle leftPaddle = new MPaddle(10);
  MPaddle rightPaddle= new MPaddle(getWidth()-20);
  final MMovable[] paddles = {leftPaddle,rightPaddle};
  int leftPoints=0;
  int rightPoints=0;
  static final int LEFT_PL=0;
  static final int RIGHT_PL=1;
  int nextPlayer=LEFT_PL;

  boolean paused = false;

  public PongCanvas(Display d) {display = d;}

  final int delay = 20;
  public void run() {
    while (!paused){
      move();
      repaint();
      try {
        Thread.sleep(delay);
      } catch (InterruptedException e) {}
    }
  }

  String msg = null;
  protected void paint(Graphics g) {
    int x = g.getClipX();
    int y = g.getClipY();
    int w = g.getClipWidth();
    int h = g.getClipHeight();

    // Draw the frame 
    g.setColor(0xffffff);
    g.fillRect(x, y, w, h);

    paddles[0].paintMeTo(g);
    paddles[1].paintMeTo(g);
    if (null!=ball) ball.paintMeTo(g);

    g.setColor(0x000000);
    g.drawString(&quot;&quot;+leftPoints,30,30,g.TOP|g.LEFT);
    g.drawString(&quot;&quot;+rightPoints,getWidth()-30,30,g.TOP|g.RIGHT);


    g.setColor(0);
    g.drawRect(0, 0, getWidth()-1, getHeight()-1);
  }

  public void move(){
    rightPaddle.setX(getWidth()-20); 
    if (ball!=null){
      if (ball.above(0) || ball.underneath(getHeight())){
        ball.reverseYDirection();
        ball.move();
      }

      if (ball.leftOf(0) ){
	ball=null;
	rightPoints=rightPoints+1;
	nextPlayer=RIGHT_PL;
      }

      else if (ball.rightOf(getWidth()) ){
	ball=null;
	leftPoints=leftPoints+1;
	nextPlayer=LEFT_PL;
      }

      else if (
         (    ball.rightOf(getWidth()-20) 
          &amp;&amp; ball.underneath(rightPaddle.getY())
	  &amp;&amp; ball.above(rightPaddle.getY()+rightPaddle.getHeight())
         )
         ||
         (    ball.leftOf(20) 
          &amp;&amp; ball.underneath(leftPaddle.getY())
	  &amp;&amp; ball.above(leftPaddle.getY()+leftPaddle.getHeight())
         )
        )
	ball.reverseXDirection();
    }

    paddles[0].move();
    paddles[1].move();
    if (ball!=null) ball.move();
    for (int i=0;i&lt;2;i++){
      if (paddles[i].getY()&lt;0) paddles[i].setY(0);
      if (paddles[i].getY()+paddles[i].getHeight()&gt;getHeight()) 
        paddles[i].setY(getHeight()-paddles[i].getHeight());
    }
  }  

  public void keyReleased(int keyCode) {
    int action = getGameAction(keyCode);
    switch (keyCode) {
      case KEY_NUM1:
        leftPaddle.setMoveY(-Math.abs(leftPaddle.getMoveY()));
	break;

      case KEY_NUM3:
        rightPaddle.setMoveY(-Math.abs(rightPaddle.getMoveY()));
	break;
    }
  }

  public void keyPressed(int keyCode) {
    int action = getGameAction(keyCode);
    switch (keyCode) {
      case KEY_NUM1:
        leftPaddle.setMoveY(Math.abs(leftPaddle.getMoveY()));
	break;
      case KEY_NUM3:
        rightPaddle.setMoveY(Math.abs(rightPaddle.getMoveY()));
	break;
      case KEY_NUM0:
        if (ball==null){
          switch (nextPlayer){
            case RIGHT_PL: 
      	      ball=new MBall(getWidth()-32,rightPaddle.getY()+10);
              ball.setMoveX(-ball.getMoveX());
              break;
            case LEFT_PL: 
              ball=new MBall(22,leftPaddle.getY()+10);
              break;
	    }
        }
	break;
    }
  }

  void destroy() {}

  boolean isPaused() {return paused;}
  void pause() {paused = true;}

  void start() {
    paused = false;
    display.setCurrent(this);
    new Thread(this).start();
  }
}</code><code bootclasspath = "wtk"
              lang = "java"
              class = "MobilePong"
              package = "name/panitz/mobile/pong">
package name.panitz.mobile.pong;

import javax.microedition.midlet.*;
import javax.microedition.lcdui.*;

public class MobilePong extends MIDlet implements CommandListener {
  final Display display = Display.getDisplay(this);
  final PongCanvas canvas = new PongCanvas(display);

  private final Command exitCommand
    = new Command(&quot;Exit&quot;, Command.EXIT, 99);
  private final Command toggleCommand
    = new Command(&quot;Stop/Go&quot;, Command.SCREEN, 1);
  private final Command helpCommand 
    = new Command(&quot;Help&quot;, Command.HELP, 2);
  private final Command aboutCommand
    = new Command(&quot;About&quot;, Command.HELP, 30);

  private final Form helpScreen = new Form(&quot;Pong Help&quot;);;
  private final String helpText
    = &quot;0 = new ball\n1 = left paddle\n3 = right paddle&quot;;

  public  MobilePong() {
    canvas.addCommand(exitCommand);
    canvas.addCommand(toggleCommand);
    canvas.addCommand(helpCommand);
    canvas.addCommand(aboutCommand);
    canvas.setCommandListener(this);

    helpScreen.append(&quot;0 = new ball\n&quot;);
    helpScreen.append(&quot;1 = move left paddle up/down\n&quot;);
    helpScreen.append(&quot;3 = move right paddle up/down\n&quot;);
  }

  public void startApp() throws MIDletStateChangeException {
    canvas.start();
  }
    
  public void pauseApp() {canvas.pause();}

  public void destroyApp(boolean unconditional) 
      throws MIDletStateChangeException {
    canvas.destroy();
  }

  public void commandAction(Command c, Displayable s) {
    final boolean wasPaused = canvas.isPaused();
    canvas.pause();
    if (c == toggleCommand) {if (wasPaused)canvas.start();}
    else if (c == helpCommand) showHelp();
    else if (c == exitCommand) {
      try {
	destroyApp(false);
	notifyDestroyed();
      } catch (MIDletStateChangeException ex) {}
    } else if (c == aboutCommand) About.showAbout(display);
  }

  void showHelp() {
    helpScreen.addCommand(toggleCommand);
    helpScreen.setCommandListener(this);
    display.setCurrent(helpScreen);
  }
}</code><code bootclasspath = "wtk"
              lang = "java"
              class = "About"
              package = "name/panitz/mobile/pong">
package name.panitz.mobile.pong;
import javax.microedition.lcdui.*;

public class About {
  private static final String copyright
    = &quot;Copyright (c) 2005 Sven Eric Panitz. All rights reserved.&quot;;

  public static void showAbout(Display display) {
    Alert alert = new Alert(&quot;About MIDP&quot;);
    alert.setTimeout(Alert.FOREVER);

    if (display.numColors() &gt; 2) {
      String icon = (display.isColor())
                    ?&quot;/icons/JavaPowered-8.png&quot; 
                    : &quot;/icons/JavaPowered-2.png&quot;;
      try {
	Image image = Image.createImage(icon);
	alert.setImage(image);
      } catch (java.io.IOException x) {}
    }
    alert.setString(copyright);
    display.setCurrent(alert);
  }
}</code><midlet name = "Pong"
                source = "name/panitz/mobile/pong/* name/panitz/games/AMovable.java name/panitz/games/ASimpleMovable.java"
                class = "name.panitz.mobile.pong.MobilePong"/></subsection></section>
  </kapitel>
  <include uri = "../webapp/skript.xml"/>
  <kapitel titel = "Scala, das Java der Zukunft?"/>
  <anhang>
    <kapitel titel = "Javawerkzeuge">
      <section titel = "Klassenpfad und Java-Archive">
Bisher haben wir Javaklassen einzeln übersetzt und
jeweils pro Klasse eine Datei <tt>.class</tt> erhalten.
Ein Javaprogramm
als solches läßt sich damit gar nicht genau eingrenzen. Ein
Javaprogramm ist eine Klasse mit einer Hauptmethode zusammen mit der
Menge aller Klassen, die von der Hauptmethode zur Ausführung benötigt 
werden. Selbst Klassen, die zwar im gleichen Paket wie die
Hauptklasse mit der Hauptmethode liegen, werden nicht unbedingt vom
Programm benötigt und daher auch nicht geladen. Ein Programm liegt
also in vielen verschiedenen Dateien verteilt. Das kann unhandlich
werden, wenn wir unser Programm anderen Benutzern bereitstellen
wollen. Wir wollen wohl kaum mehrere hundert Dateien auf einen Server
legen, die ein potentieller Kunde dann herunterlädt. <p/>
Aus diesem Grunde bietet Java eine Möglichkeit an, die Klassen eines
Programms oder einer Bibliothek zusammen in einer Datei zu
bündeln. Hierzu gibt es <tt>.jar</tt>-Dateien. <tt>Jar</tt> steht 
für <em>Java archive</em>. Die Struktur und Benutzung 
der <tt>.jar</tt>-Dateien leitet sich von den seit alters her in Unix
bekannten <tt>.tar</tt>-Dateien ab,  wobei <tt>tar</tt> für <em>tape archive</em> steht und ursprünglich dazu gedacht war,  Dateien gemeinsam auf einen Tonband-Datenträger
abzuspeichern. <p/>

In einem Javaarchiv können nicht nur Klassendateien gespeichert
werden, sondern auch Bilder und Sounddateien, die das Programm benötigt, und zusätzlich Versionsinformationen.<subsection titel = "Benutzung von jar-Dateien"><tt>jar</tt> ist zunächst einmal ein Programm zum Verpacken von
Dateien und Ordnern in eine gemeinsame Datei, ähnlich wie es auch das
Programm <tt>zip</tt> macht. Das Programm <tt>jar</tt> wird in einer Javainstallation mitgeliefert und kann von der Kommandozeile
gestartet werden. Ein Aufruf ohne Argumente führt zu einer Hilfemeldung:<scode>sep@swe10:~/fh/prog2&gt; jar
Syntax: jar {ctxu}[vfm0Mi] [JAR-Datei] [Manifest-Datei] [-C dir] Dateien ...
Optionen:
    -c  neues Archiv erstellen
    -t  Inhaltsverzeichnis für Archiv auflisten
    -x  benannte (oder alle) Dateien aus dem Archiv extrahieren
    -u  vorhandenes Archiv aktualisieren
    -v  ausführliche Ausgabe für Standardausgabe generieren
    -f  Namen der Archivdatei angeben
    -m  Manifestinformationen aus angegebener Manifest-Datei einbeziehen
    -0  nur speichern; keine ZIP-Komprimierung verwenden
    -M  keine Manifest-Datei für die Einträge erstellen
    -i  Indexinformationen für die angegebenen JAR-Dateien generieren
    -C  ins angegebene Verzeichnis wechseln und folgende Datei einbeziehen
Falls eine Datei ein Verzeichnis ist, wird sie rekursiv verarbeitet.
Der Name der Manifest-Datei und der Name der Archivdatei müssen
in der gleichen Reihenfolge wie die Flags &#39;&#39;m&#39;&#39; und &#39;&#39;f&#39;&#39; angegeben werden.

Beispiel 1: Archivieren von zwei Klassendateien in einem Archiv 
mit dem Namen classes.jar:
       jar cvf classes.jar Foo.class Bar.class
Beispiel 2: Verwenden der vorhandenen Manifest-Datei &#39;&#39;meinmanifest&#39;&#39; 
und Archivieren aller
           Dateien im Verzeichnis foo/ in &#39;&#39;classes.jar&#39;&#39;:
       jar cvfm classes.jar meinmanifest -C foo/ .

sep@swe10:~/fh/prog2&gt;</scode>
Wie man sieht, gibt es eine Reihe von Optionen, um 
mit <tt>jar</tt> die Dateien zu erzeugen, ihren Inhalt anzuzeigen oder
sie wieder auszupacken.<subsubsection titel = "Erzeugen von Jar-Dateien">
Das Kommando zum Erzeugen einer Jar-Datei hat folgende Form:<quote>
              <tt>jar cf jar-file input-file(s)</tt>
            </quote>
Die Befehlsoptionen im einzelnen:<itemize><item>Das <tt>c</tt> steht dafür, das eine Jar-Datei erzeugt werden
soll.</item><item>Das <tt>f</tt> steht dafür, daß der Dateiname der zu erzeugenden
Jar-Datei folgt.</item> <item><tt>jar-file</tt> ist der Name, den die zu erzeugende Datei haben soll. Hier nimmt man üblicherweise die Erweiterung <tt>.jar</tt> für den 
Dateinamen.</item><item><tt>input-file(s)</tt> ist eine Liste beliebiger Dateien und Ordner. Hier kann auch die aus der Kommandozeile
bekannte <tt>*</tt>-Notation  benutzt werden. </item></itemize><example>Der Befehl<quote>
                <tt>jar cf myProg.jar *.class</tt>
              </quote>
verpackt alle Dateien mit der Erweiterung <tt>.class</tt> in 
eine <tt>Jar</tt>-Datei namens <tt>myProg.jar</tt>.</example></subsubsection><subsubsection titel = "Anzeige des Inhalts einer Jar-Datei">
Das Kommando zur Anzeige der in einer Jar-Datei gespeicherten Dateien 
hat folgende Form:<quote>
              <tt>jar tf jar-file</tt>
            </quote>
Die Befehlsoptionen im einzelnen:<itemize> <item>Das <tt>t</tt> steht dafür, das eine Auflistung der enthaltenen
Dateien angezeigt werden<footnote><ttt>t</ttt> steht dabei 
für <em>table</em>.</footnote>
soll.</item><item>Das <tt>f</tt> steht dafür, daß der Dateiname der benötigten 
Jar-Datei folgt.</item> <item><tt>jar-file</tt> ist der Name der existierenden Jar-Datei.</item></itemize></subsubsection><subsubsection titel = "Extrahieren des Inhalts der Jar-Datei"> Der Befehl zum Extrahieren des Inhalts einer Jar-Datei hat folgende
schematische Form:<quote>
              <ttt>jar xf jar-file [archived-file(s)]</ttt>
            </quote>

Die Befehlsoptionen im einzelnen:<itemize> <item>Die <tt>x</tt>-Option gibt an, daß Dateien aus einer Jar-Datei
extrahiert werden sollen. </item> <item>Das <tt>f</tt> gibt wieder an, daß der Name einer JAR-Datei folgt.</item> <item><tt>jar-file</tt> ist der Name einer Jar-Datei, aus der die
entsprechenden Dateien zu extrahieren sind.</item><item>Optional kann noch eine Liste von Dateinamen folgen, die angibt,
welche Dateien extrahiert werden sollen. Wird diese Liste weggelassen,
so werden alle Dateien extrahiert.</item></itemize> Bei der Extraktion der Dateien werden die Dateien in dem aktuellen Verzeichnis der Kommandozeile gespeichert. Hierbei wird die originale
Ordnerstruktur der Dateien verwendet, sprich Unterordner, wie sie in der Jar-Datei verpackt wurden, werden auch als solche Unterordner
wieder ausgepackt.</subsubsection><subsubsection titel = "Ändern einer Jar Datei">
Schließlich gibt es eine Option, die es erlaubt, eine bestehende Jar-Datei in ihrem Inhalt zu verändern. Der entsprechende Befehl hat
folgendes Format:<quote>
              <tt>jar uf jar-file input-file(s)</tt>
            </quote>

Die Befehlsoptionen im einzelnen:<itemize> <item>Die Option <tt>u</tt> gibt an, daß eine bestehende Jar-Datei
geändert werden soll.</item> <item>Das <tt>f</tt> gibt wie üblich an, daß der Name einer Jar-Datei folgt.</item> <item>Eine Liste von Dateinamen gibt an, daß diese zur Jar-Datei
hinzuzufügen sind.</item></itemize> Dateien, die bereits in der Jar-Datei enthalten sind, werden durch diesen
Befehl mit der neuen Version überschrieben.</subsubsection></subsection><subsection titel = "Der Klassenpfad"> Jar-Dateien sind nicht nur dazu gedacht, daß damit Javaanwendungen
einfacher ausgetauscht werden können, sondern der Javainterpreter kann Klassen direkt aus der Jar-Datei starten. Eine Jar-Datei braucht also
nicht ausgepackt zu werden, um eine Klasse darin auszuführen. Es ist
dem Javainterpreter lediglich mitzuteilen, daß er auch in einer Jar-Datei nach den entsprechenden Klassen  suchen soll.<subsubsection titel = "Angabe des Klassenpfades als Option">
Der Javainterpreter hat eine Option, mit der ihm angegeben werden
kann, wo er die Klassen suchen soll, die er zur Ausführung der
Anwendung benötigt. Die entsprechende Option des Javainterpreters
heißt <tt>-cp</tt> oder auch <tt>-classpath</tt>, wie die 
Hilfmeldung des Javainterpreters auch
angibt:<scode>sep@swe10:~/fh/prog2&gt; java -help -cp
Usage: java [-options] class [args...]
           (to execute a class)
   or  java -jar [-options] jarfile [args...]
           (to execute a jar file)

where options include:

    -cp -classpath &lt;directories and zip/jar files separated by :&gt;
                  set search path for application classes and resources
</scode> Es läßt sich nicht nur eine Jar-Datei für den Klassenpfad angeben, sondern mehrere, und darüber hinaus auch Ordner im Dateisystem, in denen sich die  Paketstruktur der Javaanwendung bis hin zu deren Klassendateien befindet.
Die verschiedenen Einträge des Klassenpfades werden bei der Suche
einer Klasse von vorne nach hinten benutzt, bis die Klasse im
Dateisystem oder in einer Jar-Datei gefunden wurde. Die verschiedenen
Einträge des Klassenpfades werden durch einen Doppelpunkt getrennt.</subsubsection><subsubsection titel = "Angabe des Klassenpfades als Umgebungsvariable"> Implizit existiert immer ein Klassenpfad in Ihrem Betriebssystem als
eine sogenannte Umgebungsvariable. Sie können den Wert dieser
Umgebungsvariable abfragen und ändern. Die Umgebungsvariable, die Java benutzt, um den Klassenpfad zu speichern, 
heißt <tt>CLASSPATH</tt>. Deren Wert benutzt Java, wenn kein Klassenpfad per
Option angegeben wird.<p/>

Windows und Unix unterscheiden sich leicht in der Benutzung von
Umgebungsvariablen. In Unix wird der Wert einer Umgebungsvariable durch ein vorangestelltes Dollarzeichen bezeichnet, also <tt>$CLASSPATH</tt>, in
Windows wird sie durch Prozentzeichen eingeschlossen also, <tt>%CLASSPATH%</tt>.<paragraph titel = "Abfrage des Klassenpfades">
In der Kommandozeile kann man sich über den aktuellen Wert einer 
Umgebungsvariablen informieren.<paragraph titel = "Unix">
In Unix geschieht dieses leicht mit Hilfe des 
Befehls <tt>echo</tt>, dem die Variable in der Dollarnotation folgt: <scode>sep@swe10:~/fh/prog2&gt; echo $CLASSPATH
.:/home/sep/jarfiles/log4j-1.2.8.jar:/home/sep/jarfiles:
sep@swe10:~/fh/prog2&gt;
</scode></paragraph><paragraph titel = "Windows">
In Windows hingegen benutzt man den Konsolenbefehl <tt>set</tt>, dem
der Name der Umgebungsvariablen folgt.<p/><tt>set CLASSPATH</tt></paragraph></paragraph><paragraph titel = "Setzen des Klassenpfades">
Innerhalb einer Eingabeaufforderung kann für diese Eingabeaufforderung
der Wert einer Umgebungsvariablen geändert werden. Auch hierin
unterscheiden sich Unix und Windows marginal:<paragraph titel = "Unix"> <example>Wir fügen dem Klassenpfad eine weitere Jar-Datei an ihrem
Beginn an:<scode>sep@swe10:~/fh/prog2&gt; export CLASSPATH=~/jarfiles/jugs.jar:$CLASSPATH
sep@swe10:~/fh/prog2&gt; echo $CLASSPATH
/home/sep/jarfiles/jugs.jar:.:/home/sep/jarfiles/log4j-1.2.8.jar:/home/sep/jarfiles:</scode></example></paragraph><paragraph titel = "Windows"> In Windows werden Umgebungsvariablen auch mit dem <tt>set</tt>-Befehl geändert. Hierbei folgt dem Umgebungsvariablennamen mit einem
Gleichheitszeichen getrennt der neue Wert.<example>
Der entsprechende Befehl des letzten Beispiels ist in Windows:<br/><tt>set CLASSPATH=~\jarfiles\jugs.jar:%CLASSPATH%</tt></example></paragraph></paragraph> </subsubsection></subsection></section>
      <section titel = "APT"/>
      <section titel = "Applets testen mit: appletviewer"/>
      <section titel = "native2ascii"/>
      <section titel = "Klassendateien analysieren mit javap"/>
      <section titel = "Parsergeneratoren">
        <subsection titel = "javacc"/>
        <subsection titel = "antlr"/>
      </section>
    </kapitel>
    <kapitel titel = "Jugs: Java interpetiert"/>
    <kapitel titel = "Generierung von Klassen für XML DTDs">
      <section titel = "Introduction">
Parsers are a well understood concept. Usually a parser is used to 
read some text
according to a context free grammar. It is tested if the text can be produced
with the rules given in the grammar.  In case of success a result tree is
constructed. Different strategies for parsing  can be applied. Usually a
parser generator program is used. A textual representation of the grammar 
controls the generation of the parser. In functional programming languages
parsers can  easily be hand coded by way of 
parser cominators<cite label = "hutton-meijer:96"/>. 
We will show,
how to apply the concept of parser combinators to XML document type decriptions
in Java.<subsection titel = "Functional Programming">
The main building block in functional programming is a function
definition. Functions are first class citizens. They can be passed as argument
to other functions, whithout being wrapped within some data object. Functions
which take other function as argument are said to be 
of <em>higher order</em>. A
function that creates a new result function from different argument functions
is called a <em>combintor</em>.<subsubsection titel = "Parser Combinators">
A parser is basically a function. It consumes a token stream and results a
list of several parse results. An empty list result can be interpreted as, no
successfull parse<cite label = "wadler:85"/>. <p/>

The following type definition characterizes a parser in Haskell.<code lang = "hs"
                  class = "HsParse"
                  main = "main">type Parser result token = [token] -&gt; [(result,[token])]</code>
The type <tt>Parser</tt> is generic over the type of the token and the type of
a result. A parser is a function. The result is a pair: the first element of
the pair is the result of the parse, the second element is the list of the
remaining token (the parser will have consumed some tokens from the token
list). <p/>
In functional programming languages a parser can be written by way of
combinators. A parser consists of several basic parsers which are combined to
a more complex parser.  Simple parsers test if a certain token is the next
token in the token stream.<p/>

The basic parsers, which tests exactely for one token, can in Haskell be
written as: <code lang = "hs"
                  class = "HsParse"
                  sequel = "true"
                  main = "main">getToken tok [] = []
getToken tok (x:xs)
  |tok==x = [(x,xs)]
  |otherwise = []</code>

There are two fundamental ways to combine parsers to more complex parser:<itemize>
              <item>the sequence of two parsers.</item>
              <item>the alternativ of two parsers.</item>
            </itemize>

In functional programming languages combinator functions can be written, to
implement these two ways to construct more complex parsers.<p/>

In the alternativ combination of two parser, first the first parser is applied
to the token stream. Only if this does not succeed, 
the second parser is applied to the token stream.<p/>

In Haskell this parser can be implemented as:<code lang = "hs"
                  class = "HsParse"
                  sequel = "true"
                  main = "main">alt p1 p2 toks 
  |null res1 = p2 toks
  |otherwise = res1
 where
  res1 = p1 toks</code>

In the sequence combination of two parsers, first the first parser is applied
to the token stream and then the second parser is applied to the next token
stream of the results of the first parse.<p/>

In Haskell this parser can be implemented as:<code lang = "hs"
                  class = "HsParse"
                  sequel = "true"
                  main = "main">seqP p1 p2 toks = concat
  [[((rs1,rs2),tks2) |(rs2,tks2)&lt;-(p2 tks1) ] 
  |(rs1,tks1)&lt;-p1 toks]</code>

The result of a sequence of two parser is the pair of the two partial
parses. Quite often a joint result is needed. A further function can be
provided to apply some function to a parse result in order to get a new
result:<code lang = "hs"
                  class = "HsParse"
                  sequel = "true"
                  main = "main">mapP f p toks = [(f rs,tks)|(rs,tks)&lt;-p toks]</code>

With these three combinators basically all kinds of parsers can be defined.<example>
A very simple parser implementation in Haskell:<code lang = "hs"
                    class = "HsParse"
                    sequel = "true"
                    main = "main">parantheses = mapP (\((x1,x2),x3) -&gt; x2)
     (getToken &#39;(&#39; `seqP` a `seqP` getToken &#39;)&#39;)

a = getToken &#39;a&#39; `alt` parantheses

main = do 
  print (parantheses &quot;((((a))))&quot;)
  print (parantheses &quot;((((a)))&quot;)
  print (parantheses &quot;((((a))))bc&quot;)</code>

The program has the following output:<scode>sep@linux:~/fh/xmlparslib/examples&gt; src/HsParse
[(&#39;a&#39;,&quot;&quot;)]
[]
[(&#39;a&#39;,&quot;bc&quot;)]
sep@linux:~/fh/xmlparslib/examples&gt;</scode>
In the first call the string could complete be parsed, in the second call the
parser failed and in the third call the parser succeeded but two further
tokens where not consumed by the parser.</example>


Further parser combinators can be expressed with the two combinators
above. Typical combinators define the repetitive application of a parser,
which is expressed by the symbols <tt>+</tt> and <tt>*</tt> in the extended
Backus-Naur-form<cite label = "naur60"/>.</subsubsection></subsection><subsection titel = "XML">
XML documents are tree like structured documents. Common parser libraries are
available to parse the textual representation of an XML document and to build
the tree structure. In object orientated languages a common modell for the
resulting tree structure is used, the <em>distributed 
object modell (DOM)</em><cite label = "dom"/>.<subsubsection titel = "Document Type Definition">
The document type of an XML document describes, which tags can be used within
the document and which children these elements are allowed to have.
The document type defiition (DTD) in XML is very similar to a context free
grammar. <footnote>Throughout this paper we will ignore 
XML attributes.</footnote> A DTD describes
what kind of children elements  a certain element can have in a document. In a
DTD we find the typical elements of  grammars:<itemize>
              <item>sequences of elements, denoted by a comma <tt>,</tt>.</item>
              <item>alternatives of elements donoted by the vertical bar <ttt>|</ttt>.</item>
              <item>several kinds of repetition denoted by <tt>+</tt>, <tt>*</tt> and <tt>?</tt>.</item>
            </itemize>

Consider the following DTD, which we will use as example throughout this
paper: <code lang = "dtd"
                  class = "album"
                  package = "name/panitz/album"
                  commandchars = "_~^">&lt;!DOCTYPE musiccollection SYSTEM &quot;musiccollection.dtd&quot; [
  &lt;!ELEMENT musiccollection (lp|cd|mc)*&gt;  
  &lt;!ELEMENT lp (title,artist,recordingyear?,track+,note*)&gt;  
  &lt;!ELEMENT cd (title,artist,recordingyear?,track+,note*)&gt;  
  &lt;!ELEMENT mc (title,artist,recordingyear?,track+,note*)&gt;  
  &lt;!ELEMENT track (title,timing?)&gt;  
  &lt;!ELEMENT note (#PCDATA|author)*&gt;

  &lt;!ELEMENT timing (#PCDATA)&gt;  
  &lt;!ELEMENT title (#PCDATA)&gt;  
  &lt;!ELEMENT artist (#PCDATA)&gt;  
  &lt;!ELEMENT author (#PCDATA)&gt;  
  &lt;!ELEMENT recordingyear (#PCDATA)&gt;  
]&gt;</code>

The following XML document is build according to the structure defined in this
DTD. <code lang = "xml"
                  class = "mymusic"
                  commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;musiccollection&gt;
  &lt;lp&gt;
    &lt;title&gt;White Album&lt;/title&gt;
    &lt;artist&gt;The Beatles&lt;/artist&gt;
    &lt;recordingyear&gt;1968&lt;/recordingyear&gt;
    &lt;track&gt;&lt;title&gt;Revolution 9&lt;/title&gt;&lt;/track&gt;
    &lt;note&gt;&lt;author&gt;sep&lt;/author&gt;my first lp&lt;/note&gt;
  &lt;/lp&gt;
  &lt;cd&gt;
    &lt;title&gt;Open All Night&lt;/title&gt;
    &lt;artist&gt;Marc Almond&lt;/artist&gt;
    &lt;track&gt;&lt;title&gt;Tragedy&lt;/title&gt;&lt;/track&gt;
    &lt;note&gt;
     &lt;author&gt;sep&lt;/author&gt;
     Marc sung tainted love in the bandSoft Cell&lt;/note&gt;
  &lt;/cd&gt;
&lt;/musiccollection&gt;</code>

Another much simpler example is the following document:<code lang = "xml"
                  class = "simple"
                  commandchars = "_~^">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
&lt;musiccollection/&gt;</code>

As can be seen, DTDs are very similar to grammars. And in fact, the same
techniques can be applied for DTDs as for grammars. 
In <cite label = "HaXML"/> a Haskell combinator library for DTDs is
presented. In the next sections we will try to apply these techniques in
Java. </subsubsection></subsection><subsection titel = "Java">
In Java the main building block is a class, which defines a set of objects. A
class can contain methods. These methods can represent functions. It is
therefore natural to represent a Parser type by way of some class and the
different parser combinators by way of subclasses in Java.<subsubsection titel = "Generic Types">
As we have seen in functional programming, parser combinators make heavily use
of generic types. Fortunatly with release 1.5 of Java generic types are part
of Java&#39;s type system. This makes the application of parser combinator
techniques in Java tracktable.</subsubsection></subsection></section>
      <section titel = "Tree Parser">
As we have seen a DTD is very similar to a grammar. The main difference is,
that a grammar describes the way tokens are allowed in a token stream, whereas
a DTD describes which elements can occur in a tree structure. Therefore a
parser which we write for a DTD will not try to test, if a token stream can be
build with the rules, but if a certain tree structure can be build with the
rules in the DTD. What we get is a parser, which takes a tree and not a stream
as input.<subsection titel = "Parser Type">
We will now define classes to represent parsers over XML trees in Java. <p/>

First of all, we need some class to represent the result of a parse. In the
Haskell application above we used a pair for the result of a parse. The first
element of the pair represented the actual result data constructed, the second
element the remaining token stream. In our case, we want to parse over XML
trees. Therefore the token List will be a list of XML nodes as defined in
DOM. We use the utility class <tt>Tuple2</tt> as defined 
in <cite label = "java15"/> to represent pairs.<p/><code class = "Tuple1"
                package = "name/panitz/crempel/util"
                lang = "java">package name.panitz.crempel.util;

public class Tuple1&lt;t1&gt; {
  public t1 e1;
  public Tuple1(t1 a1){e1=a1;}
  String parenthes(Object o){return &quot;(&quot;+o+&quot;)&quot;;}
  String simpleToString(){return e1.toString();}
  public String toString(){return parenthes(simpleToString());}
  public boolean equals(Object other){
    if (! (other instanceof Tuple1)) return false;
    return e1.equals(((Tuple1)other).e1);
  }
}</code><code class = "Tuple2"
                package = "name/panitz/crempel/util"
                lang = "java">package name.panitz.crempel.util;

public class Tuple2&lt;t1,t2&gt; extends Tuple1&lt;t1&gt;{
  public t2 e2;
  public Tuple2(t1 a1,t2 a2){super(a1);e2=a2;}
  String simpleToString(){
    return super.simpleToString()+&quot;,&quot;+e2.toString();}
  public boolean equals(Object other){
    if (! (other instanceof Tuple2)) return false;
    return super.equals(other)&amp;&amp; e2.equals(((Tuple2)other).e2);
  }
}</code><code class = "Tuple3"
                package = "name/panitz/crempel/util"
                lang = "java">package name.panitz.crempel.util;

public class Tuple3&lt;t1,t2,t3&gt; extends Tuple2&lt;t1,t2&gt;{
  public t3 e3;
  public Tuple3(t1 a1,t2 a2,t3 a3){super(a1,a2);e3=a3;}
  String simpleToString(){
    return super.simpleToString()+&quot;,&quot;+e3.toString();}
  public boolean equals(Object other){
    if (! (other instanceof Tuple3)) return false;
    return super.equals(other)&amp;&amp; e3.equals(((Tuple3)other).e3);
  }
}</code><code class = "Function1"
                lang = "java"
                package = "name/panitz/crempel/util">package name.panitz.crempel.util;

public interface Function1&lt;arg,result&gt;{result eval(arg a);}</code><code class = "Visitor"
                lang = "java"
                package = "name/panitz/crempel/util">package name.panitz.crempel.util;

public interface Visitor&lt;arg,result&gt; 
                      extends Function1&lt;arg,result&gt;{
}</code>





The following class represents the result of a parse.<code class = "ParseResult"
                package = "name/panitz/crempel/util/xml/parslib"
                lang = "java">package name.panitz.crempel.util.xml.parslib;

import name.panitz.crempel.util.Tuple2;
import java.util.List;
import org.w3c.dom.Node;

public class ParseResult&lt;a&gt; extends Tuple2&lt;a,List&lt;Node&gt;&gt;{
  public ParseResult(a n,List&lt;Node&gt; xs){super(n,xs);}

  public boolean failed(){return false;}
}</code>

This class is generic over the actual result type. We added a method for
testing, whether the parse was successful. <p/>

We define a special subclass for parse results, which denotes unsuccessful
parses. <code class = "Fail"
                package = "name/panitz/crempel/util/xml/parslib"
                lang = "java">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import org.w3c.dom.Node;

public class Fail&lt;a&gt; extends ParseResult&lt;a&gt;{
  public Fail(List&lt;Node&gt; xs){super(null,xs);}
  public boolean failed(){return true;}
}</code>

Now where we have defined what a parse result looks like, we can define a
class to describe a parser. A parser is some object, which has a 
method <tt>parse</tt>. This maethod takes a list of DOM nodes as argument and
returns a parse result:<code class = "Parser"
                package = "name/panitz/crempel/util/xml/parslib"
                lang = "java">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.Node;
import name.panitz.crempel.util.Maybe;
import name.panitz.crempel.util.Tuple2;
import name.panitz.crempel.util.Function1;

public interface  Parser&lt;a&gt;{
  public ParseResult&lt;a&gt; parse(List&lt;Node&gt; xs);</code></subsection><subsection titel = "Combinators">
Now, where we have a parser class, we would like to add combinator function to
  this class. We add the following combinators:<itemize>
            <item><tt>seq</tt> to create a sequence of this parser with some other
  parser. </item>
            <item><tt>choice</tt> to create an alternative of this or some other parser. </item>
            <item><tt>star</tt> to create a zero or more repetition parser of this
  parser.</item>
            <item><tt>plus</tt> to create a one or more repetition parser of this
  parser.</item>
            <item><tt>query</tt> to create a zero or one repetition parser of this
  parser.</item>
            <item><tt>map</tt> to create a  parser from this parser, which modifies the
  parse result with some further method.</item>
          </itemize>


This leads to the following method signatures in the 
interface <tt>Parser</tt>:<code lang = "java"
                class = "Parser"
                package = "name/panitz/crempel/util/xml/parslib"
                sequel = "true">  public &lt;b&gt; Parser&lt;Tuple2&lt;a,b&gt;&gt; seq(Parser&lt;b&gt; p2);
  public &lt;b extends a&gt; Parser&lt;a&gt; choice(Parser&lt;b&gt; p2);
  public Parser&lt;List&lt;a&gt;&gt; star();
  public Parser&lt;List&lt;a&gt;&gt; plus();
  public Parser&lt;Maybe&lt;a&gt;&gt; query();
  public &lt;b&gt; Parser&lt;b&gt; map(Function1&lt;a,b&gt; f);
}</code>

The sequence
combinator creates a parser which has a pair of the two partial results as
common result. The alternative parser will only allow a second parser, which
has the same result type as this parser. This will lead to some complication
later. Results of repetitions of more than one time are represented as lists
of the partial results. For the optional repretition of zero or one time we
use the class <tt>Maybe</tt> as of <cite label = "java15"/> result 
type. It has two subclasses, <tt>Just</tt> to denote there is such a result
and <tt>Nothing</tt> to denote the contrary.<p/>

In the following we assume an abstract 
class <tt>AbstractParser</tt>, which implements these functions. We will give
the definition of <tt>AbstractParser</tt> later in this paper. <subsubsection titel = "Optional Parser">
Let us start with the parser which is optional as denoted by the question 
mark <ttt>?</ttt> in a DTD. We write a
class to represent this parser. This class contains a parser. In the 
method <tt>parse</tt>, this given parser is applied to the list of nodes. If
this fails a <tt>Nothing</tt> object is returned, otherwise 
a <tt>Just</tt> object, which wrappes the result of the successful parse, is
returned. <p/>

We get the following simple Java class:<code lang = "java"
                  class = "Optional"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import name.panitz.crempel.util.Maybe;
import name.panitz.crempel.util.Nothing;
import name.panitz.crempel.util.Just;
import org.w3c.dom.Node;

public  class Optional&lt;a&gt; extends  AbstractParser&lt;Maybe&lt;a&gt;&gt; {
  final Parser&lt;a&gt; p;
  public Optional(Parser&lt;a&gt; _p){p=_p;}
  public ParseResult&lt;Maybe&lt;a&gt;&gt; parse(List&lt;Node&gt; xs){
    final ParseResult&lt;a&gt; res = p.parse(xs);
    if (res.failed())
      return new ParseResult&lt;Maybe&lt;a&gt;&gt;(new Nothing&lt;a&gt;(),xs); 
    return new ParseResult&lt;Maybe&lt;a&gt;&gt;(new Just&lt;a&gt;(res.e1),res.e2);
  }
}</code></subsubsection><subsubsection titel = "Sequence">
Next we implement a Java class which represents the sequence of two
parsers. This class contains two inner parsers. The first one gets applied to
the list of nodes, in case of success, the second is applied to the remaining
list of the successful first parse.<p/>

We get the following simple Java class:<code lang = "java"
                  class = "Seq"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import name.panitz.crempel.util.Tuple2;
import org.w3c.dom.Node;

public  class Seq&lt;a,b&gt; extends  AbstractParser&lt;Tuple2&lt;a,b&gt;&gt; {
  final Parser&lt;a&gt; p1;
  final Parser&lt;b&gt; p2;

  public Seq(Parser&lt;a&gt; _p1,Parser&lt;b&gt; _p2){p1=_p1;p2=_p2;}

  public ParseResult&lt;Tuple2&lt;a,b&gt;&gt; parse(List&lt;Node&gt; xs){ 
    ParseResult&lt;a&gt; res1 = p1.parse(xs);
    if (res1.failed())
      return new Fail&lt;Tuple2&lt;a,b&gt;&gt;(xs);
    ParseResult&lt;b&gt; res2 = p2.parse(res1.e2);
    if (res2.failed())
      return new Fail&lt;Tuple2&lt;a,b&gt;&gt;(xs);
    return new ParseResult&lt;Tuple2&lt;a,b&gt;&gt;
                 (new Tuple2&lt;a,b&gt;(res1.e1,res2.e1),res2.e2);
  }
}</code></subsubsection><subsubsection titel = "Choice">
The alternative parser of parser can be defined in almost exactly the way as
has been done in the intrductory Haskell example. First the first parser ist
tried. If this succeeds its result is used, otherwise the second parser is
applied. However, we need to create new objects of 
classes <tt>ParseResult</tt> and <tt>Fail</tt>. This is due to the fact that
even if <tt>b extends c</tt>, <tt>ParseResult&lt;b&gt;</tt> does
not extend <tt>ParseResult&lt;c&gt;</tt>. <code lang = "java"
                  class = "Choice"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import java.util.ArrayList;
import name.panitz.crempel.util.Tuple2;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class  Choice&lt;c,a extends c,b extends c&gt; 
  extends  AbstractParser&lt;c&gt; {
  final Parser&lt;a&gt; p1;
  final Parser&lt;b&gt; p2;

  public Choice(Parser&lt;a&gt; _p1,Parser&lt;b&gt; _p2){p1=_p1;p2=_p2;}

  public ParseResult&lt;c&gt; parse(List&lt;Node&gt; xs){ 
    final ParseResult&lt;a&gt; res1 =  p1.parse(xs);
    if (res1.failed()){
      final ParseResult&lt;b&gt; res2 = p2.parse(xs);
      if (res2.failed()) return new Fail&lt;c&gt;(xs);
      return new  ParseResult&lt;c&gt;(res2.e1,res2.e2);
    }
    return new  ParseResult&lt;c&gt;(res1.e1,res1.e2);
  }
}</code></subsubsection><subsubsection titel = "Repetitions">
Reptetitive parsers try to apply a parser several times after another. We
define one common class for repetitive parses. Subclasses will differentiate
if at least one time the parser needs to be applied successfully.<code lang = "java"
                  class = "Repetition"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.Node;</code>
We need an parser to be applied in a repetition and a flag to signify, if the
parser needs to be applied sucessfulle at least one time: <code lang = "java"
                  class = "Repetition"
                  package = "name/panitz/crempel/util/xml/parslib"
                  sequel = "true">public  class Repetition&lt;a&gt; extends  AbstractParser&lt;List&lt;a&gt;&gt; {
  final Parser&lt;a&gt; p;
  final boolean atLeastOne;
  public Repetition(Parser&lt;a&gt; _p,boolean one){
    p=_p;atLeastOne=one;
  }</code>
Within the method <tt>parse</tt> the parser is applied is long as it does not
fail. The results of the parses are added to a common result list.<code lang = "java"
                  class = "Repetition"
                  package = "name/panitz/crempel/util/xml/parslib"
                  sequel = "true">  public ParseResult&lt;List&lt;a&gt;&gt; parse(List&lt;Node&gt; xs){
    final List&lt;a&gt; resultList = new ArrayList&lt;a&gt;();
    int i = 0;

    while (true){
      final ParseResult&lt;a&gt; res = p.parse(xs);
      xs=res.e2;

      if (res.failed()) break;
      resultList.add(res.e1);
    }

    if (resultList.isEmpty()&amp;&amp; atLeastOne) 
      return new Fail&lt;List&lt;a&gt;&gt;(xs);
    return new ParseResult&lt;List&lt;a&gt;&gt;(resultList,xs);
  }
}</code>

Simple subclasses can be defined for the two kinds of repetition in  a DTD.<code lang = "java"
                  class = "Star"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;

public class Star&lt;a&gt; extends Repetition&lt;a&gt; {
  public Star(Parser&lt;a&gt; p){super(p,false);}
}</code><code lang = "java"
                  class = "Plus"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;

public class Plus&lt;a&gt; extends Repetition&lt;a&gt; {
  public Plus(Parser&lt;a&gt; p){super(p,true);}
}</code></subsubsection><subsubsection titel = "Map">
Eventually we define the parser class for modifying the result of a parser. To
pass the function to be applied to the parser we use an object, which
implements the interface <tt>Function1</tt> from <cite label = "java15"/>.<p/>

The implementation is straight forward. Apply the parser and in case of
success create a new parse result object from the original parse result.<code lang = "java"
                  class = "Map"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import org.w3c.dom.Node;
import name.panitz.crempel.util.Function1;

public class Map&lt;a,b&gt; extends AbstractParser&lt;b&gt; {
  final Parser&lt;a&gt; p;
  final Function1&lt;a,b&gt; f;

  public Map(Function1&lt;a,b&gt; _f,Parser&lt;a&gt; _p){f=_f;p=_p;}

  public ParseResult&lt;b&gt; parse(List&lt;Node&gt; xs){
    final ParseResult&lt;a&gt; res = p.parse(xs);
    if (res.failed()) return new Fail&lt;b&gt;(xs);
    return new ParseResult&lt;b&gt;(f.eval(res.e1),res.e2); 
  }
}</code></subsubsection><subsubsection titel = "Abstract Parser Class">
Now where we have classes for all kinds of parser combinators, we can use
these in an abstract parser class, which implements the combinator methods of
the parser interface. We simply instantiate the corresponding parser classes. <code lang = "java"
                  class = "AbstractParser"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import name.panitz.crempel.util.Tuple2;
import name.panitz.crempel.util.Maybe;
import name.panitz.crempel.util.Function1;

public abstract class AbstractParser&lt;a&gt; implements Parser&lt;a&gt;{
  public &lt;b&gt; Parser&lt;Tuple2&lt;a,b&gt;&gt; seq(Parser&lt;b&gt; p2){
    return new Seq&lt;a,b&gt;(this,p2);
  }

  public &lt;b extends a&gt; Parser&lt;a&gt; choice(Parser&lt;b&gt; p2){
    return new Choice&lt;a,a,b&gt;(this,p2);
  }

  public Parser&lt;List&lt;a&gt;&gt; star(){return new Star&lt;a&gt;(this);}
  public Parser&lt;List&lt;a&gt;&gt; plus(){return new Plus&lt;a&gt;(this);}
  public Parser&lt;Maybe&lt;a&gt;&gt; query(){return new Optional&lt;a&gt;(this);}
  public &lt;b&gt; Parser&lt;b&gt; map(Function1&lt;a,b&gt; f){
    return new Map&lt;a,b&gt;(f,this);
  }
}</code>

Note that the method <tt>choice</tt> cannot be written as general as we would
like to. We cannot specify that we need one smallest common superclass of the
two result types. </subsubsection></subsection><subsection titel = "Atomic Parsers">
Now we are able to combine parsers to more complex parsers. We are still
missing the basic parser like the function <tt>getToken</tt> in our Haskell
parser above. In XML documents there are several different basic units:
PCDATA, Elements and Empty content.<subsubsection titel = "PCDATA">
The basic parser, which checks for a PCDATA node simply checks the node type
of the next node. If there is a next node of type text node, then the parser
succeeds and consumes the token. Otherwise it fails. We define this parser
with result type <tt>String</tt>. The resulting <tt>String</tt> will contain
the contents of the text node.<code lang = "java"
                  class = "PCData"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import org.w3c.dom.Node;

public class PCData extends AbstractParser&lt;String&gt; {

  public ParseResult&lt;String&gt; parse(List&lt;Node&gt; xs){
    if (xs.isEmpty()) return new Fail&lt;String&gt;(xs);
    final Node x = xs.get(0);
    if (x.getNodeType()==Node.TEXT_NODE)
      return new ParseResult&lt;String&gt;
                  (x.getNodeValue(),xs.subList(1,xs.size()));
System.out.println(&quot;expected pcdata but got: &quot;+x);
    return new Fail&lt;String&gt;(xs);
  }
}</code></subsubsection><subsubsection titel = "Empty">
A very simple parser, does always succeed with some result and does not
consume any node from the input.<code lang = "java"
                  class = "Return"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import org.w3c.dom.Node;

public class Return&lt;a&gt; extends AbstractParser&lt;a&gt; {
  final a returnValue;
  public Return(a r){returnValue=r;}
  public ParseResult&lt;a&gt; parse(List&lt;Node&gt; xs){
    return new ParseResult&lt;a&gt;(returnValue,xs);
  }
}</code></subsubsection><subsubsection titel = "Element">
The probably most interesting parser reads an element node and proceeds with
the children of the element node. The children of the element node are
processed with a given parser.<p/>

Therefore the element parser needs two arguments:<itemize>
              <item>the name of the element to be read.</item>
              <item>the parser to be applied to the children of the element.</item>
            </itemize><code class = "Closure"
                  package = "name/panitz/crempel/util"
                  lang = "java">package name.panitz.crempel.util;

public interface Closure&lt;result&gt;{
  public result eval();
}</code><code lang = "java"
                  class = "Element"
                  package = "name/panitz/crempel/util/xml/parslib">package name.panitz.crempel.util.xml.parslib;

import java.util.List;
import java.util.ArrayList;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import name.panitz.crempel.util.Closure;


public class Element&lt;a&gt; extends AbstractParser&lt;a&gt; {
  Parser&lt;a&gt; p=null;
  private final Closure&lt;Parser&lt;a&gt;&gt; pc;
  final String elementName;

  public Element(String n,Parser&lt;a&gt; _p){elementName=n;p=_p;pc=null;}
  public Element(String n,Closure&lt;Parser&lt;a&gt;&gt; _p){elementName=n;pc=_p;}

  public Parser&lt;a&gt; getP(){if (p==null) p=pc.eval(); return p;}</code>

For simplicity reasons, we will neglect text nodes from list of nodes, which
consist solely of whitespace:<code lang = "java"
                  sequel = "true"
                  class = "Element"
                  package = "name/panitz/crempel/util/xml/parslib">  public ParseResult&lt;a&gt; parse(List&lt;Node&gt; xs){
    if (xs.isEmpty()) {return new Fail&lt;a&gt;(xs);}
    Node x = xs.get(0);
    while (   x.getNodeType()==Node.TEXT_NODE
           &amp;&amp; x.getNodeValue().trim().length()==0
          ){
      xs=xs.subList(1,xs.size());
      if (xs.isEmpty()) return new Fail&lt;a&gt;(xs);  

      x = xs.get(0);
    }</code>
Then we compare the node name with the expected node name:<code lang = "java"
                  sequel = "true"
                  class = "Element"
                  package = "name/panitz/crempel/util/xml/parslib">    final String name = x.getNodeName();
System.out.println(name+&quot; &lt;-&gt; &quot;+elementName);
    if (!name.equals(elementName)) 
      return new Fail&lt;a&gt;(xs);</code>
Eventually we get the children of the node and apply the given parser to this
    list. <code lang = "java"
                  sequel = "true"
                  class = "Element"
                  package = "name/panitz/crempel/util/xml/parslib">    final List&lt;Node&gt; ys = nodelistToList(x.getChildNodes());
    ParseResult&lt;a&gt; res = getP().parse(ys);

    if( res.failed()) return new Fail&lt;a&gt;(xs); </code>
If this succeeds we ensure that only neglectable whitespace nodes follow in
the list of nodes<code lang = "java"
                  sequel = "true"
                  class = "Element"
                  package = "name/panitz/crempel/util/xml/parslib">    for (Node y :res.e2){
      if (y.getNodeType()!=Node.TEXT_NODE 
             || y.getNodeValue().trim().length()!=0)
         return new Fail&lt;a&gt;(xs);
    }</code>
Eventually the result can be constructed.<code lang = "java"
                  sequel = "true"
                  class = "Element"
                  package = "name/panitz/crempel/util/xml/parslib">    return new ParseResult&lt;a&gt;(res.e1,xs.subList(1,xs.size()));    
  }</code>
The following method has been used to convert DOM node list into a java list
of nodes.<code lang = "java"
                  sequel = "true"
                  class = "Element"
                  package = "name/panitz/crempel/util/xml/parslib">  static public List&lt;Node&gt; nodelistToList(NodeList xs){
    List&lt;Node&gt; result = new ArrayList&lt;Node&gt;();
    for (int i=0;i&lt;xs.getLength();i=i+1){
      result.add(xs.item(i));
    }
    return result;
  }
}</code></subsubsection></subsection><subsection titel = "Building parsers">
We have got everything now to implement parsers for a DTD in Java. <subsubsection titel = "Defining a Parser">
We can write a parser, which checks if a certain XML document is build
according to the type definition as defined for our music collection
example. As result for the parse we simply return 
some <tt>String</tt> object.<code lang = "java"
                  class = "MusiccollectionParser"
                  package = "name/panitz/crempel/test">package name.panitz.crempel.test;

import java.util.List;
import org.w3c.dom.Node;
import name.panitz.crempel.util.*;
import name.panitz.crempel.util.xml.parslib.*;

public class MusiccollectionParser extends AbstractParser&lt;String&gt;{</code>

First of all we define some objects of 
different <tt>Function1</tt> types, which are needed to construct the
final result of the parses. First an object for concatenating 
two <tt>String</tt> objects:<code lang = "java"
                  class = "MusiccollectionParser"
                  package = "name/panitz/crempel/test"
                  sequel = "true">  final private Function1&lt;Tuple2&lt;String,String&gt;,String&gt; concat
    = new Function1&lt;Tuple2&lt;String,String&gt;,String&gt;(){
         public String eval(Tuple2&lt;String,String&gt; p){
           return p.e1+p.e2;
         }
      };</code>
The second function retries a <tt>String</tt> object from 
a <tt>Maybe&lt;String&gt;</tt> object. <code lang = "java"
                  class = "MusiccollectionParser"
                  package = "name/panitz/crempel/test"
                  sequel = "true">  final private Function1&lt;Maybe&lt;String&gt;,String&gt; getString
    = new Function1&lt;Maybe&lt;String&gt;,String&gt;(){
         public String eval(Maybe&lt;String&gt; p){
           if (p instanceof Nothing) return &quot;&quot;;  
           return ((Just&lt;String&gt;)p).getJust();
         }
      };</code>
Eventually we provide a function object, which concatenates a list 
of <tt>String</tt> object into a single <tt>String</tt> object. <code lang = "java"
                  class = "MusiccollectionParser"
                  package = "name/panitz/crempel/test"
                  sequel = "true">  final private Function1&lt;List&lt;String&gt;,String&gt; concatList
    = new Function1&lt;List&lt;String&gt;,String&gt;(){
         public String eval(List&lt;String&gt; xs){
           final StringBuffer result = new StringBuffer();
           for (String x:xs) result.append(x);
           return result.toString();
         }
      };</code>
Now we can define parsers for the elements as defined in the dtd. The most
simple parsers are for those elements, which have only text nodes as children: <code lang = "java"
                  class = "MusiccollectionParser"
                  package = "name/panitz/crempel/test"
                  sequel = "true">  final private Parser&lt;String&gt; recordingyear
    = new Element&lt;String&gt;(&quot;recordingyear&quot;,new PCData());
  final private Parser&lt;String&gt; artist
    = new Element&lt;String&gt;(&quot;artist&quot;,new PCData());
  final private Parser&lt;String&gt; title
    = new Element&lt;String&gt;(&quot;title&quot;,new PCData());
  final private Parser&lt;String&gt; timing
    = new Element&lt;String&gt;(&quot;timing&quot;,new PCData());
  final private Parser&lt;String&gt; author
    = new Element&lt;String&gt;(&quot;author&quot;,new PCData());</code>

Parsers for the remaining elements are combined from these basic parsers.<code lang = "java"
                  class = "MusiccollectionParser"
                  package = "name/panitz/crempel/test"
                  sequel = "true">  final private Parser&lt;String&gt; note
    = new Element&lt;String&gt;
       (&quot;note&quot;,author.seq(new PCData()).map(concat));

  final private Parser&lt;String&gt; track
    = new Element&lt;String&gt;(&quot;track&quot;
        ,title.seq(timing.query().map(getString)).map(concat));
                    
  final private Parser&lt;String&gt; content
    =    title
        .seq(artist).map(concat)
        .seq(recordingyear.query().map(getString)).map(concat)
        .seq(track.plus().map(concatList)).map(concat)
        .seq(note.star().map(concatList)).map(concat);

  final private Parser&lt;String&gt; lp
    = new Element&lt;String&gt;(&quot;lp&quot;,content);
  final private Parser&lt;String&gt; cd
    = new Element&lt;String&gt;(&quot;cd&quot;,content);
  final private Parser&lt;String&gt; mc
    = new Element&lt;String&gt;(&quot;mc&quot;,content);

  final private Parser&lt;String&gt; musiccollection
   = new Element&lt;String&gt;
      (&quot;musiccollection&quot;,lp.choice(cd).choice(mc)
                           .star().map(concatList));

  public ParseResult&lt;String&gt; parse(List&lt;Node&gt; xs){
    return musiccollection.parse(xs);
  }
}</code></subsubsection><subsubsection titel = "Starting the parser">
We have a tree parser over XML documents of 
type <tt>musiccollection</tt>. This parser can be applied to a list of dom
objects: <code lang = "java"
                  class = "MainParser"
                  package = "name/panitz/crempel/test">package name.panitz.crempel.test;

import name.panitz.crempel.util.*;
import name.panitz.crempel.util.xml.parslib.*;

import org.w3c.dom.*;
import java.util.*;
import java.io.*;
import javax.xml.parsers.*;

public class MainParser{
  public static void main(String [] args){
    System.out.println(pFile(args[0],args[1]));
  }

  public static Object pFile(String parserClass,String fileName){
    try{
      DocumentBuilderFactory factory
        = DocumentBuilderFactory.newInstance();

      factory.setIgnoringElementContentWhitespace(true);
      factory.setCoalescing(true); 
      factory.setIgnoringComments(true);

      Document doc
	=factory.newDocumentBuilder()
	.parse(new File(fileName)) ;
      doc.normalize();
      List&lt;Node&gt; xs = new ArrayList&lt;Node&gt;();
      xs.add(doc.getChildNodes().item(0));
 
      Parser&lt;Object&gt; p
       = (Parser&lt;Object&gt;)Class.forName(parserClass).newInstance();
      
      Tuple2 res = p.parse(xs);

      return res.e1;
    }catch (Exception e){e.printStackTrace();return null;}
  }
}</code>

The parser checks the document for its structure and returns the text of the
document: <scode>sep@linux:~/fh/xmlparslib/examples&gt; java -classpath classes/  name.panitz.crempel.test.MainParser 
  name.panitz.crempel.test.MusiccollectionParser src/mymusic.xml
White AlbumThe Beatles1968Revolution 9sepmy first lpOpen All NightMarc AlmondTragedysepMarc sung tainted love
sep@linux:~/fh/xmlparslib/examples&gt;</scode></subsubsection></subsection></section>
      <section titel = "Building a Tree Structure">
In the last section we presented a library for writing tree parsers for a
certain DTD. The actual parser needed to be hand coded for the  given DTD. As
has been seen this was very tedious and boring mechanical hand coding, which
can be made automatically. As a matter of fact, a parser can easily be
generated, but for the result type of the parser. In this sections we will
develop a program that will generate tree classes for a DTD and a parser,
which has an object of these tree classes as result.<subsection titel = "Java types for DTDs"/><subsection titel = "An algebraic type for DTDs">
In this section we will make heavy use of the algebraic type framework as
presented in <cite label = "adt"/>. First of all we define an algebraic type to
represent a definition clause in a DTD (i.e. the right hand side of an element
definition). <p/>

In a DTD there exist the following building blocks:<itemize>
            <item>PCData</item>
            <item>some element name</item>
            <item>Any</item>
            <item>Empty</item>
            <item>one or more repetition</item>
            <item>zero or more repetition</item>
            <item>zero or one repetition</item>
            <item>a list of choices</item>
            <item>a list of sequence items</item>
          </itemize>

We can express this in the following algebraic type definition.<code class = "DTDDef"
                lang = "java"
                apt = "true"
                package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd.tree;
import name.panitz.adt.*;

public @Data class DTDDef {
  @Constr public void DTDPCData(){}
  @Constr public void DTDTagName(String tagName){}
  @Constr public void DTDAny(){}
  @Constr public void DTDEmpty(){}{}
  @Constr public void DTDPlus(DTDDef dtd){}
  @Constr public void DTDStar(DTDDef dtd){}
  @Constr public void DTDQuery(DTDDef dtd){}
  @Constr public void DTDSeq(java.util.List&lt;DTDDef&gt; seqParts){}
  @Constr public void DTDChoice(java.util.List&lt;DTDDef&gt; choiceParts){}
}</code>

For this algenbraic type definition we get generated a set of tree classes and
a visitor framework.<subsubsection titel = "Simple visitors vor DTDDef">
As a first exercise we write two simple visitor classes for the 
type <tt>DTDDef</tt>.<paragraph titel = "Show">
The first visitor returns a textual representation of 
the <tt>DTD</tt> object.<code lang = "java"
                    class = "DTDShow"
                    commandchars = "`~^"
                    package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import java.util.List;

public class DTDShow extends DTDDefVisitor&lt;String&gt;{
  public String show(DTDDef def){return ((DTDDefAdt)def).welcome(this);}

  public String visit(DTDPCData _){return &quot;#PCDATA&quot;;};
  public String visit(DTDTagName x){return x.tagName;}
  public String visit(DTDEmpty x){return &quot;Empty&quot;;}
  public String visit(DTDAny x){return &quot;Any&quot;;}
  public String visit(DTDPlus x){return show(x.dtd)+&quot;+&quot;;};
  public String visit(DTDStar x){return show(x.dtd)+&quot;*&quot;;};
  public String visit(DTDQuery x){return show(x.dtd)+&quot;?&quot;;};
  public String visit(DTDSeq s){
    return aux(this,&quot;,&quot;,s.seqParts);}
  public String visit(DTDChoice c){
    return aux(this,&quot;|&quot;,c.choiceParts);}

  private String aux
              (DTDShow visitor,String sep,List&lt;DTDDef&gt; parts){
    StringBuffer result=new StringBuffer(&quot;(&quot;);
    boolean first = true; for (DTDDef x:parts){
      if (first) first=false; else result.append(sep);
      result.append(show(x));
    }
    result.append(&quot;)&quot;);
    return result.toString();
  }
}</code></paragraph><paragraph titel = "ShowType">
Now we write a visitor, which returns in Java syntax the Java type, which we
associate to a certain DTD construct:<code lang = "java"
                    class = "ShowType"
                    package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.*;
import java.util.List;
import java.util.ArrayList;

public class ShowType extends DTDDefVisitor&lt;String&gt;{
  public String visit(DTDPCData x){return &quot;String&quot;;}
  public String visit(DTDTagName x){return x.tagName;}
  public String visit(DTDEmpty x){return &quot;Object&quot;;}
  public String visit(DTDAny x){return &quot;Object&quot;;}
  public String visit(DTDPlus x){return &quot;List&lt;&quot;+showType(x.dtd)+&quot;&gt;&quot;;}
  public String visit(DTDStar x){return &quot;List&lt;&quot;+showType(x.dtd)+&quot;&gt;&quot;;}
  public String visit(DTDQuery x){return &quot;Maybe&lt;&quot;+showType(x.dtd)+&quot;&gt;&quot;;}
  public String visit(DTDSeq x){
    return listAsType((List&lt;DTDDef&gt;) x.seqParts);}

  public String visit(DTDChoice x){
    List&lt;DTDDef&gt; parts = x.choiceParts;
    if (parts.size()==1) return showType(parts.get(0));
    StringBuffer result=new StringBuffer(&quot;Choice&quot;);
    for (DTDDef y:((List&lt;DTDDef&gt;) parts))
      result.append(&quot;_&quot;+typeToIdent(showType(y)));
    return result.toString();
  }

  private  String listAsType(List&lt;DTDDef&gt; xs){
    int size=xs.size();

    if (size==1) return showType(xs.get(0));
    StringBuffer result = new StringBuffer();
    for (Integer i:new FromTo(2,size)){
      result.append(&quot;Tuple2&lt;&quot;);
    }
    boolean first=true;
    for (DTDDef dtd:xs){
      if (!first) result.append(&quot;,&quot;);
      result.append(showType(dtd));
      if (!first) result.append(&quot;&gt;&quot;);
      first=false; 
    }
    return result.toString();       
  }

  public  String showType(DTDDef def){
    return ((DTDDefAdt)def).welcome(this);}

  public  static String sShowType(DTDDef def){
    return new ShowType().showType(def);}

  static public String typeToIdent(String s ){
    return s.replace(&#39;&lt;&#39;,&#39;_&#39;).replace(&#39;&gt;&#39;,&#39;_&#39;).replace(&#39;.&#39;,&#39;_&#39;);
  }
}</code></paragraph></subsubsection></subsection><subsection titel = "Generation of tree classes">
In this section we write a <code lang = "java"
                class = "GenerateADT"
                package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd;

//import name.panitz.crempel.util.adt.parser.ADT;
import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.*;
//import name.panitz.crempel.util.adt.*;
import java.util.List;
import java.util.ArrayList;
import java.io.Writer;
import java.io.StringReader;
import java.io.FileWriter;
import java.io.StringWriter;
import java.io.IOException;

public class GenerateADT extends DTDDefVisitor&lt;String&gt;{
  final String elementName;
  public GenerateADT(String e){elementName=e;}

  public String visit(DTDPCData x){
   return &quot;  public @Constr void Con(String pcdata){}&quot;;}
  public String visit(DTDTagName x){
    final String typeName = ShowType.sShowType(x);
    return &quot;  public @Constr void Con(&quot;+typeName+&quot; the&quot;+typeName+&quot;){}&quot;;}
  public String visit(DTDEmpty x){return &quot;&quot;;}
  public String visit(DTDAny x){return &quot;&quot;;}
  public String visit(DTDPlus x){
    return &quot;  public @Constr void Con(List&lt;&quot;+ShowType.sShowType(x.dtd)+&quot;&gt; xs){}&quot;;}
  public String visit(DTDStar x){
    return &quot;  public @Constr void Con(List&lt;&quot;+ShowType.sShowType(x.dtd)+&quot;&gt; xs){}&quot;;}
  public String visit(DTDQuery x){
    return &quot;  public @Constr void Con(Maybe&lt;&quot;+ShowType.sShowType(x.dtd)+&quot;&gt; xs){}&quot;;}
  public String visit(DTDSeq x){
    StringBuffer result = new StringBuffer(&quot;public @Constr void Con(&quot;);
    boolean first = true;
    for (DTDDef dtd :x.seqParts){
      if (!first) result.append(&quot;,&quot;); 
      final String typeName = ShowType.sShowType(dtd);
      result.append(typeName+&quot; the&quot;+ShowType.typeToIdent(typeName));

      first=false;
    }
    result.append(&quot;){}&quot;);
    return result.toString();
  }
  public String visit(DTDChoice x){
    StringBuffer result = new StringBuffer();
    for (DTDDef dtd :x.choiceParts){
      String typeName = ShowType.sShowType(dtd);
      final String varName = ShowType.typeToIdent(typeName);

      result.append(&quot;\n  public @Constr void C&quot;+elementName+varName
                             +&quot;(&quot;+typeName+&quot; the&quot;+varName+&quot;){}&quot;);
    }
    return result.toString();
  }

  public static String generateADT(String element,DTDDef def){
   return ((DTDDefAdt)def).welcome(new GenerateADT(element));}

  public static void  generateADT
     (String paket,String path,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; xs){
    try {
      for (Tuple3&lt;Boolean,String,DTDDef&gt;x:xs){
        Writer out = new FileWriter(path+&quot;/&quot;+x.e2+&quot;.java&quot;);
        out.write(&quot;package &quot;+paket+&quot;;\n&quot;);
        out.write(&quot;import java.util.List;\n&quot;);
        out.write(&quot;import name.panitz.crempel.util.Maybe;\n&quot;);
        out.write(&quot;import name.panitz.adt.*;\n&quot;);
        out.write(&quot;public @Data class &quot;+x.e2+&quot;{\n&quot;);
        out.write(generateADT(x.e2,x.e3));
        out.write(&quot;}&quot;);
        out.close();
       }
      }catch (Exception e){e.printStackTrace();}
  }
}</code></subsection><subsection titel = "Generation of parser code">
          <code lang = "java"
                class = "ParserCode"
                package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.*;
//import name.panitz.crempel.util.adt.*;
import java.util.List;
import java.util.ArrayList;
import java.io.Writer;
import java.io.StringWriter;
import java.io.IOException;

public class ParserCode extends DTDDefVisitor&lt;String&gt;{
  final String elementName;
  public ParserCode(String e){elementName=e;}

  public String visit(DTDPCData x){return &quot;new PCData()&quot;;}
  public String visit(DTDTagName x){return &quot;getV&quot;+x.tagName+&quot;()&quot;;}
  public String visit(DTDEmpty x){return &quot;new Return(null)&quot;;}
  public String visit(DTDAny x){return null;}
  public String visit(DTDPlus x){return parserCode(x.dtd)+&quot;.plus()&quot;;}
  public String visit(DTDStar x){return parserCode(x.dtd)+&quot;.star()&quot;;}
  public String visit(DTDQuery x){return parserCode(x.dtd)+&quot;.query()&quot;;}
  public String visit(DTDSeq x){
    StringBuffer result = new StringBuffer();
    boolean first = true;
    for (DTDDef dtd:(List&lt;DTDDef&gt;) x.seqParts){
      if (!first){result.append(&quot;.seq(&quot;);}
      result.append(parserCode(dtd));
      if (!first){result.append(&quot;)&quot;);}
      first=false;
    }
    return result.toString();
  }

  public String visit(DTDChoice x){
    final List&lt;DTDDef&gt; xs =  x.choiceParts;
    if (xs.size()==1) {
      final DTDDef ch = xs.get(0);
      final String s  = parserCode(ch);
      return s;
    }
    StringBuffer result = new StringBuffer();
    boolean first = true;
    for (DTDDef dtd:xs){
      final String argType = ShowType.sShowType(dtd);
      final String resType = elementName;
      if (!first){result.append(&quot;.choice(&quot;);}
      result.append(parserCode(dtd));
      result.append(&quot;.&lt;&quot;+resType+&quot;&gt;map(new Function1&lt;&quot;);
      result.append(argType);
      result.append(&quot;,&quot;);
      result.append(resType);
      result.append(&quot;&gt;(){&quot;);
      result.append(&quot;\n    public &quot;+resType+&quot; eval(&quot;+argType+&quot; x){&quot;);
   
      String typeName = ShowType.sShowType(dtd);
      final String varName = ShowType.typeToIdent(typeName);
      result.append(&quot;\n      return (&quot;+resType+&quot;)new C&quot;
             +elementName+varName
             +&quot;(x);&quot;);
      result.append(&quot;\n    }&quot;);
      result.append(&quot;\n  })&quot;);
      if (!first){result.append(&quot;)&quot;);}
      first=false;
    }
    return result.toString();
  }

  public String parserCode(DTDDef def){
    return ((DTDDefAdt)def).welcome(this);}

  public static String parserCode(DTDDef def,String n){
   return new ParserCode(n).parserCode(def);}
}</code>
          <code lang = "java"
                class = "WriteParser"
                commandchars = "`~^"
                package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.*;
//import name.panitz.crempel.util.adt.*;
import java.util.List;
import java.util.ArrayList;
import java.io.Writer;
import java.io.StringWriter;
import java.io.IOException;

public class WriteParser extends DTDDefVisitor&lt;String&gt;{
  final String elementName;
  final boolean isGenerated  ;
  String contentType = null;
  String typeDef = null;
  String fieldName = null;
  String getterName = null;

  public WriteParser(String e,boolean g){elementName=e;isGenerated=g;}

  private void start(DTDDef def,StringBuffer result){
    contentType = ShowType.sShowType(def);
    typeDef = !isGenerated?elementName:contentType;
    fieldName = &quot;v&quot;+elementName;  
    getterName = &quot;getV&quot;+elementName+&quot;()&quot;;  

    result.append(&quot;\n\n  private Parser&lt;&quot;+typeDef+&quot;&gt; &quot;+fieldName+&quot; = null;&quot;); 
    result.append(&quot;\n  public Parser&lt;&quot;+typeDef+&quot;&gt; &quot;+getterName+&quot;{&quot;); 
    result.append(&quot;\n    if (&quot;+fieldName+&quot;==null){&quot;); 
    result.append(&quot;\n      &quot;+fieldName+&quot; = &quot;);
    if (!isGenerated) {
      result.append(&quot;new Element&lt;&quot;+typeDef+&quot;&gt;(\&quot;&quot;+typeDef+&quot;\&quot;&quot;);
      result.append(&quot;\n     ,&quot;);
      result.append(&quot;new Closure&lt;Parser&lt;&quot;+typeDef+&quot;&gt;&gt;(){public Parser&lt;&quot;+typeDef+&quot;&gt; eval(){return &quot;);      
    }

  }

  private String f(DTDDef def){
    StringBuffer result=new StringBuffer();
    start(def,result);
    result.append(ParserCode.parserCode(def,elementName));
    if (!isGenerated){
      result.append(&quot;\n     .&lt;&quot;+typeDef+&quot;&gt;map(new Function1&quot;);
      result.append(&quot;&lt;&quot;+contentType+&quot;,&quot;+typeDef+&quot;&gt;(){&quot;);
      result.append(&quot;\n       public &quot;+typeDef+&quot; eval(&quot;+contentType+&quot; x){&quot;);
      result.append(&quot;\n         return new &quot;+typeDef+&quot;(x);&quot;);
      result.append(&quot;\n       }&quot;);
      result.append(&quot;\n     })&quot;);
    } 
    end(def,result);
    return result.toString();
  }

  private void end(DTDDef def,StringBuffer result){
    if (!isGenerated){
      result.append(&quot;\n;}}//end of closure\n&quot;); 
      result.append(&quot;)&quot;);     

    }
    result.append(&quot;;&quot;); 
    result.append(&quot;\n    }&quot;); 
    result.append(&quot;\n    return &quot;+fieldName+&quot;;&quot;); 
    result.append(&quot;\n  }&quot;);
  }

  private String startend(DTDDef def){
    StringBuffer result=new StringBuffer();
    start(def,result);
    result.append(ParserCode.parserCode(def,elementName));
    end(def,result);
    return result.toString();
  }

  public String visit(DTDPCData x){return f(x);}
  public String visit(DTDTagName x){return f(x);}
  public String visit(DTDEmpty x){return f(x);}
  public String visit(DTDAny x){return null;}
  public String visit(DTDPlus x){return f(x);}
  public String visit(DTDStar x){return f(x);}
  public String visit(DTDQuery x){return f(x);}
  public String visit(DTDChoice x){return startend(x);}
  public String visit(DTDSeq x){
    StringBuffer result = new StringBuffer();
    start(x,result);
    result.append(ParserCode.parserCode(x,elementName));
    result.append(&quot;.map(new Function1&lt;&quot;
                 +ShowType.sShowType(x)+&quot;,&quot;+elementName+&quot;&gt;(){&quot;);
    result.append(&quot;\n    public &quot;+elementName);
    result.append(&quot; eval(&quot;+ShowType.sShowType(x) +&quot; p){&quot;);
    result.append(&quot;\n      return new &quot;+elementName);
    unrollPairs(x.seqParts.size(),&quot;p&quot;,result);
    result.append(&quot;;&quot;);
    result.append(&quot;\n    }&quot;);
    result.append(&quot;\n  }&quot;);
    result.append(&quot;)&quot;);
    end(x,result);
    return result.toString();
  }

  private void unrollPairs(int i,String var,StringBuffer r){
    String c = var;
    String result=&quot;&quot;;
    for (Integer j :new FromTo(2,i)){
       result=&quot;,&quot;+c+&quot;.e2&quot;+result;
       c= c+&quot;.e1&quot;;
    }
    result=c+result;
    r.append(&quot;(&quot;);
    r.append(result);
    r.append(&quot;)&quot;);
  }

  public static String writeParser
                      (DTDDef def,String n,boolean isGenerated){
    return new WriteParser(n,isGenerated).writeParser(def);}

  public  String writeParser(DTDDef def){
    return ((DTDDefAdt)def).welcome(this);}
}</code>
        </subsection><subsection titel = "Flattening of a DTD definition">
          <code lang = "java"
                class = "FlattenResult"
                package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd;
import name.panitz.crempel.util.xml.dtd.tree.DTDDef;
import name.panitz.crempel.util.Tuple3;
import name.panitz.crempel.util.Tuple2;
import java.util.List;
import java.util.ArrayList;


public class FlattenResult
   extends Tuple2&lt;DTDDef,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;&gt;{
  public FlattenResult(DTDDef dtd,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; es){
    super(dtd,es);
  }

  public FlattenResult(DTDDef dtd){
    super(dtd,new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;() );
  }
}</code>
          <code lang = "java"
                class = "DTDDefFlatten"
                package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd;
import name.panitz.crempel.util.xml.dtd.IsAtomic.*;
import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.Tuple3;
import name.panitz.crempel.util.Tuple2;
import name.panitz.crempel.util.Function1;
import java.util.List;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Comparator;

public class DTDDefFlatten extends DTDDefVisitor&lt;FlattenResult&gt;{
  final String elementName;
  final boolean isGenerated;
  private int counter = 0;
  private String getNextName(){
    counter=counter+1;
    return elementName+&quot;_&quot;+counter;
  }

  public DTDDefFlatten(boolean g,String n){elementName=n;isGenerated=g;}

  public FlattenResult visit(DTDPCData x){
    return single(x);}
  public FlattenResult visit(DTDTagName x){
    return single(x);}
  public FlattenResult visit(DTDEmpty x){
    return single(x);}
  public FlattenResult visit(DTDAny x){
    return single(x);}
  public FlattenResult visit(DTDPlus x){
    if (IsAtomic.isAtomic(x.dtd)) return single(x);
    return flattenModified(elementName,x.dtd
          ,new Function1&lt;DTDDef,DTDDef&gt;(){
             public DTDDef eval(DTDDef dtd){return new DTDPlus(dtd);}
           });
  }
  public FlattenResult visit(DTDStar x){
    if (IsAtomic.isAtomic(x.dtd)) return single(x);
    return 
     flattenModified(elementName,x.dtd
          ,new Function1&lt;DTDDef,DTDDef&gt;(){
             public DTDDef eval(DTDDef dtd){return new DTDStar(dtd);}
           });
  }
  public FlattenResult visit(DTDQuery x){
    if (IsAtomic.isAtomic(x.dtd)) return single(x);
    return flattenModified(elementName,x.dtd
          ,new Function1&lt;DTDDef,DTDDef&gt;(){
             public DTDDef eval(DTDDef dtd){return new DTDQuery(dtd);}
           });
  }
  public FlattenResult visit(DTDSeq x){
    return flattenPartList(x.seqParts
          ,new Function1&lt;List&lt;DTDDef&gt;,DTDDef&gt;(){
             public DTDDef eval(List&lt;DTDDef&gt; dtds){
               return new DTDSeq(dtds);}
           });
  }
  public FlattenResult visit(DTDChoice x){
    return flattenPartList(x.choiceParts
          ,new Function1&lt;List&lt;DTDDef&gt;,DTDDef&gt;(){
             public DTDDef eval(List&lt;DTDDef&gt; dtds){
//System.out.println(&quot;the new choice&quot;+dtds);
               return new DTDChoice(dtds);}
           });
   }

  private FlattenResult single(DTDDef x){return new FlattenResult(x);}

  private FlattenResult flattenModified
          (final String orgElem,DTDDef content
          ,Function1&lt;DTDDef,DTDDef&gt; constr){
    List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; result 
     = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;();
    if (needsNewElement(content)){
//    System.out.println(&quot;owo needs new element: &quot;+content );
      final String newElemName
        = ShowType.typeToIdent(ShowType.sShowType(content));

      result.add(new Tuple3&lt;Boolean,String,DTDDef&gt;
         (true,newElemName,content));
      return new FlattenResult
                (constr.eval(new DTDTagName(newElemName)),result);
    } 
//    System.out.println(&quot;does not need new element&quot;);
    FlattenResult innerRes  = flatten(content);
//    System.out.println(innerRes);
    return new FlattenResult(constr.eval(innerRes.e1),innerRes.e2);
  }

  private FlattenResult flattenPartList
      (List&lt;DTDDef&gt; parts,Function1&lt;List&lt;DTDDef&gt;,DTDDef&gt; constr){
    final List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; result 
      = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;();
    if (parts.size()==1) {return single(parts.get(0));}

    List&lt;DTDDef&gt; newParts = new ArrayList&lt;DTDDef&gt;();    
    for (DTDDef part:parts){
      if (IsAtomic.isAtomic(part)) {//System.out.println(&quot;atomic part:&quot;+part);
            newParts.add(part);}
      else if (needsNewElement(part)){
        final String newElemName
          = ShowType.typeToIdent(ShowType.sShowType(part));
        result.add(new Tuple3&lt;Boolean,String,DTDDef&gt;
             (true,newElemName,part));
        newParts.add(new DTDTagName(newElemName));
      }else{
        FlattenResult innerRes  = flatten(part);
        newParts.add(innerRes.e1);
        result.addAll(innerRes.e2);
      }
    } 
    return new FlattenResult(constr.eval(newParts),result);
  }

  static private boolean needsNewElement(DTDDef d){
    return 
     (d instanceof DTDSeq &amp;&amp; ((DTDSeq)d).seqParts.size()&gt;1)
            ||
     (d instanceof DTDChoice &amp;&amp;((DTDChoice)d).choiceParts.size()&gt;1);
  }

  static public List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; 
       flattenDefList(List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; defs){
    boolean changed = true;
    List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; result = defs;
    while (changed){
      Tuple2&lt;Boolean,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;&gt; once
        = flattenDefListOnce(result);
      changed=once.e1;
      result=once.e2;
    } 

    TreeSet&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; withoutDups
      = new TreeSet&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;(
         new Comparator&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;(){
           public int compare(Tuple3&lt;Boolean,String,DTDDef&gt; o1
                             ,Tuple3&lt;Boolean,String,DTDDef&gt; o2){
              return o1.e2.compareTo(o2.e2);
           }
         });
    withoutDups.addAll(result); 

    result = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; ();
    result.addAll(withoutDups);
    return result;
  }

  private static Tuple2&lt;Boolean,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;&gt; 
       flattenDefListOnce(List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; defs){

    final List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; result
     = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;();

    boolean changed = false;

    for (Tuple3&lt;Boolean,String,DTDDef&gt; def:defs){
      final FlattenResult singleResult
        = new DTDDefFlatten(def.e1,def.e2).flatten(def.e3);
      changed=changed||singleResult.e2.size()&gt;0;
      result.addAll(singleResult.e2);
      result.add(
       new Tuple3&lt;Boolean,String,DTDDef&gt;(
         singleResult.e2.isEmpty()&amp;&amp;def.e1,def.e2,singleResult.e1));
    }
    return new Tuple2&lt;Boolean,List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;&gt;
                  (changed,result); 
  }

  public static FlattenResult flatten(DTDDef def,String n){
   return new DTDDefFlatten(false,n).flatten(def);}

  public  FlattenResult flatten(DTDDef def){
   return ((DTDDefAdt)def).welcome(this);}
}

</code>
          <code lang = "java"
                class = "IsAtomic"
                package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;

public class IsAtomic extends DTDDefVisitor&lt;Boolean&gt;{
  public Boolean visit(DTDPCData x){return true;}
  public Boolean visit(DTDTagName x){return true;}
  public Boolean visit(DTDEmpty x){return true;}
  public Boolean visit(DTDAny x){return true;}
  public Boolean visit(DTDPlus x){return isAtomic(x.dtd);}
  public Boolean visit(DTDStar x){return isAtomic(x.dtd);}
  public Boolean visit(DTDQuery x){return isAtomic(x.dtd);}
  public Boolean visit(DTDSeq x){return false;}
  public Boolean visit(DTDChoice x){return false;}

  public static Boolean isAtomic(DTDDef def ){
   return ((DTDDefAdt)def).welcome(new IsAtomic());}
}</code>
        </subsection><subsection titel = "Main generation class">
          <code lang = "java"
                class = "GenerateClassesForDTD"
                commandchars = "_~^"
                package = "name/panitz/crempel/util/xml/dtd">package name.panitz.crempel.util.xml.dtd;

import name.panitz.crempel.util.xml.dtd.tree.*;
import java.util.List;
import java.util.ArrayList;
import java.io.*;
import name.panitz.crempel.util.*;

public class GenerateClassesForDTD{
  public static void generateAll
     (String paket,String path,String n,List&lt;Tuple2&lt;String,DTDDef&gt;&gt;dtds){
    List&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt; xs
      = new ArrayList&lt;Tuple3&lt;Boolean,String,DTDDef&gt;&gt;();
    for (Tuple2&lt;String,DTDDef&gt; t:dtds)
      xs.add(new Tuple3&lt;Boolean,String,DTDDef&gt;(false,t.e1,t.e2));

    xs = DTDDefFlatten.flattenDefList(xs);

    System.out.println(&quot;vereinfacht und flachgemacht&quot;);
    for (Tuple3&lt;Boolean,String,DTDDef&gt; t:xs){
      System.out.println(t.e2);
      System.out.println(t.e3);
      System.out.println(&quot;&quot;);
    }
    
    final String parserType = dtds.get(0).e1;
    try{
      Writer out = new FileWriter(path+&quot;/&quot;+n+&quot;Parser&quot;+&quot;.java&quot;);
      out.write(&quot;package &quot;+paket+&quot;;\n&quot;);

      out.write(&quot;import name.panitz.crempel.util.xml.parslib.*;\n&quot;);
      out.write(&quot;import name.panitz.crempel.util.*;\n&quot;);
      out.write(&quot;import java.util.*;\n&quot;);
      out.write(&quot;import org.w3c.dom.Node;\n\n&quot;);

      out.write(&quot;public class &quot;+n+&quot;Parser &quot;);
      out.write(&quot;extends AbstractParser&lt;&quot;+parserType+&quot;&gt;{\n&quot;);

      out.write(&quot;public ParseResult&lt;&quot;+parserType+&quot;&gt; &quot;);
      out.write(&quot;parse(List&lt;Node&gt; xs){&quot;);
      out.write(&quot;  return getV&quot;+parserType+&quot;().parse(xs);}\n\n&quot;);

      for (Tuple3&lt;Boolean,String,DTDDef&gt; x :xs)
        out.write(WriteParser.writeParser(x.e3,x.e2,x.e1));

      out.write(&quot;}&quot;);  
      out.close();  
    }catch (IOException e){e.printStackTrace();}
    GenerateADT.generateADT(paket,path,xs);
  }             
}</code>
        </subsection><subsection titel = "Main generator class">

We provide the main class for generating the parser and algebraic type for a
given dtd. Two arguments are passed on the command line. The file name of the
DTD file and a package for the generated classes.<code class = "MainDTDParse"
                lang = "java"
                package = "name/panitz/crempel/util/xml/dtd/parser">package name.panitz.crempel.util.xml.dtd.parser;

import java.io.*;
import java.util.*;
import name.panitz.crempel.util.*;
import name.panitz.crempel.util.xml.dtd.tree.*;
import name.panitz.crempel.util.xml.dtd.*;

public class MainDTDParse {
  public static void main(String [] args){
    try{
      final String dtdFileName = args[0];
      final String packageName = args[1].replace(&#39;/&#39;,&#39;.&#39;);

      File f = new File(dtdFileName);  
      final String path
          = f.getParentFile()==null?&quot;.&quot;:f.getParentFile().getPath();

      final DTD parser = new DTD(new FileReader(f));

      final Tuple3&lt;List&lt;Tuple2&lt;String,DTDDef&gt;&gt;,List&lt;String&gt;,String&gt; dtd
        = parser.dtd();

      for (Tuple2&lt;String,DTDDef&gt; t:dtd.e1){
        System.out.println(t.e1);
        System.out.println(t.e2);
        System.out.println(&quot;&quot;);
      }
 
      GenerateClassesForDTD
          .generateAll(packageName,path,dtd.e3,dtd.e1);
   }catch (Exception _){_.printStackTrace();System.out.println(_);} 
  }
}</code><scode>sep@linux:~/fh/xmlparslib/examples/src/name/panitz/album&gt; java -c
lasspath /home/sep/fh/xmlparslib/examples/classes/:/home/sep/fh/java1.5/exa
mples/classes/:/home/sep/fh/adt/examples/classes/ name.panitz.crempel.util.
xml.dtd.parser.MainDTDParse album.dtd name.panitz.album
package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class Choice_String_author{

  CChoice_String_authorString(String theString);
  CChoice_String_authorauthor(author theauthor);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class Choice_lp_cd_mc{

  CChoice_lp_cd_mclp(lp thelp);
  CChoice_lp_cd_mccd(cd thecd);
  CChoice_lp_cd_mcmc(mc themc);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class artist{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class author{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class cd{
Con(title thetitle,artist theartist,Maybe&lt;recordingyear&gt; 
 theMaybe_recordingyear_,List&lt;track&gt; theList_track_,List&lt;note&gt; theList_note_);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class lp{
Con(title thetitle,artist theartist,Maybe&lt;recordingyear&gt; 
 theMaybe_recordingyear_,List&lt;track&gt; theList_track_,List&lt;note&gt; theList_note_);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class mc{
Con(title thetitle,artist theartist,Maybe&lt;recordingyear&gt; 
 theMaybe_recordingyear_,List&lt;track&gt; theList_track_,List&lt;note&gt; theList_note_);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class musiccollection{
Con(List&lt;Choice_lp_cd_mc&gt; xs);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class note{
Con(List&lt;Choice_String_author&gt; xs);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class recordingyear{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class timing{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class title{
Con(String pcdata);}

package name.panitz.album;
import java.util.List;
import name.panitz.crempel.util.Maybe;
data class track{
Con(title thetitle,Maybe&lt;timing&gt; theMaybe_timing_);}

sep@linux:~/fh/xmlparslib/examples/src/name/panitz/album&gt; ls
CChoice_String_authorString.java    lpVisitor.java
CChoice_String_authorauthor.java    mc.java
CChoice_lp_cd_mccd.java             mcVisitable.java
CChoice_lp_cd_mclp.java             mcVisitor.java
CChoice_lp_cd_mcmc.java             musiccollection.java
Choice_String_author.java           musiccollectionParser.java
Choice_String_authorVisitable.java  musiccollectionVisitable.java
Choice_String_authorVisitor.java    musiccollectionVisitor.java
Choice_lp_cd_mc.java                note.java
Choice_lp_cd_mcVisitable.java       noteVisitable.java
Choice_lp_cd_mcVisitor.java         noteVisitor.java
album.dtd                           recordingyear.java
artist.java                         recordingyearVisitable.java
artistVisitable.java                recordingyearVisitor.java
artistVisitor.java                  timing.java
author.java                         timingVisitable.java
authorVisitable.java                timingVisitor.java
authorVisitor.java                  title.java
cd.java                             titleVisitable.java
cdVisitable.java                    titleVisitor.java
cdVisitor.java                      track.java
lp.java                             trackVisitable.java
lpVisitable.java                    trackVisitor.java
sep@linux:~/fh/xmlparslib/examples/src/name/panitz/album&gt;</scode></subsection><subsection titel = "JaxB">
          <scode>sep@linux:~/fh/xmlparslib/&gt; ~/jwsdp-1.3/jaxb/bin/xjc.sh -dtd
  album.dtd -p name.panitz.jaxb.album
parsing a schema...
compiling a schema...
name/panitz/jaxb/album/impl/runtime/GrammarInfo.java
name/panitz/jaxb/album/impl/runtime/AbstractUnmarshallingEventHandlerImpl.java
name/panitz/jaxb/album/impl/runtime/PrefixCallback.java
name/panitz/jaxb/album/impl/runtime/Discarder.java
name/panitz/jaxb/album/impl/runtime/ValidatableObject.java
name/panitz/jaxb/album/impl/runtime/SAXUnmarshallerHandlerImpl.java
name/panitz/jaxb/album/impl/runtime/ContentHandlerAdaptor.java
name/panitz/jaxb/album/impl/runtime/ValidatorImpl.java
name/panitz/jaxb/album/impl/runtime/UnmarshallerImpl.java
name/panitz/jaxb/album/impl/runtime/GrammarInfoFacade.java
name/panitz/jaxb/album/impl/runtime/XMLSerializable.java
name/panitz/jaxb/album/impl/runtime/UnmarshallingEventHandler.java
name/panitz/jaxb/album/impl/runtime/DefaultJAXBContextImpl.java
name/panitz/jaxb/album/impl/runtime/SAXMarshaller.java
name/panitz/jaxb/album/impl/runtime/GrammarInfoImpl.java
name/panitz/jaxb/album/impl/runtime/MSVValidator.java
name/panitz/jaxb/album/impl/runtime/UnmarshallableObject.java
name/panitz/jaxb/album/impl/runtime/SAXUnmarshallerHandler.java
name/panitz/jaxb/album/impl/runtime/ErrorHandlerAdaptor.java
name/panitz/jaxb/album/impl/runtime/NamespaceContext2.java
name/panitz/jaxb/album/impl/runtime/Util.java
name/panitz/jaxb/album/impl/runtime/UnmarshallingEventHandlerAdaptor.java
name/panitz/jaxb/album/impl/runtime/ValidationContext.java
name/panitz/jaxb/album/impl/runtime/ValidatingUnmarshaller.java
name/panitz/jaxb/album/impl/runtime/MarshallerImpl.java
name/panitz/jaxb/album/impl/runtime/XMLSerializer.java
name/panitz/jaxb/album/impl/runtime/UnmarshallingContext.java
name/panitz/jaxb/album/impl/runtime/NamespaceContextImpl.java
name/panitz/jaxb/album/impl/ArtistImpl.java
name/panitz/jaxb/album/impl/AuthorImpl.java
name/panitz/jaxb/album/impl/CdImpl.java
name/panitz/jaxb/album/impl/JAXBVersion.java
name/panitz/jaxb/album/impl/LpImpl.java
name/panitz/jaxb/album/impl/McImpl.java
name/panitz/jaxb/album/impl/MusiccollectionImpl.java
name/panitz/jaxb/album/impl/NoteImpl.java
name/panitz/jaxb/album/impl/RecordingyearImpl.java
name/panitz/jaxb/album/impl/TimingImpl.java
name/panitz/jaxb/album/impl/TitleImpl.java
name/panitz/jaxb/album/impl/TrackImpl.java
name/panitz/jaxb/album/Artist.java
name/panitz/jaxb/album/Author.java
name/panitz/jaxb/album/Cd.java
name/panitz/jaxb/album/Lp.java
name/panitz/jaxb/album/Mc.java
name/panitz/jaxb/album/Musiccollection.java
name/panitz/jaxb/album/Note.java
name/panitz/jaxb/album/ObjectFactory.java
name/panitz/jaxb/album/Recordingyear.java
name/panitz/jaxb/album/Timing.java
name/panitz/jaxb/album/Title.java
name/panitz/jaxb/album/Track.java
name/panitz/jaxb/album/jaxb.properties
name/panitz/jaxb/album/bgm.ser
sep@linux:~/fh/xmlparslib/examples/src/name/panitz/album&gt;</scode>
        </subsection></section>
      <include asThis = "section"
               uri = "../play/skript.xml"/>
      <section titel = "Conclusion">
We applied techniques as known from functional programming to Java.
Algebraic types and parser combinators enables us to write a complicated
library tool, which generates classes and parsers for a given <tt>DTD</tt>.
Java&#39;s generic types provide some good means to express these concepts in
a static type safe manner.<p/>


With <em>JaxB (JavaTM Architecture for XML Binding)</em> Sun 
provides a library and tool which addresses the same problem: for a given
schema generate classes and a parser. However, the resulting classes and
parsers in <em>JaxB</em> do not provide the visitor pattern for the resulting
class and do not use the concepts as known from functional programming.</section>
      <section titel = "Javacc input file for DTD parser">
In this section you can find a simple not complete parser for DTDs as input
grammar for the parser generator <em>javacc</em>.<code class = "dtd"
              lang = "jj"
              package = "name/panitz/crempel/util/xml/dtd/parser"
              commandchars = "`~^">options {STATIC=false;}

PARSER_BEGIN(DTD)
package name.panitz.crempel.util.xml.dtd.parser;

import name.panitz.crempel.util.*;
import name.panitz.crempel.util.xml.dtd.tree.*;
import java.util.List;
import java.util.ArrayList;
import java.io.FileReader;

public class DTD {}
PARSER_END(DTD)

TOKEN :
{&lt;ELEMENTDEC: &quot;&lt;!ELEMENT&quot;&gt;
|&lt;DOCTYPE:    &quot;&lt;!DOCTYPE&quot;&gt; 
|&lt;ATTLIST:    &quot;&lt;!ATTLIST&quot;&gt; 
|&lt;REQUIRED:   &quot;#REQUIRED&quot;&gt; 
|&lt;IMPLIED:    &quot;#IMPLIED&quot;&gt; 
|&lt;EMPTY: &quot;EMPTY&quot;&gt;
|&lt;PCDATA: &quot;#PCDATA&quot;&gt;
|&lt;CDATA: &quot;CDATA&quot;&gt;
|&lt;ANY: &quot;ANY&quot;&gt;
|&lt;SYSTEM: &quot;SYSTEM&quot;&gt;
|&lt;PUBLIC: &quot;PUBLIC&quot;&gt;
|&lt;GR: &quot;&gt;&quot;&gt;
|&lt;QMARK: &quot;?&quot;&gt;
|&lt;PLUS: &quot;+&quot;&gt;
|&lt;STAR: &quot;*&quot;&gt;
|&lt;#NameStartCar: [&quot;:&quot;,&quot;A&quot;-&quot;Z&quot;,&quot;_&quot;,&quot;a&quot;-&quot;z&quot;
                 ,&quot;\u00C0&quot;-&quot;\u00D6&quot;
                 ,&quot;\u00D8&quot;-&quot;\u00F6&quot;
                 ,&quot;\u00F8&quot;-&quot;\u02FF&quot;
                 ,&quot;\u0370&quot;-&quot;\u037D&quot;
                 ,&quot;\u037F&quot;-&quot;\u1FFF&quot;
                 ,&quot;\u200C&quot;-&quot;\u200D&quot;
                 ,&quot;\u2070&quot;-&quot;\u218F&quot;
                 ,&quot;\u2C00&quot;-&quot;\u2FEF&quot;
                 ,&quot;\u3001&quot;-&quot;\uD7FF&quot;
                 ,&quot;\uF900&quot;-&quot;\uFDCF&quot;
                 ,&quot;\uFDF0&quot;-&quot;\uFFFD&quot;]&gt;
//                 ,&quot;\u10000&quot;-&quot;\uEFFFF&quot;]&gt;
|&lt;#InnerNameChar: [&quot;-&quot;, &quot;.&quot;,&quot;0&quot;-&quot;9&quot;, &quot;\u00B7&quot; 
                  ,&quot;\u0300&quot;-&quot;\u036F&quot;
                  ,&quot;\u203F&quot;-&quot;\u2040&quot;]&gt;
|&lt;#NameChar: &lt;InnerNameChar&gt;|&lt;NameStartCar&gt;&gt;
|&lt;Name: &lt;NameStartCar&gt; (&lt;NameChar&gt;)* &gt;

|&lt;#ALPHA:       [&quot;a&quot;-&quot;z&quot;,&quot;A&quot;-&quot;Z&quot;,&quot;_&quot;,&quot;.&quot;]&gt;
|&lt;#NUM:	        [&quot;0&quot;-&quot;9&quot;]&gt;
|&lt;#ALPHANUM:    &lt;ALPHA&gt; | &lt;NUM&gt;&gt;
|&lt;EQ: &quot;=&quot;&gt;
|&lt;BAR: &quot;|&quot;&gt;
|&lt;LPAR: &quot;(&quot;&gt;
|&lt;RPAR: &quot;)&quot;&gt;
|&lt;LBRACKET: &quot;{&quot;&gt;
|&lt;RBRACKET: &quot;}&quot;&gt;
|&lt;LSQBRACKET: &quot;[&quot;&gt;
|&lt;RSQBRACKET: &quot;]&quot;&gt;
|&lt;LE: &quot;&lt;&quot;&gt;
|&lt;SEMICOLON: &quot;;&quot;&gt;
|&lt;COMMA: &quot;,&quot;&gt;
|&lt;QUOTE: &quot;\&quot;&quot;&gt;
|&lt;SINGLEQUOTE: &quot;&#39;&quot;&gt;
}

SKIP :
{&lt; [&quot;\u0020&quot;,&quot;\t&quot;,&quot;\r&quot;,&quot;\n&quot;] &gt;}

//&quot;

void externalID():
{}
{&lt;SYSTEM&gt; systemLiteral()
 |&lt;PUBLIC&gt; systemLiteral() systemLiteral()
}

void systemLiteral():{}
{&lt;QUOTE&gt;&lt;Name&gt;&lt;QUOTE&gt;|&lt;SINGLEQUOTE&gt;&lt;Name&gt;&lt;SINGLEQUOTE&gt;
}

Tuple3&lt;List&lt;Tuple2&lt;String,DTDDef&gt;&gt;,List&lt;String&gt;,String&gt; dtd():
{ 
  Token nameToken;
  List&lt;Tuple2&lt;String,DTDDef&gt;&gt; els = new ArrayList&lt;Tuple2&lt;String,DTDDef&gt;&gt;();
  List&lt;String&gt; atts = new ArrayList&lt;String&gt;();
  Tuple2&lt;String,DTDDef&gt; el;
}
{&lt;DOCTYPE&gt; nameToken=&lt;Name&gt; externalID() &lt;LSQBRACKET&gt;

   (el=elementdecl(){ els.add(el);}
   |AttlistDecl())* 
 &lt;RSQBRACKET&gt;&lt;GR&gt;
  {return new Tuple3&lt;List&lt;Tuple2&lt;String,DTDDef&gt;&gt;,List&lt;String&gt;,String&gt;
                (els,atts,nameToken.toString());}
}

Tuple2&lt;String,DTDDef&gt; elementdecl():
{Token nameToken;
 DTDDef content;}
{&lt;ELEMENTDEC&gt; nameToken=&lt;Name&gt;  content=contentspec()  &lt;GR&gt;
  {return new Tuple2&lt;String,DTDDef&gt;(nameToken.toString(),content);}
}


DTDDef contentspec():
{DTDDef result;}
{  &lt;EMPTY&gt;{result=new DTDEmpty();} 
 | &lt;ANY&gt;{result=new DTDAny();}
 | (&lt;LPAR&gt;(result=Mixed()
          |result=children()))
 { return result;}
}

DTDDef children():
{ List&lt;DTDDef&gt; cps;
  DTDDef cp;
  Modifier mod = Modifier.none;
  boolean wasChoice = true;
}
{cp=cp()
  (cps=choice()| cps=seq(){wasChoice=false;})
   {cps.add(0,cp);} 
   &lt;RPAR&gt;(&lt;QMARK&gt;{mod=Modifier.query;}
     |&lt;STAR&gt;{mod=Modifier.star;}
     |&lt;PLUS&gt;{mod=Modifier.plus;})?
  {DTDDef result=wasChoice?ParserAux.createDTDChoice(cps)
                          :ParserAux.createDTDSeq(cps);
   return mod.mkDTDDef(result);
  }
}

List&lt;DTDDef&gt; choice():
{ DTDDef cp;
  List&lt;DTDDef&gt; result = new ArrayList&lt;DTDDef&gt;();}
{(&lt;BAR&gt; cp=cp() {result.add(cp);} )+
  {return result;}
}

DTDDef cp():
{ Token nameToken=null;
  List&lt;DTDDef&gt; cps=new ArrayList&lt;DTDDef&gt;();
  DTDDef cp;
  Modifier mod=Modifier.none;
  boolean wasChoice = true;
  boolean wasTagName = false;
}
{((nameToken = &lt;Name&gt;{wasTagName=true;})
 |(&lt;LPAR&gt;cp=cp()
         (cps=choice()|cps=seq(){wasChoice=false;})
    {cps.add(0,cp);}
   &lt;RPAR&gt;
  )
 ) 
     (&lt;QMARK&gt;{mod=Modifier.query;}
     |&lt;STAR&gt;{mod=Modifier.star;}
     |&lt;PLUS&gt;{mod=Modifier.plus;})?
{
 DTDDef result;
 if (wasTagName) result=new DTDTagName(nameToken.toString());
 else result=wasChoice?ParserAux.createDTDChoice(cps)
                      :ParserAux.createDTDSeq(cps);
 return mod.mkDTDDef(result);
}
}

List&lt;DTDDef&gt; seq():
{  List&lt;DTDDef&gt; result = new ArrayList&lt;DTDDef&gt;();
   DTDDef cp;
}
{(&lt;COMMA&gt; cp=cp(){result.add(cp);} )*
  {return result;}
}

DTDDef Mixed():
{Token nameToken;
 List&lt;DTDDef&gt; xs = new ArrayList&lt;DTDDef&gt;();
 Modifier mod=Modifier.none;
}
{  &lt;PCDATA&gt; {xs.add(new DTDPCData());}
  ((&lt;BAR&gt; nameToken=&lt;Name&gt; 
    {xs.add(new DTDTagName(nameToken.toString()));}
   )* &lt;RPAR&gt;(&lt;STAR&gt;{mod=Modifier.star;})?)
{return mod.mkDTDDef(ParserAux.createDTDChoice(xs));}

}

void AttlistDecl():
{Token nameToken;}
{&lt;ATTLIST&gt; nameToken=&lt;Name&gt; (AttDef() )*
{}}

void AttDef():
{Token nameToken;
 boolean isRequired;}
{nameToken=&lt;Name&gt; AttType() isRequired=DefaultDecl()
  {}
}

void AttType():
{}
{ StringType()}//|TokenizedType()|EnumeratedType()}

void StringType():
{}
{&lt;CDATA&gt;}


boolean DefaultDecl():
{ boolean isRequired=false;}

{(&lt;REQUIRED&gt;{isRequired=true;} | &lt;IMPLIED&gt;)
//| ((&#39;#FIXED&#39; S)? AttValue)
{return isRequired;}
}</code><code class = "ParserAux"
              lang = "java"
              package = "name/panitz/crempel/util/xml/dtd/parser">package name.panitz.crempel.util.xml.dtd.parser;

import name.panitz.crempel.util.xml.dtd.tree.*;
import java.util.List;

public class ParserAux{
  static public DTDDef createDTDSeq(List&lt;DTDDef&gt; xs){
    return new DTDSeq(xs);
  }
  static public DTDDef createDTDChoice(List&lt;DTDDef&gt; xs){
    return new DTDChoice(xs);
  }  
}</code><code class = "Modifier"
              lang = "java"
              package = "name/panitz/crempel/util/xml/dtd/tree">package name.panitz.crempel.util.xml.dtd.tree;

public enum Modifier { none, star, plus, query;

  public String toString(){
    switch(this) {
          case star:   return &quot;*&quot;;
          case plus:   return &quot;+&quot;;
          case query:  return &quot;?&quot;;
    }
    return &quot;&quot;;
  }

  public DTDDef mkDTDDef(DTDDef dtd){
    switch(this) {
      case star:   return new DTDStar(dtd);
      case plus:   return new DTDPlus(dtd);
      case query:  return new DTDQuery(dtd);
    }
    return dtd;
  }
}</code></section>
    </kapitel>
    <kapitel titel = "Hilfklasssen zu Swing">
      <code lang = "java"
            class = "SwingWorker"
            package = "name/panitz/swing/threadTest">package name.panitz.swing.threadTest;
import javax.swing.SwingUtilities;

/**
 * This is the 3rd version of SwingWorker (also known as
 * SwingWorker 3), an abstract class that you subclass to
 * perform GUI-related work in a dedicated thread.  For
 * instructions on using this class, see:
 * 
 * http://java.sun.com/docs/books/tutorial/uiswing/misc/threads.html
 *
 * Note that the API changed slightly in the 3rd version:
 * You must now invoke start() on the SwingWorker after
 * creating it.
 */
public abstract class SwingWorker {
    private Object value;  // see getValue(), setValue()
    private Thread thread;

    /** 
     * Class to maintain reference to current worker thread
     * under separate synchronization control.
     */
    private static class ThreadVar {
        private Thread thread;
        ThreadVar(Thread t) { thread = t; }
        synchronized Thread get() { return thread; }
        synchronized void clear() { thread = null; }
    }

    private ThreadVar threadVar;

    /** 
     * Get the value produced by the worker thread, or null if it 
     * hasn&#39;t been constructed yet.
     */
    protected synchronized Object getValue() { 
        return value; 
    }

    /** 
     * Set the value produced by worker thread 
     */
    private synchronized void setValue(Object x) { 
        value = x; 
    }

    /** 
     * Compute the value to be returned by the &lt;code&gt;get&lt;/code&gt; method. 
     */
    public abstract Object construct();

    /**
     * Called on the event dispatching thread (not on the worker thread)
     * after the &lt;code&gt;construct&lt;/code&gt; method has returned.
     */
    public void finished() {
    }

    /**
     * A new method that interrupts the worker thread.  Call this method
     * to force the worker to stop what it&#39;s doing.
     */
    public void interrupt() {
        Thread t = threadVar.get();
        if (t != null) {
            t.interrupt();
        }
        threadVar.clear();
    }

    /**
     * Return the value created by the &lt;code&gt;construct&lt;/code&gt; method.  
     * Returns null if either the constructing thread or the current
     * thread was interrupted before a value was produced.
     * 
     * @return the value created by the &lt;code&gt;construct&lt;/code&gt; method
     */
    public Object get() {
        while (true) {  
            Thread t = threadVar.get();
            if (t == null) {
                return getValue();
            }
            try {
                t.join();
            }
            catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // propagate
                return null;
            }
        }
    }


    /**
     * Start a thread that will call the &lt;code&gt;construct&lt;/code&gt; method
     * and then exit.
     */
    public SwingWorker() {
        final Runnable doFinished = new Runnable() {
           public void run() { finished(); }
        };

        Runnable doConstruct = new Runnable() { 
            public void run() {
                try {
                    setValue(construct());
                }
                finally {
                    threadVar.clear();
                }

                SwingUtilities.invokeLater(doFinished);
            }
        };

        Thread t = new Thread(doConstruct);
        threadVar = new ThreadVar(t);
    }

    /**
     * Start the worker thread.
     */
    public void start() {
        Thread t = threadVar.get();
        if (t != null) {
            t.start();
        }
    }
}</code>
    </kapitel>
    <kapitel titel = "Fragen und Antworten als Lernhilfe">
      <faqs>
        <faq>
          <frage>Ist Java eine kompilierte oder interpretierte Sprache?</frage>
          <antwort>Im Prinzip beides: Ein Compiler übersetzt den Quelltext in
.class-Dateien, die Code für eine virtuelle Maschine enthalten. Ein
Interpreter ist in der Lage diesen Code auszuführen. </antwort>
        </faq>
        <faq>
          <frage>Wie ist ein Javaprogramm strukturiert?</frage>
          <antwort>Pro Datei eine Klasse (oder Schnittstelle oder Aufzählung), die den
Namen der Datei trägt.</antwort>
        </faq>
        <faq>
          <frage>Gibt es einen Präprozessor?</frage>
          <antwort>Nein.</antwort>
        </faq>
        <faq>
          <frage>Gibt es einen Linker?</frage>
          <antwort>Nein, aber die virtuelle Maschine hat einen Klassenlader, der den
Code der einzelnen Klassen bei Bedarf lädt.</antwort>
        </faq>
        <faq>
          <frage>Welche Namenskonventionen gibt es?</frage>
          <antwort>Klassennamen beginnen mit einem Großbuchstaben, globale Konstanten
sind komplett in Großbuchstaben geschrieben. Pakete, Parameter, Variablen
beginnen mit einem Kleinbuchstaben. Bei Bezeichnern aus mehreren Wörter fängt
das nächste Wort immer mit einem Großbuchstaben an.</antwort>
        </faq>
        <faq>
          <frage>Ist Java statisch getypt?</frage>
          <antwort>Ja, der Compiler überprüft, ob das Programm korrekt 
getypt ist. </antwort>
        </faq>
        <faq>
          <frage>Gibt es auch dynamische Typüberprüfung zur Laufzeit?</frage>
          <antwort>Ja, zum einem verifiziert die virtuelle Maschine noch einmal
den Code, zum anderen bewirkt eine Typzusicherung (cast) eine
Laufzeittypüberprüfung. </antwort>
        </faq>
        <faq>
          <frage>Kann ich sicherstellen, daß die Typzusicherung während der Laufzeit
nicht fehlschlägt.</frage>
          <antwort>Ja, indem vor der Typzusicherung der Test mit <tt>instanceof</tt>
gemacht wird.</antwort>
        </faq>
        <faq>
          <frage>Wie schreibt man Unterprogramme oder Funktionen?</frage>
          <antwort>Immer innerhalb einer Klasse. Sie werden als Methoden 
bezeichnet.</antwort>
        </faq>
        <faq>
          <frage>Was sind die Eigenschaften einer Klasse?</frage>
          <antwort>Zum einen die Felder (auch als Attribute) bezeichnet, in denen
Referenzen auf Objekte abgelegt werden können. Zum anderen die Methoden und
Konstruktoren.  </antwort>
        </faq>
        <faq>
          <frage>Was ist das <tt>this</tt>-Objekt?</frage>
          <antwort>Damit wird das Objekt bezeichnet, in dem sich eine Eigenschaft
befindet. </antwort>
        </faq>
        <faq>
          <frage>Was ist Vererbung?</frage>
          <antwort>Jede Klasse hat genau eine Oberklasse, die in 
der <tt>extends</tt>-Klausel angegeben wird. Objekte können alle
Eigenschaften die in ihrer Oberklasse zur Verfügung stehen benutzen.</antwort>
        </faq>
        <faq>
          <frage>Was ist wenn ich keine Oberklasse angebe?</frage>
          <antwort>Dann ist automatisch die Klasse <tt>Object</tt> die Oberklasse.</antwort>
        </faq>
        <faq>
          <frage>Was sind Konstruktoren?</frage>
          <antwort>Konstruktoren sind der Code einer Klasse, der beim Erzeugen von neuen
Objekten ausgeführt wird und in der Regel die Felder des Objektes initialisiert.</antwort>
        </faq>
        <faq>
          <frage>Wie werden Konstruktoren definiert?</frage>
          <antwort>Ähnlich wie Methoden. Sie haben den Namen der Klasse und keinen
Rückgabetyp. </antwort>
        </faq>
        <faq>
          <frage>Wie werden Konstuktoren aufgerufen?</frage>
          <antwort>Durch das Schlüsselwort <tt>new</tt> gefolgt von dem 
Klassennamen.</antwort>
        </faq>
        <faq>
          <frage>Hat jede Klasse einen Konstruktor?</frage>
          <antwort>Ja.</antwort>
        </faq>
        <faq>
          <frage>Und wenn ich keinen Konstruktor für meine Klasse schreibe?</frage>
          <antwort>Dann fügt Java einen leeren Konstruktor ohne Parameter ein.</antwort>
        </faq>
        <faq>
          <frage>Was ist der Unterschied zwischen statischen und nicht statischen
Eigenschaften einer Klasse?</frage>
          <antwort>Eine statische Eigenschaft ist nicht an spezielle Objekte
gebunden. Sie hat daher auch kein <tt>this</tt>-Objekt. Eine statische
Eigenschaft existiert nur einmal für alle Objekte einer
Klasse. Nicht-statische Methoden werden auch als Objektmethoden 
bezeichnet. </antwort>
        </faq>
        <faq>
          <frage>Gibt es auch statische Konstruktoren?</frage>
          <antwort>Ja, pro Klasse genau einen, der keine Parameter hat.</antwort>
        </faq>
        <faq>
          <frage>Kann ich den statischen Konstruktor auch selbst definieren?</frage>
          <antwort>Ja, mit dem Schlüssenwort <tt>static</tt> gefolgt von in geschweiften
Klammern eingeschlossenen Code.</antwort>
        </faq>
        <faq>
          <frage>Was bedeutet Überschreiben von Methoden?</frage>
          <antwort>Methoden, die es in der Oberklasse bereits gibt in einer Unterklasse
neu zu definieren.</antwort>
        </faq>
        <faq>
          <frage>Kann ich auch Konstruktoren überschreiben?</frage>
          <antwort>Nein.</antwort>
        </faq>
        <faq>
          <frage>Was bezeichnet man als Polymorphie?</frage>
          <antwort>Wenn eine Methode in verschiedenen Unterklassen einer Klasse
überschrieben wird.</antwort>
        </faq>
        <faq>
          <frage>Kann ich in einer überschreibenen Methode, die überschriebene Methode
aufrufen?</frage>
          <antwort>Ja, indem man das Schlüsselwort <tt>super</tt> benutzt und mit einem
Punkt abgetrennt den eigentlichen Methodenaufruf folgen läßt.</antwort>
        </faq>
        <faq>
          <frage>Kann ich Konstruktoren der Oberklasse aufrufen.</frage>
          <antwort>Ja, aber nur im Konstruktor als erste Anweisung. Hier muß sogar der
Aufruf eines Konstruktors der Oberklasse stehen. Dieser Aufruf wird durch das
Schlüsselwort <tt>super</tt> gefolgt von der Parameterliste gemacht.</antwort>
        </faq>
        <faq>
          <frage>Was ist, wenn ich im Konstruktor keinen Aufruf an einen Konstruktor der
Oberklasse schreiben. </frage>
          <antwort>Dann generiert Java den Aufruf eines Konstruktors der Oberklasse ohne
Parameter als erste Anweisung in den Konstruktor. Sollte so ein parameterloser
Konstruktor nicht existieren, dann gibt es allerdings einen 
Folgefehler. </antwort>
        </faq>
        <faq>
          <frage>Was ist späte Bindung (late binding)?</frage>
          <antwort>Beim Aufruf von Objektmethoden wird immer der Methodencode
ausgeführt, der in der Klasse implementiert wurde, von der das Objekt, auf dem
diese Methode aufgerufen wurde, erzeugt wurde. Es wird also immer
die überschreibende Version einer Methode benutzt.</antwort>
        </faq>
        <faq>
          <frage>Was sind virtuelle Methoden und gibt es sie in Java?</frage>
          <antwort>In C++ werden Methoden, für die späte Bindung gewünscht ist als
virtuell markiert. In Java funktioniert die späte Bindung für alle 
Objektmethoden. </antwort>
        </faq>
        <faq>
          <frage>Funktioniert späte Bindung auch für Felder?</frage>
          <antwort>Nein.</antwort>
        </faq>
        <faq>
          <frage>Funktioniert späte Bindung auch für statische Methoden?</frage>
          <antwort>Nein.</antwort>
        </faq>
        <faq>
          <frage>Funktioniert späte Bindung auch für Konstruktoren?</frage>
          <antwort>Nein.</antwort>
        </faq>
        <faq>
          <frage>Was sind überladene Methoden? </frage>
          <antwort>Methoden gleichen Namens in einer Klasse, die sich in Typ/Anzahl der
Parameter unterscheiden.</antwort>
        </faq>
        <faq>
          <frage>Können auch Konstruktoren überladen werden?</frage>
          <antwort>Ja.</antwort>
        </faq>
        <faq>
          <frage>Gibt es das Prinzip von später Bindung auch für die verschiedenen
überladenen Versionen einer Methode? </frage>
          <antwort>Nein! Die Auflösung, welche der überladenen Versionen einer Methode
ausgeführt wird, wird bereits statisch vom Compiler vorgenommen und nicht
dynamisch während der laufzeit.</antwort>
        </faq>
        <faq>
          <frage>Was sind abstrakte Klassen?</frage>
          <antwort>Klassen, die als <tt>abstract</tt> deklariert sind. Nur abstrakte
Klassen können abstrakte Eigenschaften enthalten.</antwort>
        </faq>
        <faq>
          <frage>Und was sind abstrakte Eigenschaften?</frage>
          <antwort>Das sind Methoden, die keinen Methodenrumpf haben. </antwort>
        </faq>
        <faq>
          <frage>Können abstrakte Klassen Konstruktoren haben?</frage>
          <antwort>Ja, allerdings können von abstrakten Klassen keine Objekte 
mit <tt>new</tt> erzeugt werden.</antwort>
        </faq>
        <faq>
          <frage>Wie kann ich dann Objekte einer abstrakten Klassen erzeugen und wozu
haben die dann Konstruktoren?</frage>
          <antwort>Indem Objekte einer nicht abstrakten Unterklasse 
mit <tt>new</tt> erzeugt werden. Im Konstrukor der Unterklasse wird ein
Konstruktor der abstrakten Oberklasse aufgerufen.</antwort>
        </faq>
        <faq>
          <frage>Kann eine Klasse mehrere abstrakte Oberklassen haben?</frage>
          <antwort>Nein, auch abstrakte Klassen sind Klassen und es gilt die Regel: jede
Klasse hat genau eine Oberklasse.</antwort>
        </faq>
        <faq>
          <frage>Kann ich in einer abstrakten Klasse abstrakte Methoden aufrufen?</frage>
          <antwort>Ja, im Rumpf einer nicht-abstrakten Methode können bereits abstrakte
Klassen aufgerufen werden.</antwort>
        </faq>
        <faq>
          <frage>Was sind Schnittstellen?</frage>
          <antwort>Man kann Schnittstellen als abstrakte Klassen ansehen, in denen jeder
Methode abstrakt ist.</antwort>
        </faq>
        <faq>
          <frage>Warum gibt es dann Schnittstellen?</frage>
          <antwort>Schnittstellen gelten nicht als Klassen. Eine Klasse kann nur eine
Oberklasse haben, aber zusätzlich mehrere Schnittstellen 
implementieren.</antwort>
        </faq>
        <faq>
          <frage>Wie wird deklariert, daß eine Klasse eine Schnitstelle implementiert?</frage>
          <antwort>Durch die <tt>implements</tt>-Klausel in der Klassendeklaration. In
ihr können mehrere Komma getrennte Schnittstellen angegeben werden. </antwort>
        </faq>
        <faq>
          <frage>Kann eine Schnittstelle eine Oberklasse haben?</frage>
          <antwort>Nein.</antwort>
        </faq>
        <faq>
          <frage>Kann eine Schnittstelle weitere Oberschnittstellen haben.</frage>
          <antwort>Ja, diese werden in der <tt>extends</tt>-Klausel angegeben.</antwort>
        </faq>
        <faq>
          <frage>Muß eine Klasse die eine Schnittstelle implementiert alle Methoden der
Schnittstelle implementieren?</frage>
          <antwort>Im Prinzip ja, jedoch nicht, wenn die Klasse selbst abstrakt ist.</antwort>
        </faq>
        <faq>
          <frage>Haben Schnittstellen auch Objektfelder?</frage>
          <antwort>Nein! Nur Methoden und statische Felder.</antwort>
        </faq>
        <faq>
          <frage>Gibt es Zeiger?</frage>
          <antwort>Explizit nicht. Implizit wird außer bei Werten primitiver Typen immer
mit Referenzen auf Objekte gearbeitet.</antwort>
        </faq>
        <faq>
          <frage>Sind alle Daten in Java Objekte?</frage>
          <antwort>Nein, es gibt 8 primitive Typen, deren Daten keine Objekte sind. Es
gibt aber zu jeden dieser 8 primitiven Typen eine Klasse, die die Daten
entsprechend als Objekt speichern.</antwort>
        </faq>
        <faq>
          <frage>Welches sind die primitiven Typen?</frage>
          <antwort>byte, short, int, long, double, float, char, boolean</antwort>
        </faq>
        <faq>
          <frage>Sind Strings Objekte?</frage>
          <antwort>Ja, die Klasse String ist eine Klasse wie Du und ich.</antwort>
        </faq>
        <faq>
          <frage>Sind Reihungen (arrays) Objekte?</frage>
          <antwort>Ja, und sie haben sogar ein Attribut, das ihre Länge speichert. </antwort>
        </faq>
        <faq>
          <frage>Was sind generische Typen?</frage>
          <antwort>Klassen oder Schnittstellen, in denen ein oder mehrere Typen variabel
gehalten sind.</antwort>
        </faq>
        <faq>
          <frage>Wie erzeugt man Objekte einer generischen Klasse? </frage>
          <antwort>Indem beim Konstruktoraufruf in spitzen Klammern konkrete Typen für
die Typvariablen angegeben werden.</antwort>
        </faq>
        <faq>
          <frage>Was passiert, wenn ich für generische Typen die spitzen Klammern bei
der Benutzung weglasse?</frage>
          <antwort>Dann gibt der Compiler eine Warnung und nimmt den allgemeinsten Typ
für die Typvariablen an. Meistens ist das der Typ <tt>Object</tt>.</antwort>
        </faq>
        <faq>
          <frage>Was sind generische Methoden?</frage>
          <antwort>Methoden in denen ein oder mehrere Parametertypen variabel gehalten
sind. </antwort>
        </faq>
        <faq>
          <frage>Muß ich bei der Benutzung von generischen Methoden die konkreten Typen
für die Typvariablen mit angeben?</frage>
          <antwort>Anders als beim Konstruktoraufruf für generische Klassen nicht.</antwort>
        </faq>
        <faq>
          <frage>Was passiert, wenn ich sie nicht angebe?</frage>
          <antwort>Dann inferriert der Typchecker die konkreten Typen, sofern das
möglich ist.</antwort>
        </faq>
        <faq>
          <frage>Was sind typische Beispiel für generische Typen? </frage>
          <antwort>Alle Sammlungsklassen und Abbildungsklassen im 
Paket <tt>java.util</tt>, zB die Klassen <tt>ArrayList</tt>,<tt>LinkedList</tt>, <tt>HashSet</tt>, <tt>Vector</tt> oder die Schnittstellen <tt>List</tt>, <tt>Map</tt>, <tt>Set</tt>.</antwort>
        </faq>
        <faq>
          <frage>Wo wir gerade dabei sind. Was sollte ich bei der 
Klasse <tt>Vector</tt> beachten?</frage>
          <antwort>In 90\% der Fälle ist ein Objekt der 
Klasse <tt>ArrayList</tt> einem Objekt der 
Klasse <tt>Vector</tt> vorzuziehen. <tt>Vector</tt> ist eine sehr alte
Klasse. Ihre Objekte sind synchronisiert, die anderen Sammlungsklassen nicht,
es lassen sich von den anderen Sammlungsklassen allerdings synchronisierte
Kopien machen. Am besten <tt>Vector</tt> gar nie benutzen.</antwort>
        </faq>
        <faq>
          <frage>Was ist automatisches Boxing und Unboxing?</frage>
          <antwort>Die Konvertierung von Daten primitiver Typen in Objekte der
korrespondierenden Klassen und umgekehrt wird automatisch 
vorgenommen.</antwort>
        </faq>
        <faq>
          <frage>Welche zusammengesetzten Befehle gibt es? </frage>
          <antwort>if, while, for, switch</antwort>
        </faq>
        <faq>
          <frage>Was hat es mit der besonderen for-Schleife auf sich?</frage>
          <antwort>Es handelt sich um eine sogenannte for-each-Schleife. Syntaktisch
trennt hier ein Doppelpunkt die lokale Schleifenvariable das Sammlungsobjekt. </antwort>
        </faq>
        <faq>
          <frage>Für welche Objekte kann die for-each-Schleife benutzt werden?</frage>
          <antwort>Für alle Objekte, die die Schnittstelle <tt>Iterable</tt>
implementieren und für Reihungen.</antwort>
        </faq>
        <faq>
          <frage>Bedeutet das, ich kann die for-each Schleife auch für meine Klassen benutzen?</frage>
          <antwort>Ja, genau, man muß nur die Schnittstelle <tt>Iterable</tt> hierzu implementieren.</antwort>
        </faq>
        <faq>
          <frage>Können Operatoren überladen oder neu definiert werden?</frage>
          <antwort>Nein.</antwort>
        </faq>
        <faq>
          <frage>Was sind Ausnahme?</frage>
          <antwort>Objekte von Unterklassen der Klasse <tt>Exception</tt>. Zusätzlich
gibt es die Klasse  <tt>Error</tt> und die gemeinsame Klasse<tt>Throwable</tt>. </antwort>
        </faq>
        <faq>
          <frage>Wozu sind Ausnahmen gut?</frage>
          <antwort>Um in bestimmten Situationen mit einem <tt>throw</tt> Befehl den
Programmfluß abzubrechen um eine besondere Ausnahmesituation zu 
signalisieren. </antwort>
        </faq>
        <faq>
          <frage>Was für Objekte dürfen in eine <tt>throw</tt> geworfen werden?</frage>
          <antwort>Nur Objekte einer Unterklasse von <tt>Throwable</tt>.</antwort>
        </faq>
        <faq>
          <frage>Wie werden geworfene Ausnahme behandelt?</frage>
          <antwort>Indem man sie innerhalb eines <tt>try</tt>-<tt>catch</tt>-Konstruktes
wieder abfängt.</antwort>
        </faq>
        <faq>
          <frage>Kann man auf unterschiedliche Ausnahmen in einem <tt>catch</tt>
unterschiedlich reagieren?</frage>
          <antwort>Ja, einfach mehrere <tt>catch</tt> untereinanderschreiben. Das als
erstes zutreffende <tt>catch</tt> ist dann aktiv.</antwort>
        </faq>
        <faq>
          <frage>Was ist das mit dem <tt>finally</tt> beim <tt>try-catch</tt>?</frage>
          <antwort>Hier kann Code angegeben werden, der immer ausgeführt werden soll,
egal ob und welche Ausnahme aufgetreten ist. Dieses ist sinnvoll um eventuell
externe Verbindungen und ähnliches immer sauber zu schließen.</antwort>
        </faq>
        <faq>
          <frage>Darf man beliebig Ausnahmen werfen?</frage>
          <antwort>Ausnahmen, die nicht in einem <tt>catch</tt> abgefangen werden müssen
in der <tt>throws</tt>-Klausel einer Methode deklariert werden.</antwort>
        </faq>
        <faq>
          <frage>Alle?</frage>
          <antwort>Nein, Ausnahmeobjekte von <tt>RuntimeException</tt> dürfen auch
geworfen werden, wenn sie nicht in der <tt>throws</tt>-Klausel einer Methode
stehen. </antwort>
        </faq>
        <faq>
          <frage>Wozu sind Pakete da?</frage>
          <antwort>Unter anderen damit man nicht Milliarden von Klassen in einem Ordner 
hat und dabei die Übersicht verliert. </antwort>
        </faq>
        <faq>
          <frage>Ist mir egal. Pakete sind mir zu umständlich.</frage>
          <antwort>Das ist aber dumm, wenn man Klassen gleichen Namens aus verschiedenen
Bibliotheken 
benutzen will. Die kann man nur unterscheiden, wenn sie in verschiedenen
Paketen sind.</antwort>
        </faq>
        <faq>
          <frage>OK, ich sehs ein. Wie nenne ich mein Paket?</frage>
          <antwort>Am besten die eigene Webdomain rückwärsts nehmen also für uns an der
FH: <tt>de.fhwiesbaden.informatik.panitz.meineApplikation</tt></antwort>
        </faq>
        <faq>
          <frage>Da fehlt doch der Bindestrich.</frage>
          <antwort>Der ist kein gültiges Zeichen innerhalb eines Bezeichners in Java (es
ist ja der Minusoperator). Bindestriche in Webadressen sind eine recht
deutsche Krankheit.</antwort>
        </faq>
        <faq>
          <frage>Muß ich imports machen um Klassen aus anderen Paketen zu benutzen?</frage>
          <antwort>Nein. Das macht die Sache nur bewuemer, weil sonst der Klassenname
immer und überall komplett mit seinem Paket angegeben werden muß, auch beim
Konstruktoraufruf oder z.B. <tt>instanceof</tt>.</antwort>
        </faq>
        <faq>
          <frage>Machen Import-Anweisungen das Programm langsamer oder größer?</frage>
          <antwort>Nein! Sie haben insbesondere nichts mit includes in C gemein. Sie
entsprechen eher dem <tt>using namespace</tt> aus C++.</antwort>
        </faq>
        <faq>
          <frage>Da gibt es doch auch noch <tt>public</tt>, <tt>private</tt> und <tt>protected</tt>. </frage>
          <antwort>Jaja, die Sichtbarkeiten. Hinzu kommt, wenn man keine Sichtbarkeit
hinschreibt. <tt>public</tt> heißt von überall aufrufbar, <tt>protected</tt> heißt in Unterklassen und gleichem Paket aufrufbar, <tt>package</tt> das ist wenn man nichts hinschreibt, heißt nur im gleichen Paket
sichtbar, und <tt>private</tt> nur in der Klasse.</antwort>
        </faq>
        <faq>
          <frage>Und dann war da noch das <tt>final</tt>.</frage>
          <antwort>Das hat zwei Bedeutungen: bei Variablen und Feldern, daß sie nur
einmal einen Wert zugewiesen bekommen, bei Klassen, daß keine Unterklassen von
der Klasse definiert werden</antwort>
        </faq>
        <faq>
          <frage>Ich will GUIs programmieren.</frage>
          <antwort>Wunderbar, da gibt es zwei Bibliotheken: Swing und AWT.</antwort>
        </faq>
        <faq>
          <frage>Na toll, warum zwei?</frage>
          <antwort>Historisch.</antwort>
        </faq>
        <faq>
          <frage>Und welche sol ich jetzt benutzen?</frage>
          <antwort>Swing!</antwort>
        </faq>
        <faq>
          <frage>Also kann ich alles über AWT vergessen, insbesondere das 
Paket <tt>java.awt</tt>? </frage>
          <antwort>Nein. Swing benutzt große Teile aus AWT. Insbesondere hat jede
Swingkomponente eine Oberklasse aus AWT. Aber auch die
Ereignisbehandlungsklassen werden 
vollständig aus AWT benutzt.</antwort>
        </faq>
        <faq>
          <frage>Und woran erkenne ich jetzt, wann ich Komponente aus AWT bnutzen muß,
obwohl ich in Swing programmiere?</frage>
          <antwort>Alle graphischen AWT-Komponenten haben ein Swing Pendant, das mit dem
dem Buchstaben <tt>J</tt> beginnt, z.B. <tt>javax.swing.JButton</tt> im
Gegensatz zu <tt>java.awt.Button</tt>.</antwort>
        </faq>
        <faq>
          <frage>Sonst noch paar Tipps, zum benutzen von Swing?</frage>
          <antwort>Keine eigenen Threads schreiben! Nicht die 
Methode <tt>paint</tt> sondern <tt>paintComponent</tt> überschreiben.</antwort>
        </faq>
        <faq>
          <frage>Toll, wenn ich keine Threads schreiben soll, wie mache ich dann
z.B. zeitgesteuerte Ereignisse in Swing?</frage>
          <antwort>Da gibt es die Klasse <tt>javax.swing.Timer</tt> für.</antwort>
        </faq>
        <faq>
          <frage>Ich will XML verarbeiten.</frage>
          <antwort>Kein Problem, alles vorhanden, soll es das DOM-Api oder SAX sein?</antwort>
        </faq>
        <faq>
          <frage>Weiß nicht? Was ist der Unterschied?</frage>
          <antwort>In DOM wird eine Baumstruktur für ein XML-Dokument im Speicher
aufgebaut. Mit der kann man alles machen, was man mit einem Baum machen kann.</antwort>
        </faq>
        <faq>
          <frage>Super. Wozu ist dann SAX?</frage>
          <antwort>Oft braucht man nie die ganze Baumstruktur, sondern muß das Dokument
nur einmal von vorne nach hinten durcharbeiten. Dabei hilft SAX</antwort>
        </faq>
        <faq>
          <frage>Ist dann effizienter schätze ich?</frage>
          <antwort>Ganz genau, insbesondere wird viel weniger Speicher 
benötigt. </antwort>
        </faq>
        <faq>
          <frage>Na ich weiß nicht, ob ich jetzt genügend weiß für die Klausur?</frage>
          <antwort>Das weiß ich auch nicht, über alles haben wir hier nicht
gesprochen. Ich denke aber  es reicht an Wissen aus.</antwort>
        </faq>
      </faqs>
    </kapitel>
    <kapitel titel = "Wörterliste">
      <wortliste>
        <erklaerung>In dieser Mitschrift habe  ich mich bemüht, soweit
existent oder naheliegend, deutsche Ausdrücke für die vielen in der
Informatik auftretenden englischen Fachbegriffe zu benutzen. Dieses ist
nicht aus einem nationalen Chauvinismus heraus, sondern 
für eine flüssige Lesbarkeit des Textes geschehen. Ein mit sehr vielen
englischen Wörtern durchsetzter Text ist schwerer zu lesen, insbesondere
auch für Menschen, deren Muttersprache nicht deutsch ist.<p/>

Es folgen hier 
Tabellen der verwendeten deutschen Ausdrücke mit ihrer englischen
Entsprechung. </erklaerung>
        <wliste>
          <entry>
            <deutsch>Klasse</deutsch>
            <english>class</english>
          </entry>
          <entry>
            <deutsch>Schnittstelle</deutsch>
            <english>interface</english>
          </entry>
          <entry>
            <deutsch>Eigenschaft</deutsch>
            <english>feature</english>
          </entry>
          <entry>
            <deutsch>Feld</deutsch>
            <english>field</english>
          </entry>
          <entry>
            <deutsch>Methode</deutsch>
            <english>method</english>
          </entry>
          <entry>
            <deutsch>Blubbersortierung</deutsch>
            <english>bubble sort</english>
          </entry>
          <entry>
            <deutsch>Übersetzer</deutsch>
            <english>compiler</english>
          </entry>
          <entry>
            <deutsch>Interpreter</deutsch>
            <english>interpreter</english>
          </entry>
          <entry>
            <deutsch>Behälter</deutsch>
            <english>container</english>
          </entry>
          <entry>
            <deutsch>Zeichenkette</deutsch>
            <english>string</english>
          </entry>
          <entry>
            <deutsch>Sammlung</deutsch>
            <english>collection</english>
          </entry>
          <entry>
            <deutsch>Ausnahme</deutsch>
            <english>exception</english>
          </entry>
          <entry>
            <deutsch>Erreichbarkeit</deutsch>
            <english>visibility</english>
          </entry>
          <entry>
            <deutsch>Sichtbarkeit</deutsch>
            <english>visibility</english>
          </entry>
          <entry>
            <deutsch>Modellierung</deutsch>
            <english>design</english>
          </entry>
          <entry>
            <deutsch>Paket</deutsch>
            <english>package</english>
          </entry>
          <entry>
            <deutsch>Befehl</deutsch>
            <english>statement</english>
          </entry>
          <entry>
            <deutsch>Ausdruck</deutsch>
            <english>expression</english>
          </entry>
          <entry>
            <deutsch>Zuweisung</deutsch>
            <english>assignment</english>
          </entry>
          <entry>
            <deutsch>Typzusicherung</deutsch>
            <english>type cast</english>
          </entry>
          <entry>
            <deutsch>Kommandozeile</deutsch>
            <english>command line</english>
          </entry>
          <entry>
            <deutsch>Rückgabetyp</deutsch>
            <english>return type</english>
          </entry>
          <entry>
            <deutsch>Typ</deutsch>
            <english>type</english>
          </entry>
          <entry>
            <deutsch>Ordner</deutsch>
            <english>folder</english>
          </entry>
          <entry>
            <deutsch>Datei</deutsch>
            <english>file</english>
          </entry>
          <entry>
            <deutsch>Deklaration</deutsch>
            <english>declaration</english>
          </entry>
          <entry>
            <deutsch>Verzeichnis</deutsch>
            <english>directory</english>
          </entry>
          <entry>
            <deutsch>Reihung</deutsch>
            <english>array</english>
          </entry>
          <entry>
            <deutsch>Unterklasse</deutsch>
            <english>subclass</english>
          </entry>
          <entry>
            <deutsch>Oberklasse</deutsch>
            <english>superclass</english>
          </entry>
          <entry>
            <deutsch>geschützt</deutsch>
            <english>protected</english>
          </entry>
          <entry>
            <deutsch>öffentlich</deutsch>
            <english>public</english>
          </entry>
          <entry>
            <deutsch>privat</deutsch>
            <english>private</english>
          </entry>
          <entry>
            <deutsch>Auswertung</deutsch>
            <english>evaluation</english>
          </entry>
          <entry>
            <deutsch>Attribut</deutsch>
            <english>modifier</english>
          </entry>
          <entry>
            <deutsch>Schleife</deutsch>
            <english>loop</english>
          </entry>
          <entry>
            <deutsch>Bedingung</deutsch>
            <english>condition</english>
          </entry>
          <entry>
            <deutsch>Hauruckverfahren</deutsch>
            <english>bruteforce</english>
          </entry>
          <entry>
            <deutsch>Rumpf</deutsch>
            <english>body</english>
          </entry>
          <entry>
            <deutsch>Fabrikmethode</deutsch>
            <english>factory method</english>
          </entry>
          <entry>
            <deutsch>vollqualifizierter Name</deutsch>
            <english>fully qualified name</english>
          </entry>
          <entry>
            <deutsch>Keller</deutsch>
            <english>stack</english>
          </entry>
          <entry>
            <deutsch>Aufrufkeller</deutsch>
            <english>stack trace</english>
          </entry>
          <entry>
            <deutsch>Abbildung</deutsch>
            <english>map</english>
          </entry>
          <entry>
            <deutsch>Strom</deutsch>
            <english>stream</english>
          </entry>
          <entry>
            <deutsch>Menge</deutsch>
            <english>set</english>
          </entry>
          <entry>
            <deutsch>Zeichen</deutsch>
            <english>character</english>
          </entry>
          <entry>
            <deutsch>Steuerfaden</deutsch>
            <english>thread</english>
          </entry>
          <entry>
            <deutsch>Verklemmung</deutsch>
            <english>dead lock</english>
          </entry>
          <entry>
            <deutsch>Implementierung</deutsch>
            <english>implementation</english>
          </entry>
          <entry>
            <deutsch>Puffer</deutsch>
            <english>buffer</english>
          </entry>
          <entry>
            <deutsch>nebenläufig</deutsch>
            <english>concurrent</english>
          </entry>
          <entry>
            <deutsch>strikt</deutsch>
            <english>strict</english>
          </entry>
          <entry>
            <deutsch>faul</deutsch>
            <english>lazy</english>
          </entry>
        </wliste>
      </wortliste>
    </kapitel>
    <alleaufgaben/>
    <printindex name = "Klassen"
                titel = "Klassenverzeichnis"/>
    <listoffigures/>
    <bibliography/>
  </anhang>
</skript>